Description: Upstream changes introduced in version 4~svn156-0gz1
 This patch has been created by dpkg-source during the package build.
 Here's the last changelog entry, hopefully it gives details on why
 those changes were made:
 .
 sdr-shell (4~svn156-0gz1) unstable; urgency=low
 .
   * Adjusted version numbers, debianized package.
 .
 The person named in the Author field signed this changelog entry.
Author: Dr. Gerolf Ziegenhain <g@ziegenhain.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- sdr-shell-4~svn156.orig/logo.xpm
+++ sdr-shell-4~svn156/logo.xpm
@@ -1,5 +1,5 @@
 /* XPM */
-static char *logo_xpm[]={
+static const char *logo_xpm[]={
 "88 27 5 1",
 ". c #000000",
 "# c #00ff00",
--- /dev/null
+++ sdr-shell-4~svn156/hook-mode
@@ -0,0 +1,60 @@
+#!/bin/sh
+
+#
+# Establish JACK connections for CW and PHONE modes
+#
+
+mode=$1
+echo set_mode_hook: mode $mode
+
+phil=system:capture_3
+phir=system:capture_4
+#read phil phir < .phinput
+echo phone: il= $phil  ir= $phir
+
+cwil=kkyr:ol
+cwir=kkyr:or
+#read cwil cwir < .cwinput
+echo cw: il= $cwil  ir= $cwir
+
+case $mode in
+CW )
+	echo CW Mode
+	set -x
+	jack_disconnect $phil sdr-tx:il
+	jack_disconnect $phir sdr-tx:ir
+	jack_connect $cwil sdr-tx:il        
+	jack_connect $cwir sdr-tx:ir
+	#jack_connect system:capture_3 sdr-tx:il        
+	#jack_connect system:capture_4 sdr-tx:ir
+	set +x
+;;
+
+METRO )
+	echo METRONOME Mode
+	set -x
+	jack_metro -b 60 &
+	jack_disconnect $phil sdr-tx:il
+	jack_disconnect $phir sdr-tx:ir
+	jack_disconnect $cwil sdr-tx:il
+	jack_disconnect $cwir sdr-tx:ir
+	jack_connect metro:60_bpm sdr-tx:il        
+	jack_connect metro:60_bpm sdr-tx:ir
+	#jack_connect system:capture_3 sdr-tx:il        
+	#jack_connect system:capture_4 sdr-tx:ir
+	set +x
+;;
+
+* )
+	echo PHONE Mode
+	set -x
+	jack_disconnect $cwil sdr-tx:il
+	jack_disconnect $cwir sdr-tx:ir
+	jack_disconnect metro:60_bpm sdr-tx:il
+	jack_disconnect metro:60_bpm sdr-tx:ir
+	jack_connect $phil sdr-tx:il        
+	jack_connect $phir sdr-tx:ir
+	set +x
+;;
+esac
+
--- sdr-shell-4~svn156.orig/pbscale.h
+++ sdr-shell-4~svn156/pbscale.h
@@ -2,14 +2,17 @@
 #define SDXCVR_PBSCALE_H
 
 #include <qwidget.h>
+#include <QMouseEvent>
 
 class PassBandScale : public QWidget
 {
     Q_OBJECT
     
     public:
-	PassBandScale(QWidget *parent = 0, const char *name = 0, WFlags f = 0 );
-
+//    PassBandScale(QWidget *parent = 0, const char *name = 0, WFlags f = 0 );
+//    PassBandScale(QWidget *parent = 0, const char *name = 0);
+    PassBandScale(QWidget *parent = 0);
+    
     private:
         int x0;
 
--- /dev/null
+++ sdr-shell-4~svn156/trxwidget.h
@@ -0,0 +1,81 @@
+/***************************************************************************
+                          trxwidget.h  -  description
+                             -------------------
+    begin                : Sat May 18 2002
+    copyright            : (C) 2002 by Luc Langehegermann
+    email                : lx2gt@qsl.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef TRXWIDGET_H
+#define TRXWIDGET_H
+
+#include <sys/types.h>
+#include <sys/ipc.h>
+#include <sys/msg.h>
+#include <qwidget.h>
+#include "trxwidgetbase.h"
+#include "rigctrl.h"
+#include "dcopinterface.h"
+
+
+/**Transceiver widget - displays frequencies and let you chose the transponder
+  *@author Luc Langehegermann
+  */
+
+typedef struct
+{
+  long mtype;                   /* mtype should always be 88 */
+  char mtext[1024];             /* mtext holds the message */
+} msgtype;
+
+class trxWidget : public trxWidgetBase, virtual public DCOPInterface {
+   Q_OBJECT
+public: 
+	trxWidget(QWidget *parent=0, const char *name=0);
+	~trxWidget();
+  /** sets the radio control device we should use */
+  void setDevice(rigctrl* dev);
+private:
+  rigctrl* trxctrl;
+  satellite* sat;
+  // these values are available for the DCOP interface
+  double uplinkfrequency, downlinkfrequency;
+  QString mode,satname;
+  int msgid;
+  msgtype msgbuf;
+  transponder* currenttransponder;
+  QString lastmsg;
+public slots:
+  void slotNewHardwareDownlinkFrequency(double freq);
+  void slotNewHardwareUplinkFrequency(double freq);
+private slots: // Private slots
+  void slotNewUplinkFrequency(double freq);
+  void slotNewDownlinkFrequency(double freq);
+  void newTransponder(int id);
+  void newCorrection(int c);
+  void sendToXlog();
+public:
+  /** sets the satellite we use to get informations about */
+  void setSatellite(satellite* s);
+  /** call this, if the transponderlist changed */
+  void updateTransponderList();
+  // DCOP Interface functions
+  double getUplinkFrequency();
+  double getDownlinkFrequency();
+  QString getMode();
+  QString getSatellite();
+private: // Private methods
+  /** No descriptions */
+  QString dottedFrequency(double freq);
+};
+
+#endif
--- /dev/null
+++ sdr-shell-4~svn156/Makefile.osx
@@ -0,0 +1,297 @@
+#############################################################################
+# Makefile for building: sdr-shell
+# Generated by qmake (1.07a) (Qt 3.3.8b) on: Sat Nov 28 00:10:02 2009
+# Project:  sdr-shell.pro
+# Template: app
+# Command: $(QMAKE) -o Makefile sdr-shell.pro
+#############################################################################
+
+####### Compiler, tools and options
+
+CC       = gcc
+CXX      = g++
+LEX      = flex
+YACC     = yacc
+CFLAGS   = -pipe -Wall -W -g  -DQT_SHARED -DQT_TABLET_SUPPORT -DQT_NO_DEBUG -DQT_THREAD_SUPPORT
+CXXFLAGS = -pipe -Wall -W -g  -DQT_SHARED -DQT_TABLET_SUPPORT -DQT_NO_DEBUG -DQT_THREAD_SUPPORT
+LEXFLAGS = 
+YACCFLAGS= -d
+QTDIR=/sw/lib/qt3
+#INCPATH  = -I/usr/lib64/qt-3.3/mkspecs/default -I. -I. -I$(QTDIR)/include
+INCPATH  = -I$(QTDIR)/mkspecs/default -I. -I. -I /Users/glen/sdr/include -I$(QTDIR)/include
+LINK     = g++
+LFLAGS   = 
+#LIBS     = $(SUBLIBS) -L$(QTDIR)/lib `pkg-config --cflags --libs hamlib` -lqt-mt -lXext -lX11 -lm
+LIBS     = $(SUBLIBS) -L$(QTDIR)/lib -lqt-mt -lqui -L/usr/X11/lib -lXext -lX11 -lm -L/Users/glen/sdr/lib -lhamlib
+AR       = ar cqs
+RANLIB   = 
+MOC      = $(QTDIR)/bin/moc
+UIC      = $(QTDIR)/bin/uic
+QMAKE    = qmake
+TAR      = tar -cf
+GZIP     = gzip -9f
+COPY     = cp -f
+COPY_FILE= $(COPY)
+COPY_DIR = $(COPY) -r
+INSTALL_FILE= $(COPY_FILE)
+INSTALL_DIR = $(COPY_DIR)
+DEL_FILE = rm -f
+SYMLINK  = ln -sf
+DEL_DIR  = rmdir
+MOVE     = mv -f
+CHK_DIR_EXISTS= test -d
+MKDIR    = mkdir -p
+
+####### Output directory
+
+OBJECTS_DIR = ./
+
+####### Files
+
+HEADERS = main_widget.h \
+		spectrogram.h \
+		varilabel.h \
+		memorycell.h \
+		pbscale.h \
+		sunpropagator.h \
+		moonpropagator.h \
+		worldmap.h \
+		spectrum.h \
+		text.h \
+		hamlibwrapper.h \
+		dttsp.h
+SOURCES = main.cpp \
+		main_widget.cpp \
+		spectrogram.cpp \
+		varilabel.cpp \
+		memorycell.cpp \
+		spectrum.cpp \
+		hamlibwrapper.cpp \
+		pbscale.cpp \
+		sunpropagator.cpp \
+		moonpropagator.cpp \
+		worldmap.cpp \
+		dttsp.cpp
+OBJECTS = main.o \
+		main_widget.o \
+		spectrogram.o \
+		varilabel.o \
+		memorycell.o \
+		spectrum.o \
+		hamlibwrapper.o \
+		pbscale.o \
+		sunpropagator.o \
+		moonpropagator.o \
+		worldmap.o \
+		dttsp.o
+FORMS = 
+UICDECLS = 
+UICIMPLS = 
+SRCMOC   = moc_main_widget.cpp \
+		moc_spectrogram.cpp \
+		moc_varilabel.cpp \
+		moc_memorycell.cpp \
+		moc_pbscale.cpp \
+		moc_worldmap.cpp \
+		moc_spectrum.cpp \
+		moc_hamlibwrapper.cpp
+OBJMOC = moc_main_widget.o \
+		moc_spectrogram.o \
+		moc_varilabel.o \
+		moc_memorycell.o \
+		moc_pbscale.o \
+		moc_worldmap.o \
+		moc_spectrum.o \
+		moc_hamlibwrapper.o
+DIST	   = test \
+		KL7NA_Notes \
+		sdr-shell.pro
+QMAKE_TARGET = sdr-shell
+DESTDIR  = 
+TARGET   = sdr-shell
+
+first: all
+####### Implicit rules
+
+.SUFFIXES: .c .o .cpp .cc .cxx .C
+
+.cpp.o:
+	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o $@ $<
+
+.cc.o:
+	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o $@ $<
+
+.cxx.o:
+	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o $@ $<
+
+.C.o:
+	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o $@ $<
+
+.c.o:
+	$(CC) -c $(CFLAGS) $(INCPATH) -o $@ $<
+
+####### Build rules
+
+all: Makefile $(TARGET)
+
+$(TARGET):  $(UICDECLS) $(OBJECTS) $(OBJMOC)  
+	$(LINK) $(LFLAGS) -o $(TARGET) $(OBJECTS) $(OBJMOC) $(OBJCOMP) $(LIBS)
+
+mocables: $(SRCMOC)
+uicables: $(UICDECLS) $(UICIMPLS)
+
+$(MOC): 
+	( cd $(QTDIR)/src/moc && $(MAKE) )
+
+#Makefile: sdr-shell.pro  /usr/lib64/qt-3.3/mkspecs/default/qmake.conf /usr/lib64/qt-3.3/lib/libqt-mt.prl
+Makefile: sdr-shell.pro
+	$(QMAKE) -o Makefile sdr-shell.pro
+qmake: 
+	@$(QMAKE) -o Makefile sdr-shell.pro
+
+dist: 
+	@mkdir -p .tmp/sdr-shell && $(COPY_FILE) --parents $(SOURCES) $(HEADERS) $(FORMS) $(DIST) .tmp/sdr-shell/ && ( cd `dirname .tmp/sdr-shell` && $(TAR) sdr-shell.tar sdr-shell && $(GZIP) sdr-shell.tar ) && $(MOVE) `dirname .tmp/sdr-shell`/sdr-shell.tar.gz . && $(DEL_FILE) -r .tmp/sdr-shell
+
+mocclean:
+	-$(DEL_FILE) $(OBJMOC)
+	-$(DEL_FILE) $(SRCMOC)
+
+uiclean:
+
+yaccclean:
+lexclean:
+clean: mocclean
+	-$(DEL_FILE) $(OBJECTS)
+	-$(DEL_FILE) *~ core *.core
+
+
+####### Sub-libraries
+
+distclean: clean
+	-$(DEL_FILE) $(TARGET) $(TARGET)
+
+
+FORCE:
+
+####### Compile
+
+main.o: main.cpp main_widget.h \
+		app.xpm \
+		spectrogram.h \
+		spectrum.h \
+		varilabel.h \
+		memorycell.h \
+		worldmap.h \
+		pbscale.h \
+		hamlibwrapper.h \
+		dttsp.h \
+		sunpropagator.h \
+		moonpropagator.h \
+		constants.h
+
+main_widget.o: main_widget.cpp main_widget.h \
+		switches.h \
+		modes.h \
+		agc.h \
+		meter1.xpm \
+		mhz.xpm \
+		rx.xpm \
+		tx.xpm \
+		logo.xpm \
+		text.h \
+		dttsp.h \
+		spectrogram.h \
+		spectrum.h \
+		varilabel.h \
+		memorycell.h \
+		worldmap.h \
+		pbscale.h \
+		hamlibwrapper.h \
+		sunpropagator.h \
+		moonpropagator.h \
+		constants.h
+
+spectrogram.o: spectrogram.cpp spectrogram.h
+
+varilabel.o: varilabel.cpp varilabel.h
+
+memorycell.o: memorycell.cpp memorycell.h
+
+spectrum.o: spectrum.cpp spectrum.h
+
+hamlibwrapper.o: hamlibwrapper.cpp hamlibwrapper.h
+
+pbscale.o: pbscale.cpp pbscale.h
+
+sunpropagator.o: sunpropagator.cpp sunpropagator.h \
+		constants.h
+
+moonpropagator.o: moonpropagator.cpp moonpropagator.h \
+		constants.h
+
+worldmap.o: worldmap.cpp worldmap.h \
+		world.xpm \
+		sunpropagator.h \
+		moonpropagator.h \
+		constants.h
+
+dttsp.o: dttsp.cpp dttsp.h
+
+moc_main_widget.o: moc_main_widget.cpp  main_widget.h spectrogram.h \
+		spectrum.h \
+		varilabel.h \
+		memorycell.h \
+		worldmap.h \
+		pbscale.h \
+		hamlibwrapper.h \
+		dttsp.h \
+		sunpropagator.h \
+		moonpropagator.h \
+		constants.h
+
+moc_spectrogram.o: moc_spectrogram.cpp  spectrogram.h 
+
+moc_varilabel.o: moc_varilabel.cpp  varilabel.h 
+
+moc_memorycell.o: moc_memorycell.cpp  memorycell.h 
+
+moc_pbscale.o: moc_pbscale.cpp  pbscale.h 
+
+moc_worldmap.o: moc_worldmap.cpp  worldmap.h sunpropagator.h \
+		moonpropagator.h \
+		constants.h
+
+moc_spectrum.o: moc_spectrum.cpp  spectrum.h 
+
+moc_hamlibwrapper.o: moc_hamlibwrapper.cpp  hamlibwrapper.h 
+
+moc_main_widget.cpp: $(MOC) main_widget.h
+	$(MOC) main_widget.h -o moc_main_widget.cpp
+
+moc_spectrogram.cpp: $(MOC) spectrogram.h
+	$(MOC) spectrogram.h -o moc_spectrogram.cpp
+
+moc_varilabel.cpp: $(MOC) varilabel.h
+	$(MOC) varilabel.h -o moc_varilabel.cpp
+
+moc_memorycell.cpp: $(MOC) memorycell.h
+	$(MOC) memorycell.h -o moc_memorycell.cpp
+
+moc_pbscale.cpp: $(MOC) pbscale.h
+	$(MOC) pbscale.h -o moc_pbscale.cpp
+
+moc_worldmap.cpp: $(MOC) worldmap.h
+	$(MOC) worldmap.h -o moc_worldmap.cpp
+
+moc_spectrum.cpp: $(MOC) spectrum.h
+	$(MOC) spectrum.h -o moc_spectrum.cpp
+
+moc_hamlibwrapper.cpp: $(MOC) hamlibwrapper.h
+	$(MOC) hamlibwrapper.h -o moc_hamlibwrapper.cpp
+
+####### Install
+
+install:  
+
+uninstall:  
+
--- sdr-shell-4~svn156.orig/meter1.xpm
+++ sdr-shell-4~svn156/meter1.xpm
@@ -1,5 +1,5 @@
 /* XPM */
-static char *meter1_xpm[]={
+static const char *meter1_xpm[]={
 "193 27 8 1",
 ". c #000000",
 "# c #00ff00",
--- /dev/null
+++ sdr-shell-4~svn156/INSTALL
@@ -0,0 +1,117 @@
+Installation Instructions for sdr-shell-v4 branch.
+
+Distribution Specific Instructions
+
+Fedora 14
+
+(1) Install prerequisite packages with:
+
+	if fedora was installed from the live cd:
+	sudo yum install subversion autoconf gcc gcc-c++
+
+	sudo yum install libtool qt-devel liblo-devel hamlib-devel
+	sudo yum install jack-audio-connection-kit-devel 
+	sudo yum install jack-audio-connection-kit-example-clients
+	sudo yum install qjackctl alsa-util
+
+	depenencies for dttsp:
+		sudo yum install fftw-devel gsl-devel
+
+	dependencies for usbsoftrock:
+		sudo yum install libusb1-devel ncurses-devel
+
+(2) Run 'qmake-qt4' to build the Makefile, then 'make' to build sdr-shell.
+
+(3) Add yourself to the audio and jackusers groups in /etc/group.
+
+(4) Configure udev to set usbsoftrock permissions (see below)
+
+Ubuntu 10.10 / Debian squeeze
+
+(1) From a live CD installation of Ubuntu, Xubuntu or lubuntu, install
+
+   Packages needed to build dttsp:
+	sudo apt-get install automake build-essential subversion 
+	sudo apt-get install libfftw3-dev jackd2 libjack-jackd2-dev
+	sudo apt-get install liblo-dev libgsl0-dev
+
+	When installing jack, answer 'yes' to the question about setting up
+	real-time priorities.
+
+   Packages needed to build usbsoftrock:
+	sudo apt-get install libusb++-dev libncurses5-dev
+
+   Packages needed to build sdr-shell:
+	sudo apt-get install qt4-qmake libqt4-dev libhamlib++-dev pkg-config 
+
+(2) Run 'qmake-qt4' to build the Makefile, then 'make' to build sdr-shell.
+
+(3) Add yourself to the audio and video groups in /etc/group.
+
+	sudo usermod -G audio -a <user>
+	sudo usermod -G video -a <user>
+
+(4) If you did not answer 'yes' to the jack installation question about
+real-time priorities, you may reconfigure it for real-time priorities with:
+
+	sudo dpkg-reconfigure -p high jackd
+
+(5) Configure udev to set usbsoftrock permissions (see below)
+
+(6) Build this package: 
+update-alternatives --set qmake   /usr/bin/qmake-qt4  
+
+All Linux Systems
+
+The following udev rules works well to allow the group softrock to use
+usbsoftrock without root privileges. You can put it in /etc/udev/rules.d
+and call it softrock.rules.
+
+Fedora 9:
+	BUS=="usb", ACTION=="add", SSSYSFS{idVendor}=="16c0", SYSFS{idProduct}=="05dc",
+	MODE="660", GROUP="softrock"
+
+Fedora 12+, openSUSE 11+, Ubuntu 9.10+ needs 
+	SUBSYSTEM=="usb", ACTION=="add", ATTR{idVendor}=="16c0",
+	ATTR{idProduct}=="05dc", MODE="0660", GROUP="admin", SYMLINK="softrock"
+
+the group "softrock" must exist in /etc/group, or substitute another group
+name.
+
+Use jack_metro, a metronome, to figure out which ports are your speakers, etc.
+
+
+Building for OSX 10.6 * not updated for qt4 *
+
+sdr-shell-v4 on OSX doesn't preserve the background of the spectrogram frame.
+
+When setting up to build for OSX, I wanted to use the fink and macports tools
+to get the prerequisite packages.  I had very limited success in getting usable
+prerequisites.  Both fink and macports build their packages in 32-bit (x86)
+mode, while the compiler default on 10.6 is now 64 bit (x86_64) mode.  In order
+to build against its packages requires setting:
+
+	PATH=/sw/var/lib/fink/path-prefix-10.6:$PATH
+
+Note that qt3mac from both package systems does not build on OSX 10.6 (it did
+build on 10.5) and there doesn't appear to be anyone working on it.  Instead, I
+selected 'qt3', which uses x11.
+
+In all, I believe these packages were for building dttsp and sdr-shell:
+  fink:
+	qt3
+  mac ports:
+ 	fftw-3 @3.2.2_0+i386 (active)
+	fftw-3-single @3.2.2_0+i386 (active)
+	gsl @1.13_1+darwin_i386 (active)
+
+The more packages were built from source using the instructions in:
+
+  http://groups.yahoo.com/group/dttsp-linux/files/build-dttsp.sh 
+
+I also had to build hamlib-1.2.9 (I recall having to do something ugly to
+hamlib to get it to compile -- it probably doesn't work).
+
+Get the JACK Audio Connection Kit from from jackosx.com.  I've never
+gotten the JACK in fink or macports to work.
+
--- /dev/null
+++ sdr-shell-4~svn156/freqlabel.cpp
@@ -0,0 +1,43 @@
+#include "freqlabel.h"
+
+Freqlabel::Freqlabel(QWidget *parent) : QLabel(parent)
+{
+    p = this->palette();
+    q = this->palette();
+    p.setColor( QPalette::Window, QColor(0, 0, 0, 0) );
+    this->setPalette(p);
+    // set label background
+    q.setColor( QPalette::Window, QColor(255, 0, 0, 127) );   //transparent red
+//    q.setColor( QPalette::Window, QColor(0, 0, 255, 127) );   //transparent blue
+//    q.setColor( QPalette::Window, QColor(255, 255, 0, 127) ); //transparent yellow
+    this->setAutoFillBackground(true);
+}
+
+bool Freqlabel::event ( QEvent *e )
+{
+  if (e->type() == QEvent::Wheel) {
+     QWheelEvent *wheelEvent = static_cast<QWheelEvent *>(e);
+     if ( wheelEvent->delta() < 0 ) 
+        emit mouseWheel( increment );
+       else
+         emit mouseWheel( -increment );
+     return 0;
+  }
+
+  switch ( e->type() ) {
+
+  case QEvent::Enter:
+       this->setPalette(q);
+       break;
+  case QEvent::Leave:
+       this->setPalette(p);
+       break;
+  default:
+       break;
+  }
+}  
+
+void Freqlabel::setIncrement( int i )
+{
+  increment = i;
+}
--- /dev/null
+++ sdr-shell-4~svn156/hamlibwrapper.cpp
@@ -0,0 +1,259 @@
+/***************************************************************************
+                          hamlibwrapper.cpp  -  description
+                             -------------------
+    begin                : 8/12/07
+    copyright            : (C) 2007 by Rob Frohne, KL7NA with thanks to Luc Langehegermann
+    email                : frohro@wallawalla.edu
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <string.h>
+#include <stdlib.h>
+#include <qapplication.h>
+#include <math.h>
+
+#include "hamlibwrapper.h"
+
+hamlibWrapper::hamlibWrapper ( QObject *parent) : QThread ( parent )
+{
+	rRig=NULL;
+	shouldexit = FALSE;
+	useSlopeTuning = FALSE;
+	rig_set_debug ( RIG_DEBUG_TRACE ); // RIG_DEBUG_NONE for none.
+        connect ( parent, SIGNAL ( changeRigMode ( rmode_t, pbwidth_t ) ), this, SLOT ( setMode ( rmode_t, pbwidth_t ) ) );
+        connect ( parent, SIGNAL ( changeSlopeTune ( bool ) ), this, SLOT ( pollSlopeTuning ( bool ) ) );
+        connect ( parent, SIGNAL ( tellMuteXmit ( bool ) ), this, SLOT ( useMuteXmit ( bool ) ) );
+}
+
+hamlibWrapper::~hamlibWrapper()
+{
+        if ( isRunning() )
+	{
+		shouldexit=true;
+		wait();
+	}
+	if ( rRig )
+	{
+		rig_close ( rRig );
+		rig_cleanup ( rRig );
+	}
+}
+
+
+
+int hamlibWrapper::init ( rig_model_t rig, const char* port, int speed )
+{
+	int retval=0;
+	value_t pitch;
+
+	mutex.lock();
+	if ( rRig ) // Close the rig if it is already open.
+	{
+		rig_close ( rRig );
+		rig_cleanup ( rRig );
+	}
+	// first init the first radio.
+	// if we have no rig... simply init dummy rig! So, we do not have to care if we have an
+	// rig or not!
+	if ( rig ) rRig=rig_init ( rig );
+	// set the parameters
+	rRig->state.rigport.parm.serial.rate=speed;
+	strcpy ( rRig->state.rigport.pathname, port );
+	// open the rig
+	if ( rig_open ( rRig ) != RIG_OK )
+	{
+		fprintf ( stderr, "Error opening radio!\n" );
+		retval--;
+		mutex.unlock();
+		return retval;
+	}
+	if ( rig_get_vfo ( rRig, &vfo ) != RIG_OK )
+	{
+		fprintf ( stderr, "Error getting vfo from radio!\n" );
+		retval--;
+	}
+	if ( rig_get_mode ( rRig, vfo, &mode, &width ) != RIG_OK )
+	{
+		fprintf ( stderr, "Error getting mode from radio!\n" );
+		retval--;
+	}
+	if ( rig_get_level ( rRig, RIG_VFO_CURR, RIG_LEVEL_CWPITCH, &pitch ) != RIG_OK )
+	{
+		fprintf ( stderr, "Error getting mode from radio!\n" );
+		retval--;
+	}
+	emit rigPitch ( pitch.i );
+
+        if ( !isRunning() && rRig )  start();
+	mutex.unlock();
+	return retval;
+}
+
+void hamlibWrapper::setMode ( rmode_t new_mode, pbwidth_t new_width )
+{
+	newMode = new_mode;
+	newWidth = new_width;
+	setmodes=TRUE;
+}
+
+void hamlibWrapper::run()
+{
+	// these are static (args) but we can only have one instance of this!
+	static freq_t oldfreq = 0, fr = 0;
+	int retval;
+	ptt_t oldtrstate = transmit;
+	rmode_t oldmode;
+	int oldSlopeLow = 0, oldSlopeHigh = 0;
+
+	for ( ;; )
+	{
+		if ( shouldexit || !rRig )
+		{
+			shouldexit=false;
+			return;
+		}
+		
+		if ( muteOnXmit )
+		{
+			//mutex.lock();
+			if ( rig_get_ptt ( rRig, vfo, &transmit ) != RIG_OK )
+			{
+				fprintf ( stderr, "Error getting vfo from radio!\n" );
+				retval--;
+			}
+			//mutex.unlock();
+			if ( oldtrstate != transmit )
+			{
+				//mutex.lock();
+				emit nowTransmit ( ( int ) transmit );
+				//mutex.unlock();
+				oldtrstate = transmit;
+			}
+		}
+
+		//mutex.lock(); //Check vfo and mode
+		if ( rig_get_vfo ( rRig, &vfo ) != RIG_OK )
+		{
+			fprintf ( stderr, "Error getting vfo from radio!\n" );
+			retval--;
+		}
+		if ( rig_get_mode ( rRig, vfo, &mode, &width ) != RIG_OK )
+		{
+			fprintf ( stderr, "Error getting vfo from radio!\n" );
+			retval--;
+		}
+		//mutex.unlock();
+		if ( oldmode != mode )
+		{
+			//mutex.lock();
+			emit rigChangedMode ( mode, TRUE );
+			//mutex.unlock();
+			oldmode = mode;
+		}
+		fr=getHardwareFrequency();  //Check frequency
+		if ( fr!=oldfreq )
+		{
+			oldfreq=fr;
+			getfreq=fr;
+			//mutex.lock();
+			emit newFreq ( ( double ) getfreq );
+			//mutex.unlock();
+		}
+
+		if ( useSlopeTuning ) //Check slope tuning
+		{
+			//mutex.lock();  //Check SlopeLow
+			retval = rig_get_level ( rRig, RIG_VFO_CURR, RIG_LEVEL_SLOPE_LOW, &slopeLowVal );
+			// Note you have to put RIG_VFO_CURR here to make this call work.  (vfo won't).
+			if ( retval != RIG_OK )
+			{
+				fprintf ( stderr, "Error getting slope tune low from radio!\n" );
+				retval--;
+			}
+			//mutex.unlock();
+			slopeLow = slopeLowVal.i;
+			if ( oldSlopeLow != slopeLow )
+			{
+				//mutex.lock();
+				emit slopeLowChangedByRig ( slopeLow );
+				//mutex.unlock();
+				oldSlopeLow = slopeLow;
+			}
+
+			//mutex.lock();  //Check SlopeHigh
+			if ( rig_get_level ( rRig, RIG_VFO_CURR, RIG_LEVEL_SLOPE_HIGH, &slopeHighVal ) != RIG_OK )
+			{
+				fprintf ( stderr, "Error getting slope tune high from radio!\n" );
+				retval--;
+			}
+			slopeHigh = slopeHighVal.i;
+			//mutex.unlock();
+			if ( oldSlopeHigh != slopeHigh )
+			{
+				//mutex.lock();
+				emit slopeHighChangedByRig ( slopeHigh );
+				//mutex.unlock();
+				oldSlopeHigh = slopeHigh;
+			}
+		}
+
+		if ( setmodes )
+		{
+			setmodes=false;
+			if ( rRig )
+			{
+				//mutex.lock();
+				rig_set_mode ( rRig, vfo, newMode, newWidth );
+				//mutex.unlock();
+			}
+		}
+	}
+}
+
+void hamlibWrapper::setPause ( bool p )
+{
+	if ( rRig->caps->rig_model==RIG_MODEL_DUMMY )
+		return;
+
+	shouldexit=p;
+        if ( !p && !isRunning() )
+		start();
+}
+
+
+
+freq_t hamlibWrapper::getHardwareFrequency()
+{
+	const char* errorstring=NULL;
+	int errorcode;
+	freq_t frequency=0;
+	//mutex.lock();
+	errorcode=rig_get_freq ( rRig, vfo, &frequency );
+	if ( errorcode!=RIG_OK )
+	{
+		fprintf ( stderr, "WARNING: Error fetching frequency from Radio! \n" );
+		errorstring=rigerror ( errorcode );
+		if ( errorstring )
+			fprintf ( stderr, "The reported error was: %s\n", errorstring );
+	}
+	//mutex.unlock();
+	return frequency;
+}
+
+void hamlibWrapper::pollSlopeTuning ( bool checktuning )
+{
+	useSlopeTuning = checktuning;
+}
+
+void hamlibWrapper::useMuteXmit ( bool muteonxmit )
+{
+	muteOnXmit = muteonxmit;
+}
--- /dev/null
+++ sdr-shell-4~svn156/lcdfreq.h
@@ -0,0 +1,27 @@
+#ifndef LCDFREQ_H
+#define LCDFREQ_H
+
+#include <QLabel>
+#include <QLCDNumber>
+#include <QMouseEvent>
+
+class LCDFreq : public QLCDNumber
+{
+	Q_OBJECT
+
+	public:
+		explicit LCDFreq(QWidget *parent = 0);
+		explicit LCDFreq(uint numDigits, QWidget *parent = 0);
+
+    protected:
+        void mouseReleaseEvent ( QMouseEvent * );
+		void wheelEvent ( QWheelEvent * );
+
+    signals:
+        void tuneStep( int );
+		void tune3 (int );
+
+	private:
+		int digit ( int );
+};
+#endif
--- /dev/null
+++ sdr-shell-4~svn156/COPYING
@@ -0,0 +1,674 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
--- sdr-shell-4~svn156.orig/varilabel.h
+++ sdr-shell-4~svn156/varilabel.h
@@ -1,15 +1,17 @@
 #ifndef VARILABEL_H
 #define VARILABEL_H
 
-#include <qlabel.h>
+#include <QLabel>
+#include <QMouseEvent>
+#include <hamlib/rig.h>
 
 class Varilabel : public QLabel
 {
     Q_OBJECT
     
     public:
-        Varilabel(QWidget *parent = 0, const char *name = 0);
-    void setLabel( int );
+    	Varilabel(QWidget *parent = 0);    
+    	void setLabel( int );
 
     private:
         int label;
@@ -22,6 +24,27 @@ class Varilabel : public QLabel
         void y( int );
         void pulse( int );
         void mouseRelease( int );
+        void mouseRelease2( int );
+        void mouseRelease3( int );
+
+};
+
+class VariModelabel : public Varilabel
+{
+	Q_OBJECT
+    
+	public:
+		VariModelabel(QWidget *parent);
+		void setLabel( rmode_t );
+		
+	private:
+		rmode_t label;
+		
+	protected:
+		void mouseReleaseEvent ( QMouseEvent *);
+		
+	signals:
+		void mouseRelease( rmode_t, bool, bool );
 
 };
 #endif
--- sdr-shell-4~svn156.orig/spectrogram.cpp
+++ sdr-shell-4~svn156/spectrogram.cpp
@@ -1,18 +1,27 @@
+#include <cstdio>
 #include "spectrogram.h"
 
-Spectrogram::Spectrogram(QWidget *parent, const char *name) : QWidget(parent, name)
+//Spectrogram::Spectrogram(QWidget *parent, const char *name) : QWidget(parent, name)
+Spectrogram::Spectrogram(QWidget *parent) : QWidget(parent)
 {
-  //setMouseTracking( true );
+    setMouseTracking( true );
 
     mouseMoving = 0;
 }
 
 void Spectrogram::mouseReleaseEvent( QMouseEvent *e )
 {
-    if ( !mouseMoving && e->state() == LeftButton )
+//printf("spectrogram mouseReleaseEvent \n");
+    if ( !mouseMoving && e->button() == Qt::LeftButton )
+    {
+//     printf("e->x() = %d\n", e->x());
+//     printf("e->gloabalX() = %d\n", e->globalX());     
+//     printf("e->y() = %d\n", e->y());
+//     printf("e->globalY() = %d\n", e->globalY());     
         emit tune1( e->x() );
+        }
 
-    if ( !mouseMoving && e->state() == RightButton )
+    if ( !mouseMoving && e->button() == Qt::RightButton )
         emit plot( e->y() );    
 
     mouseMoving = false;
@@ -20,9 +29,10 @@ void Spectrogram::mouseReleaseEvent( QMo
 
 void Spectrogram::mouseMoveEvent( QMouseEvent *e )
 {
+//printf("spectrogram mouseMoveEvent \n");
     static int x0 = 0;
     int output;
-
+	
     mouseMoving = true;
 
     if ( x0 - e->x() >= 0 )
@@ -30,14 +40,50 @@ void Spectrogram::mouseMoveEvent( QMouse
     else
         output = -1;
 
-    if ( e->state() == LeftButton ) 
+    if ( e->buttons() == Qt::LeftButton ) 
         emit tune2( output );
-    else if ( e->state() == RightButton )
+    else if ( e->buttons() == Qt::RightButton )
         emit tune2( output * 10 );
-    else if ( e->state() == MidButton )
+    else if ( e->buttons() == Qt::MidButton )
         emit tune2( output * 100 );
     else
         emit movement( e->x() );
 
+
     x0 = e->x();
 }
+
+void Spectrogram::wheelEvent(QWheelEvent *event)
+{
+    int numDegrees = event->delta() / 8;
+    int numSteps = numDegrees / 15;
+    char orientation = '?';
+    int orient = 0, shift = 0, ctl = 0, alt = 0;
+
+    if (event->orientation() == Qt::Horizontal) {
+		orientation = 'h';
+		orient = 100;
+    } else {
+		orientation = 'v';
+		orient = 1000;
+    }
+
+#if 0
+   if (event->state() & Qt::ShiftButton)
+	shift = 1;
+   if (event->state() & Qt::AltButton)
+	alt = 1;
+   if (event->state() & Qt::ControlButton)
+	ctl = 1;
+#endif
+
+    printf("wheelEvent degrees %d steps %d orientation %c %c %c %c\n",
+		numDegrees, numSteps, orientation, shift, ctl, alt);
+
+    if (event->orientation() == Qt::Horizontal) {
+    	emit tune2( orient * -numSteps +  10000 * shift + 100000 * alt);
+	} else {
+    	emit tune3( -numSteps );
+	}
+}
+
--- /dev/null
+++ sdr-shell-4~svn156/dttsp.h
@@ -0,0 +1,178 @@
+/*
+
+The code contained in this file has been excerpted from DttSP port-clients.h
+and adapted to c++ by A.Montefusco - IW0HDV
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*/
+
+#if !defined __DTTSP_H__
+#define      __DTTSP_H__
+
+#define DTTSP_PORT_CLIENT_COMMAND  19001
+#define DTTSP_PORT_CLIENT_SPECTRUM 19002
+#define DTTSP_PORT_CLIENT_METER    19003
+#define USBSOFTROCK_CLIENT_COMMAND 19004
+#define DTTSP_TX_PORT_CLIENT_COMMAND  19005
+
+#define DTTSP_PORT_CLIENT_BUFSIZE  65536
+
+
+struct sockaddr_in;
+
+class DttSP {
+    
+protected:
+    bool verbose;
+    unsigned short      port;
+    struct sockaddr_in *pSa;
+	struct addrinfo		*address;
+    int clen, flags, sock;
+
+    char  buff [DTTSP_PORT_CLIENT_BUFSIZE];
+    int   size, used;
+    double   param;
+
+    DttSP (int port, int inbound);
+    DttSP (int port, int inbound, char *host);
+    DttSP (char *host);
+    DttSP (bool verbose, int port, int inbound);
+    DttSP (bool verbose, int port, int inbound, char *host);
+    DttSP (bool verbose, char *host);
+
+    int send_command ( char *cmdstr) ;
+public:
+    virtual ~DttSP ();
+};
+
+
+
+class DttSPcmd: public DttSP {
+
+public:
+    DttSPcmd (int port ): //= DTTSP_PORT_CLIENT_COMMAND
+        DttSP (false, port, 0)
+        {}
+    DttSPcmd (int port, char *host):
+        DttSP (false, port, 0, host)
+        {}
+    DttSPcmd (bool verbose, int port ): //= DTTSP_PORT_CLIENT_COMMAND
+        DttSP (verbose, port, 0)
+        {}
+    DttSPcmd (bool verbose, int port, char *host):
+        DttSP (verbose, port, 0, host)
+        {}
+
+    ~DttSPcmd () {}
+
+    int sendCommand ( const char *format, ... );
+};
+
+
+class DttSPmeter: public DttSP {
+
+public:
+    DttSPmeter (int port)://= DTTSP_PORT_CLIENT_METER
+        DttSP (false, port, 1)
+    {}
+    DttSPmeter (int port, char *host):
+        DttSP (false, port, 1, host)
+    {}
+    DttSPmeter (bool verbose, int port)://= DTTSP_PORT_CLIENT_METER
+        DttSP (verbose, port, 1)
+    {}
+    DttSPmeter (bool verbose, int port, char *host):
+        DttSP (verbose, port, 1, host)
+    {}
+
+    ~DttSPmeter () {}
+
+    int fetch (int *label, float *data, int npts);
+};
+
+
+class DttSPspectrum: public DttSP {
+
+public:
+    DttSPspectrum (int port )://= DTTSP_PORT_CLIENT_SPECTRUM
+        DttSP (false, port, 1)
+    {}
+    DttSPspectrum (int port, char *host):
+        DttSP (false, port, 1, host)
+    {}
+    DttSPspectrum (bool verbose, int port )://= DTTSP_PORT_CLIENT_SPECTRUM
+        DttSP (verbose, port, 1)
+    {}
+    DttSPspectrum (bool verbose, int port, char *host):
+        DttSP (verbose, port, 1, host)
+    {}
+
+    ~DttSPspectrum () {}
+
+    int fetch ( int *tick, int *label, float *data, int npts) ;
+};
+
+class USBSoftrockCmd: public DttSP {
+
+	public: 
+
+    USBSoftrockCmd (int port )://= USBSOFTROCK_CLIENT_COMMAND
+            DttSP (false, port, 0)
+	    {}
+    USBSoftrockCmd (int port, char *host):
+            DttSP (false, port, 0, host)
+	    {}
+    USBSoftrockCmd (bool verbose, int port )://= USBSOFTROCK_CLIENT_COMMAND
+            DttSP (verbose, port, 0)
+            {}
+    USBSoftrockCmd (bool verbose, int port, char *host):
+            DttSP (verbose, port, 0, host)
+            {}
+
+    ~USBSoftrockCmd () {}
+
+    int sendCommand ( const char *format, ... );
+    double getParam();
+};
+
+class DttSPTXcmd: public DttSP {
+
+public:
+    DttSPTXcmd (int port ): //= DTTSP_TX_PORT_CLIENT_COMMAND
+        DttSP (false, port, 0)
+        {}
+    DttSPTXcmd (int port, char *host):
+        DttSP (false, port, 0, host)
+        {}
+    DttSPTXcmd (bool verbose, int port ): //= DTTSP_TX_PORT_CLIENT_COMMAND
+        DttSP (verbose, port, 0)
+        {}
+    DttSPTXcmd (bool verbose, int port, char *host):
+        DttSP (verbose, port, 0, host)
+        {}
+
+    ~DttSPTXcmd () {}
+
+    int sendCommand ( const char *format, ... );
+    void off();
+    void on();
+    void setPort ( const int newport );
+};
+
+
+#endif
--- sdr-shell-4~svn156.orig/switches.h
+++ sdr-shell-4~svn156/switches.h
@@ -1,6 +1,6 @@
 /* XPM */
 
-static char *nr_xpm[]={
+static const char *nr_xpm[]={
 "27 11 2 1",
 ". c None",
 "# c #ffffff",
@@ -16,7 +16,7 @@ static char *nr_xpm[]={
 "...........................",
 "..........................."};
 
-static char *anf_xpm[]={
+static const char *anf_xpm[]={
 "27 11 2 1",
 ". c None",
 "# c #ffffff",
@@ -32,7 +32,7 @@ static char *anf_xpm[]={
 "...........................",
 "..........................."};
 
-static char *nb_xpm[]={
+static const char *nb_xpm[]={
 "27 11 2 1",
 ". c None",
 "# c #ffffff",
@@ -48,7 +48,7 @@ static char *nb_xpm[]={
 "...........................",
 "..........................."};
 
-static char *bin_xpm[]={
+static const char *bin_xpm[]={
 "27 11 2 1",
 ". c None",
 "# c #ffffff",
@@ -65,7 +65,7 @@ static char *bin_xpm[]={
 "..........................."};
 
 
-static char *mute_xpm[]={
+static const char *mute_xpm[]={
 "27 11 2 1",
 ". c None",
 "# c #ffffff",
@@ -82,7 +82,7 @@ static char *mute_xpm[]={
 "..........................."};
 
 
-static char *spec_xpm[]={
+static const char *spec_xpm[]={
 "27 11 2 1",
 ". c None",
 "# c #ffffff",
@@ -98,3 +98,99 @@ static char *spec_xpm[]={
 "...........................",
 "..........................."};
 
+static const char *up_xpm[]={
+"27 11 2 1",
+". c None",
+"# c #ffffff",
+"...........................",
+"...........................",
+"........#...#.#### ........",
+"........#...#.#...#........",
+"........#...#.#...#........",
+"........#...#.####.........",
+"........#...#.#............",
+"........#...#.#............",
+".........###..#............",
+"...........................",
+"..........................."};
+
+static const char *down_xpm[]={
+"27 11 2 1",
+". c None",
+"# c #ffffff",
+"...........................",
+"...........................",
+"..####...###..#...#.#...#..",
+"..#...#.#...#.#...#.#...#..",
+"..#...#.#...#.#...#.##..#..",
+"..#...#.#...#.#.#.#.#.#.#..",
+"..#...#.#...#.#.#.#.#..##..",
+"..#...#.#...#.##.##.#...#..",
+"..####...###..#...#.#...#..",
+"...........................",
+"..........................."};
+
+static const char *rit_xpm[]={
+"27 11 2 1",
+". c None",
+"# c #ffffff",
+"...........................",
+"...........................",
+"....####....###..#####.....",
+"....#...#....#.....#.......",
+"....#...#....#.....#.......",
+"....####.....#.....#.......",
+"....#..#.....#.....#.......",
+"....#...#....#.....#.......",
+"....#...#...###....#.......",
+"...........................",
+"..........................."};
+
+static const char *split_xpm[]={
+"27 11 2 1",
+". c None",
+"# c #ffffff",
+"...........................",
+"...........................",
+"...###..####..#.....#####..",
+"..#...#.#...#.#.......#....",
+"..#.....#...#.#.......#....",
+"...###..####..#.......#....",
+"......#.#.....#.......#....",
+"..#...#.#.....#.......#....",
+"...###..#.....#####...#....",
+"...........................",
+"..........................."};
+
+static const char *zoom_in_xpm[]={
+"27 11 2 1",
+". c None",
+"# c #ffffff",
+"...........................",
+".............#.............",
+".............#.............",
+".............#.............",
+".............#.............",
+".......############........",
+".............#.............",
+".............#.............",
+".............#.............",
+".............#.............",
+"..........................."};
+
+static const char *zoom_out_xpm[]={
+"27 11 2 1",
+". c None",
+"# c #ffffff",
+"...........................",
+"...........................",
+"...........................",
+"...........................",
+"...........................",
+".......############........",
+"...........................",
+"...........................",
+"...........................",
+"...........................",
+"..........................."};
+
--- /dev/null
+++ sdr-shell-4~svn156/freqlabel.h
@@ -0,0 +1,27 @@
+#ifndef FREQLABEL_H
+#define FREQLABEL_H
+
+#include <QLabel>
+#include <QWheelEvent>
+
+class Freqlabel : public QLabel
+{
+    Q_OBJECT
+    
+    public:
+    	Freqlabel(QWidget *parent = 0);    
+        void setIncrement( int );
+
+    private:
+        int increment;
+        QPalette p, q;
+
+    protected:
+//        void wheelEvent ( QWheelEvent * );
+        bool event ( QEvent * );
+
+    signals:
+        void mouseWheel( int );
+
+};
+#endif
--- sdr-shell-4~svn156.orig/spectrum.cpp
+++ sdr-shell-4~svn156/spectrum.cpp
@@ -1,10 +1,13 @@
+#include <cstdio>
 #include "spectrum.h"
 
-Spectrum::Spectrum( QWidget *parent, const char *name, WFlags f ) 
-	: QWidget( parent, name, f )
+//Spectrum::Spectrum( QWidget *parent, const char *name, WFlags f ) 
+//	: QWidget( parent, name, f )
+Spectrum::Spectrum( QWidget *parent) 
+	: QWidget( parent)
 {
 	setMouseTracking( true );
-    mouseMoving = 0;
+        mouseMoving = 0;
 }
 
 void Spectrum::mouseReleaseEvent( QMouseEvent *e )
@@ -16,3 +19,34 @@ void Spectrum::mouseMoveEvent( QMouseEve
 {
 	emit movement( e->x() );
 }
+
+void Spectrum::wheelEvent(QWheelEvent *event)
+{
+    int numDegrees = event->delta() / 8;
+    int numSteps = numDegrees / 15;
+    char orientation = '?';
+    int orient = 0, shift = 0, ctl = 0, alt = 0;
+
+    if (event->orientation() == Qt::Horizontal) {
+	orientation = 'h';
+	orient = 100;
+    } else {
+	orientation = 'v';
+	orient = 1000;
+    }
+
+#if 0
+   if (event->state() & Qt::ShiftButton)
+	shift = 1;
+   if (event->state() & Qt::AltButton)
+	alt = 1;
+   if (event->state() & Qt::ControlButton)
+	ctl = 1;
+#endif
+
+    printf("wheelEvent degrees %d steps %d orientation %c %c %c %c\n",
+		numDegrees, numSteps, orientation, shift, ctl, alt);
+
+    emit tune2( orient * numSteps +  10000 * shift + 100000 * alt);
+}
+
--- /dev/null
+++ sdr-shell-4~svn156/dttsp.cpp
@@ -0,0 +1,377 @@
+/*
+
+The code contained in this file has been excerpted from DttSP port-clients.c
+and adapted to c++ by A.Montefusco - IW0HDV
+
+Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 by Frank Brickle, AB2KT and Bob McGwier, N4HY
+
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*/
+
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/wait.h>  
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>  
+#include <netdb.h>
+
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include <time.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <string.h>
+#include <stdarg.h>
+
+#include "dttsp.h"
+
+
+
+DttSP :: DttSP (bool verbose, int port, int inbound):
+    port(port)
+{
+    pSa = new struct sockaddr_in;
+	address = NULL;
+
+    if (pSa) {
+        // create socket 
+        if ((sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
+          perror("Couldn't create dttsp_port_client socket");
+          exit(1);
+        }
+
+        flags = 0;
+
+        // are we the listener here?
+        if (inbound) {
+          clen = sizeof(*pSa);
+          memset((char *) pSa, 0, clen);
+          pSa->sin_family = AF_INET;
+          pSa->sin_addr.s_addr = htonl(INADDR_ANY);
+          pSa->sin_port = htons((unsigned short) port);
+
+          if (bind(sock, (struct sockaddr *) pSa, clen) < 0) {
+            perror("Failed to bind socket");
+            exit(1);
+          }
+        } // else no, so sockaddr gets filled in at point of use, not bound by us
+
+        if(verbose) fprintf( stderr, "DttSP port %d\n", port);
+
+        // one size fits all
+        size = DTTSP_PORT_CLIENT_BUFSIZE;
+        memset(buff, 0, size);
+    }
+}
+
+DttSP :: DttSP (bool verbose, int port, int inbound, char *host):
+        port(port)
+{
+    struct addrinfo	hints;
+    int			rc;
+    char		porttxt[32];
+
+    if (inbound) {
+        sethostent(0);
+        memset(&hints, 0, sizeof(struct addrinfo));
+        snprintf(porttxt, 32, "%d", port);
+        hints.ai_flags = AI_PASSIVE | AI_NUMERICSERV;
+        hints.ai_family = AF_INET;
+        hints.ai_socktype = SOCK_DGRAM;
+        hints.ai_protocol = IPPROTO_UDP;	//PF_INET;
+        if ( (rc = getaddrinfo(NULL, porttxt, &hints, &address)) != 0 ) {
+            fprintf( stderr, "getaddrinfo for inbound %s %d failed %s\n", host, port, gai_strerror(rc));
+            return;
+        }
+
+        // create socket 
+        if ((sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
+            perror("Couldn't create dttsp_port_client socket");
+            exit(1);
+        }
+
+        flags = 0;
+        if (bind(sock, address->ai_addr, address->ai_addrlen) < 0) {
+            perror("Failed to bind socket");
+            exit(1);
+        }
+        if (verbose) fprintf( stderr, "DttSP inbound host %s port %d addrlen %d\n", host, port, address->ai_addrlen);
+    } else {
+        sethostent(0);
+        memset(&hints, 0, sizeof(struct addrinfo));
+        snprintf(porttxt, 32, "%d", port);
+        //hints.ai_flags = AI_PASSIVE | ;
+        hints.ai_flags = AI_NUMERICSERV;
+        hints.ai_family = AF_INET;
+        hints.ai_socktype = SOCK_DGRAM;
+        hints.ai_protocol = IPPROTO_UDP;	//PF_INET;
+        if ( (rc = getaddrinfo(host, porttxt, &hints, &address)) != 0 ) {
+            fprintf( stderr, "getaddrinfo for outbound %s %d failed %s\n", host, port, gai_strerror(rc));
+            return;
+        }
+
+        // create socket 
+        if ((sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
+            perror("Couldn't create dttsp_port_client socket");
+            exit(1);
+        }
+
+        flags = 0;
+
+        fprintf( stderr, "DttSP outbound host %s port %d\n", host, port);
+
+    }
+    // one size fits all
+    size = DTTSP_PORT_CLIENT_BUFSIZE;
+    memset(buff, 0, size);
+}
+
+DttSP :: ~DttSP ()
+{
+    close (sock);
+    if (address == NULL)
+    	delete pSa;
+    else
+        delete address;
+}
+
+
+int DttSP :: send_command ( char *cmdstr ) 
+{
+    fd_set fds;
+    struct timeval tv;
+
+    char *saveptr;
+    char *token;
+
+    // are we pointing at the moon?
+    if ((!pSa && !address) || sock == -1 || !cmdstr)
+//    if (!pSa  || sock == -1 || !cmdstr)
+        return -1;
+
+    // make local, properly terminated copy of command
+    // Needs better error checking
+    // TBD
+    strcpy (buff, cmdstr);
+    strcat (buff, "\n");
+    used = strlen (buff);
+
+    // blast it
+    if (address == NULL) {
+        clen = sizeof(*pSa);
+    	memset((char *) pSa, 0, clen);
+    	pSa->sin_family = AF_INET;
+    	pSa->sin_addr.s_addr = htonl(INADDR_ANY);
+    	pSa->sin_port = htons((unsigned short) port);
+    	if (sendto(sock, buff, used, flags, (struct sockaddr *) pSa, clen) != used) {
+            fprintf (stderr, "%s: error in sendto\n", __FUNCTION__);
+            return -3;
+        }
+    } else {
+
+    	if (sendto(sock, buff, used, flags, address->ai_addr, address->ai_addrlen) != used) {
+            fprintf (stderr, "%s: error in sendto\n", __FUNCTION__);
+            return -3;
+    	}
+    }
+
+    // wait a little for ack
+    FD_ZERO(&fds);
+    FD_SET(sock, &fds);
+    tv.tv_sec = 1;
+    tv.tv_usec = 0;
+
+    if (!select(sock + 1, &fds, 0, 0, &tv)) {
+        fprintf (stderr, "%s: error from select, disabling port\n", __FUNCTION__);
+        fprintf (stderr, "Perhaps sdr-core isn't started, or usbsoftrock isn't running (when selected in CFG).\n");
+        close (sock);
+        sock = -1;
+        delete pSa;
+        pSa = NULL;
+       	return -4;
+    }
+    if (address == NULL) {
+        if (recvfrom(sock, buff, size, flags, (struct sockaddr *) pSa, (socklen_t *)(&clen)) <= 0) {
+            fprintf (stderr, "%s: error in recvfrom\n", __FUNCTION__);
+            return -5;
+        }
+    } else {
+        if (recvfrom(sock, buff, size, flags, address->ai_addr, &address->ai_addrlen) <= 0) {
+            fprintf (stderr, "%s: error in recvfrom\n", __FUNCTION__);
+            return -5;
+        }
+    }
+
+    if (buff[0] != 'o' || buff[1] != 'k') return -6;
+
+	param = 0.0;
+        token = strtok_r(buff, " ", &saveptr);		// parse the buffer
+        if (token != NULL) {  
+          token = strtok_r(NULL, " ", &saveptr);	// parse the next
+	  if (token != NULL) param = atof(token);	// param is double number
+        }
+
+
+    return 0;
+}
+
+int DttSPcmd :: sendCommand ( const char *format, ... )
+{
+    va_list ap;
+    char    szBuf [BUFSIZ];
+    int     rc;
+
+    va_start(ap, format);
+
+    vsprintf ( szBuf, format, ap );
+    rc = send_command (szBuf);
+
+    va_end(ap);
+
+    return rc;
+
+}
+
+
+int DttSPmeter :: fetch (int *label, float *data, int npts)
+{
+  fd_set fds;
+  struct timeval tv;
+
+  // wait a bit for data to appear
+  FD_ZERO(&fds);
+  FD_SET(sock, &fds);
+  tv.tv_sec = 1;
+  tv.tv_usec = 0;
+  if (!select(sock + 1, &fds, 0, 0, &tv))
+    return -1;
+  if (recvfrom(sock, buff, size, flags,
+	       (struct sockaddr *) pSa, (socklen_t*)&clen) <= 0)
+    return -2;
+
+  // copy payload back to client space
+  memcpy((char *) label, buff,               sizeof(int)          );
+  memcpy((char *) data,  buff + sizeof(int), npts * sizeof(float) );
+  return 0;
+}
+
+int  DttSPspectrum :: fetch ( int *tick, int *label, float *data, int npts) 
+{
+  fd_set fds;
+  struct timeval tv;
+
+  // wait a bit for data to appear
+  FD_ZERO(&fds);
+  FD_SET(sock, &fds);
+  tv.tv_sec = 1;
+  tv.tv_usec = 0;
+  if (!select(sock + 1, &fds, 0, 0, &tv))
+    return -1;
+  if (recvfrom(sock, buff, size, flags,
+	       (struct sockaddr *) pSa, (socklen_t*)&clen) <= 0)
+    return -2;
+
+  // copy payload back to client space
+  memcpy((char *) tick,  buff,                   sizeof(int)          );
+  memcpy((char *) label, buff + sizeof(int),     sizeof(int)          );
+  memcpy((char *) data,  buff + 2 * sizeof(int), npts * sizeof(float) );
+  return 0;
+}
+
+double USBSoftrockCmd :: getParam()
+{
+	return param;
+}
+
+int USBSoftrockCmd :: sendCommand ( const char *format, ... )
+{
+	va_list ap;
+	char    szBuf [BUFSIZ];
+	int     rc;
+
+	va_start(ap, format);
+
+	vsprintf ( szBuf, format, ap );
+	rc = send_command (szBuf);
+
+	va_end(ap);
+
+	return rc;
+
+}
+
+int DttSPTXcmd :: sendCommand ( const char *format, ... )
+{
+    va_list ap;
+    char    szBuf [BUFSIZ];
+    int     rc;
+
+    va_start(ap, format);
+
+    vsprintf ( szBuf, format, ap );
+    rc = send_command (szBuf);
+
+    va_end(ap);
+
+    return rc;
+
+}
+
+void DttSPTXcmd :: off ( )
+{
+    printf("DttSPTXcmd = off\n");
+    close (sock);
+    sock = -1;
+    delete pSa;
+    pSa = NULL;
+}
+
+void DttSPTXcmd :: on ( )
+{
+    printf("DttSPTXcmd = on\n");
+    pSa = new struct sockaddr_in;
+
+    if (pSa) {
+        // create socket 
+        if ((sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
+		  perror("Couldn't create dttsp_port_client socket for DttSPTXcmd");
+          exit(1);
+        }
+
+        flags = 0;
+
+        if(verbose) fprintf( stderr, "DttSP port %d\n", port);
+
+        // one size fits all
+        size = DTTSP_PORT_CLIENT_BUFSIZE;
+        memset(buff, 0, size);
+    }
+}
+
+void DttSPTXcmd :: setPort ( const int newport )
+{
+    printf("DttSPTXcmd: old port %d new port %d\n", port, newport);
+    port = newport;
+}
+
--- /dev/null
+++ sdr-shell-4~svn156/hamlibwrapper.h
@@ -0,0 +1,78 @@
+/***************************************************************************
+                          hamlibwrapper.h  -  description
+                             -------------------
+    begin                : 8/12/2007
+    copyright            : (C) 2007 by Rob Frohne
+    email                : frohro@wallawalla.edu
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef HAMLIBWRAPPER_H
+#define HAMLIBWRAPPER_H
+
+#include <hamlib/rig.h>
+#include <qthread.h>
+#include <qobject.h>
+#include <qmutex.h>
+
+#define SLOPE_TUNE_MAX 20;
+#define SLOPE_TUNE_MAX_CW 20;
+
+/** This is an simple wrapper class around hamlib to control our rigs for use with IF Softrock, etc.
+
+  *@author Rob Frohne, with thanks to Luc Langehegermann for a look at his code for his ktrack hamlibwrapper.
+  */
+
+class hamlibWrapper : public QThread
+{
+        Q_OBJECT
+	public:
+                hamlibWrapper ( QObject *parent=0);
+		~hamlibWrapper();
+		int init ( rig_model_t, const char* port, int speed );
+		void run();
+		void setPause ( bool p );
+
+	public slots:
+		void setMode ( rmode_t, pbwidth_t );
+		void pollSlopeTuning ( bool );
+		void useMuteXmit ( bool );
+		
+	private:
+		RIG* rRig;
+		double freq, getfreq;
+		bool shouldexit;
+		ptt_t transmit;
+		bool setmodes;
+		QMutex mutex;
+		freq_t getHardwareFrequency();
+		rmode_t mode;
+		rmode_t newMode;
+		pbwidth_t width;
+		pbwidth_t newWidth;
+		value_t slopeLowVal;
+		int slopeLow;
+		value_t slopeHighVal;
+		int slopeHigh;
+		vfo_t vfo;
+		bool useSlopeTuning;
+		bool muteOnXmit;
+		
+	signals: // Signals
+		void newFreq ( double );
+		void nowTransmit ( int );
+		void rigChangedMode ( rmode_t, bool );
+		void slopeLowChangedByRig ( int );
+		void slopeHighChangedByRig ( int );
+		void rigPitch ( int );		
+};
+
+#endif
--- /dev/null
+++ sdr-shell-4~svn156/CHANGELOG
@@ -0,0 +1,382 @@
+
+Version 4.25
+
+1. The NR, ANF and NB values were not being read from the config file.  The
+code that reads those from the saved configuration were deleted in svn #136.
+Restored.
+
+2. To deal with the usbsoftrock offset setup, I moved some code around.  I'm
+a bit uncertain if I'm breaking something here, but it runs okay.  I moved
+the getenv of SDR_DEFRATE into the main_widget constructor, and set the
+tuneCenter there.  I would also move getting SDR_HOST there, also, but I'm
+not too certain of what I would be getting into with that.
+
+3. Moved the setting of cfgTransmit->setChecked to after where all the
+command ports will be set up.
+
+4. Fixed the hScale related compile errors.
+
+5. I fixed the spectrogram area mouse scroll wheel tuning to be consistant
+with the way tuning in the spectrum and frequency display widgets.  It was
+backwards from the way the other windows operated.  Does anyone else use mouse
+wheel tuning?  I've been thinking of gutting a mouse to make a "big knob" out
+of the mouse wheel.
+
+6. Set maximum values for the NR LeakageSpinBox and NR_GainSpinBox to values
+that will keep dttsp from going mute and not coming out of it.
+
+7. Set the value and step of the ANF_Leakage to the dttsp default, which
+requires more digits (and tweeking of the GUI widget widths).
+
+
+Version 4.24
+
+Added command line options.
+
+Version 4.23
+
+Add revised PTT polling, by Alex Lee 9V1AL.
+
+To turn this on, edit
+sdr-shell.pro and remove the # (comment) character on the line that says:
+
+	DEFINES += PTT_POLL
+
+
+   Every 100ms or so, sdr-shell will check
+   the PTT state by sending a UDP message to the usbsoftrock daemon.  The message is a 
+   "get ptt".  You will need a patched version of usbsoftrock to enable "get ptt" to work.
+
+   With PTT polling, when an external
+   program, such the keyboard keyer, iambic keyer, or fldigi. to change the PTT state to Rx
+   or Tx, and sdr-shell will change state accordingly.  The 'center' frequency for Tx and the filter
+   limits may also be changed for CW Tx and flidigi Tx to ensure that the Rx dial freq is the same
+   (or very close to) the actual Tx RF out.
+
+Add FREQ polling, by Alex Lee 9V1AL.
+
+To turn this on, edit
+sdr-shell.pro and remove the # (comment) character on the line that says:
+
+	DEFINES += FREQ_POLL
+
+
+   Every 500ms or so, sdr-shell will check
+   the current "center" frequency of the softrock Si570 (which is usually Si570 freq / 4),
+   and updates the Rx frequency (and display) of sdr-shell accordingly.  This allows external
+   changes of the frequency, eg. by a rotary encoder attached to the Softrock/Mobo, to be
+   reflected automatically in sdr-shell.  There is no need to use a patched version of usbsoftrock,
+   as the "get freq" command is already available.
+
+
+Version 4.22
+
+Break out functions for turning TX on and off from toggle_TX(). 
+
+Turn TX off at start-up.  This mutes the transmit dttsp process, which 
+otherwise sends audio to the softrock which is in turn picked up as noise
+by the receive dttsp process.
+
+Fix up arguments to some of the commands.  Several formats had two %d
+strings but only one argument.
+
+Fix setTxIQGain and setTxIQPhase.  They were setting the receive IQ values.
+
+
+Version 4.21
+
+Add PTT polling code by Alex, 9V1AL.
+
+The PTT polling keeps sdr-shell up-to-date with other program that may
+be setting PTT on the USB Synthesizer.  Sdr-shell sets state for dttsp
+when it sees the PTT line change state.
+
+Reading the PTT state is only available in usbsoftrock for the MOBO.
+If used with usbsoftrock-1.0.1 this will not work due to a bug in
+usbsoftrock.  To make this compatible with all softrock boards, the setting
+of the PTT polling timer is done inside ofan #ifdef.  To turn this on, edit
+sdr-shell.pro and remove the # (comment) character on the line that says:
+
+	DEFINES += PTT_POLL
+
+
+Version 4.20
+
+Note: this change adds files and modified sdr-shell.pro.  You must rebuild
+your makefile with 'qmake-qt4'.
+
+This adds buttons to send arbitrary commands to DttSP.  There are eight "commands"
+buttons that are new in the window-bottom control frame.  Look in the DttSP Commands
+section of the README for details.
+
+Version 4.19
+
+Note: this change adds files and modified sdr-shell.pro.  You must rebuild
+your makefile with 'qmake-qt4'.
+
+ - Change the default frequency for bands and memories to 10mhz.
+
+ - change the mouse wheel to tune by 'tuneStep', which is the tuning step
+   selected by the up/down arrow keys for the tuning granularity of the
+   left/right arrow keys.
+
+   When tuning 1khz or less, the the dttsp oscillator is tuned until it hits
+   a size of the spectrum, at which time the oscillator is set to it's default
+   and usbsoftrock is called to retune the external oscillator.
+
+ - the mouse wheel tunes in the frequency display.  Position the pointer
+   over the digit to be tuned, and scroll the mouse wheel up or down to tune
+   at that step size.
+
+ - clicking on a digit in the frequency display sets the tuneStep size.  This
+   will be used by both the mouse wheel in the spectrum/spectogram frames as
+   well as the arrow keys.
+
+ - reversed the h and l keys.  Now the tune step moves left (higher) on h and
+   right (lower) on l.  I feel that this behaves more like vi, as the motion of
+   the step goes left with h and right with l.
+
+Version 4.18
+
+Fixes from Al, nh7o:
+
+ - setFilter_l() was not multiplying by step size
+
+ - the [ and ] keys did not move the filter when on LSB/CWL because of a range
+   check.  Removed the range check.
+
+Version 4.17
+
+Version number is now a number in main_widget.h
+
+- Turn on the 'filterLine' flag to put bandpass filter lines in the spectrogram
+  display.  This should be a config option.
+
+A Spectrum Display box on the Spectrum configuration tab that includes:
+-  Fill spectrum line.
+-  Spectrum Averaging
+  The spectrum display gets averaged of the past (n) values.  This makes it
+  smoother, possibly at the cost of lost detail.  Try 
+- Spectrum Scale
+  This is a start at being able to set the db scale of the spectrum display.
+  Right now the values are used only for setting a scale value against which to
+  plot the spectrum line.  I don't know how to calibrate the spectrum data from
+  dttsp to a dB scale.  When the scale is not 1.0, the db values and
+  spectrogram window are wrong.
+
+Version 4.16
+
+- Separate HELP window from Configuration (the config window still has help in it)
+
+- Incorporate user settable NR values for dttsp by Glenn VE9GJ
+
+- Make a separate configuration window for setting NR, NB and ANF values.  Bring it up by clicking the
+left mouse button (for right handed mice) on one of the NR NB or ANF widgets.
+
+- Make a widget for setting the zoom level, along the bottom of the window.
+
+- Change some menu bar colors around so it looks better.
+
+
+Version rxrx-14
+
+- Remove the fixed -sample-rate/4 tuning offset used when tuning with usbsoftrock.
+  The offset is now configurable (but not persistant across restart)
+
+- UDP command connections (for sdr-shell and usbsoftrock) can now go
+  to another computer, or from a virtual machine to the host.  Spectrum and
+  meter data must be sent back to the local host by some other means.
+  I attempted to do this with netcat, but was unsuccessful.  I ended up
+  writing a simple tunnel of my own (it's in the tools directory)
+
+To use:
+
+host:
+./tunnel1 19003 17003
+./tunnel1 19002 17002 
+ 
+remote:
+./tunnel2 otherside 17002 19002
+./tunnel2 otherside 17003 19003
+
+I put the name otherside in /etc/hosts.  This is the host side of the virtualbox
+
+- kubuntu spectrogram drawing.  I don't know why this was different on kubuntu,
+  but I changed the main widget's attributes from:
+
+    setAttribute( Qt::WA_OpaquePaintEvent, true);
+
+  to	
+
+    setAttribute( Qt::WA_NoSystemBackground, true);
+
+and it updates correctly.  It also updates correctly on Fedora9 and Ubuntu 10,
+but not on OSX with qt4-mac.  I could argue that the WA_OpaquePaintEvent
+attribute was wrong, since sdr-shell does NOT redraw the entire spectrogram
+on every update.
+
+				QT Version
+Kubuntu:			4:4.6.2-0ubuntu5
+Ubuntu 10.04.1 LTS:		4:4.6.2-0ubuntu5.1
+Fedora 9:			4.5.2
+OSX:				4.5.2-2 (qt4-mac)
+Fedora 13:			qt-x11-4.6.3-8.fc13.i686 
+
+
+Version rxtx-13
+
+The goal for this version is to restore the sdr-for-if v2d behavior.
+v2d has no ability to to tune the usbsoftrock (that feature was in v2e)
+so the arrow keys, mouse dragging in the spectrogram and clicking in
+the spectrum window all tune within the bandwidth of the sound card.
+
+This functionality is configured by turning off the "USBSoftrock"
+configuration setting (CFG -> General).
+
+Testing
+
+Set the SoftRock to a frequeny, then tune.
+
+Frequencies:
+	./usbsoftrock -vvv -a set freq 3.5815
+	(W1AW CW bulletins and morse code practice)
+
+	Open CFG window
+		Click off Use usbsoftrock via UDP
+		set LO Frequency to 3581500 (click Update)
+
+Tuning Operations
+	1. arrow keys (left, right).
+	   tune from one end of the sound card spectrom to the other
+	2. change the arrow key steps (up & down arrows), 
+	   use the left & right arrow keys to tune
+	3. click-and-drag in the spectrogram (buttons 1, 2, 3)
+	4. click in the spectrum.
+	   Click from one end to the other.
+	   Click on a signal to tune to it.
+
+With usbsoftrock -vvv set, make sure it does not get changed.
+Use usbsoftrock getfreq at the end to make sure it has not been changed.
+
+Version rxtx-12
+
+Revert all the changes to setRxFrequency made in rxtx-11.  This almost certainly
+breaks tuning when not using IF mode and not using USBSoftrock.
+
+Filter stuff:
+echo 'getSpectrumInfo' | nc -v -u localhost 19001
+
+CFG/General/Calibration:
+	Spectrum: 70  S-Meter: 40
+
+
+Version rxtx-11
+
+- fixed the IF mode that won't turn off.  This looks like some QT4 interactions
+that I don't understand.  I put the IF on/off button inside of a box inside the
+frame and now it works.
+
+- initialize cfg menus to saved values.  This affected the Spectrum type
+
+- fixed a bunch of spectrum type settings bugs.  FWIW there are other spectrum
+types that are not supported.
+
+- fixed the General / USBSoftrock Control settings so they are independent
+
+- save the 5/4 tuning (for 6m/2m converter) setting
+
+- vfo display no longer goes black when window loses focus
+
+- there is still a bug in the IF code where the frequency gets really messed up
+on startup.
+
+- I removed the RX and TX phase calibration.  I've seen many comments on this
+list saying that it doesn't really work anymore since that is automatic.
+
+- there was something buggy in the RX/TX and TX/RX switching.  I'm not sure of
+the details but the click button (click on RX widget) and T key now call the
+same function.  So, if they're broken they're at least broken in the same way.
+
+- there have been some improvements on tuning with the arrow keys when not using
+usbsoftrock for tuning ("rock bound" - the old crystal softrocks).  I'm sure that
+there are some bugs in this area.
+
+Version rxtx-5
+
+ - Several fixes to the "zoom out" display, and I now believe it is working
+   correctly.
+
+   One thing that can cause the spectrum and spectogram displays to look
+   odd is an artifact of how sdr-shell puts together the spectrum buffer.
+   The spectrum is centered on the oscillator frequency, which makes
+   displaying it simple.  However, if the Osc is set to 12000 hz above
+   zero (where tuning using an Si580 with a 48khz sound card) there is
+   only 1200hz of valid data above the center frequency.  Above that,
+   dttsp repeats the data, backwards.  The result is a display where
+   there appears to be a "mirror" on the right side of the window.
+
+   In this version, I draw a green line at where the data ends.
+
+ - Tuning changes.  Scroll wheel tuning now works in the spectrum portion
+   of the window, as well as in the spectrogram portion.  Clicking to
+   tune in the spectrogram display still does not work well, because
+   the two clicks have to be in almost exactly the same spot.  This is
+   because of the click-and-drag tuning feature.
+
+ - For packaging, I created an INSTALL and CHANGELOG.  Build instructions have
+   moved from README to INSTALL.
+
+Version rxtx-4
+Bug Fixes:
+ - Change version string to "rxtx.#", where I intend to bump the # on checkins
+ - make band switching remember the whole frequeny, not just the rx_delta_f
+
+Organization:
+ - moved all the frequency setting code to setRxFrequeny, which now takes an
+   argument of whether or not it should set a USBSoftrock
+ - remove various bits of dead code
+
+New Features:
+ - mouse scroll wheel tunes (shift, ctl and alt increase the tuning steps)
+   - includes logitech mice with "3d" scrolling (wheel tilts left/right)
+
+ - hooks for external programs: band switch, mode switch
+   Set the environment variables SDR_MODE and SDR_BAND to a program that
+   will be run when the mode is changed, either manually or as part of
+   recalling a memory.
+
+   I use the mode switch hook to connect a keyer to the TX-dttsp input.
+   As an optimization, if the mode does not change, the program is not
+   called, nor is a mode change sent to dttsp.  To force a change, use
+   shift-click on any of the mode buttons.
+   This required adding an argument to the VariModelabel mouseRelease() call.
+
+ - arrow keys can tune 10mhz & 100mhz
+
+ - set the TX dttsp to MUTE on receive.  This reduced the receive noise I was
+   getting dramaticly; however, when I hooked up a speaker to the TX Output
+   port on my sound card, I found that the microphone input was being passed
+   through so it's not really quiet.
+
+ - RIT and SPLIT tuning.  Neither are persistant across band switches or
+   program restart.  RIT is reset when tuning with the arrow keys is done
+   (tune only by dragging the mouse in the spectrogram display)
+
+   SPLIT is not saved when the program exits (yet).
+
+ - Config menu IQ: for the TX dttsp, added a gain setting for mic input.
+
+ - 5/4 tuning (setting is not persistant across program exits), useful for
+   tuning of dual-conversion softrocks, e.g. 144mhz to 28mhz
+
+New Features that Don't Entirely Work:
+ - scaling of the display: zoom out 1x, 2x or 4x
+   The goal was to permits seeing more or all of the spectrum on the screen
+   at once.  I did this by reducing the size of the spectrum buffer from 4096
+   to 2048 or 1024 (1/2 and 1/4) and making adjustments in the display code.
+
+   It only partly works.  I think the spectrogram display is wrong (it wraps)
+   and it's clear the spectrum display is wrong.
+
+   Use 1, 2, and 4 keys to set zoom (1x, 1/2x, 1/4x).
+
--- sdr-shell-4~svn156.orig/agc.h
+++ sdr-shell-4~svn156/agc.h
@@ -1,6 +1,6 @@
 /* XPM */
 /*
-static char *agc_o_xpm[]={
+static const char *agc_o_xpm[]={
 	"9 11 2 1",
 	". c None",
 	"# c #ffffff",
@@ -16,7 +16,7 @@ static char *agc_o_xpm[]={
 	".........",
 	"........."};
 */
-static char *agc_l_xpm[]={
+static const char *agc_l_xpm[]={
 	"9 11 2 1",
 	". c None",
 	"# c #ffffff",
@@ -32,7 +32,7 @@ static char *agc_l_xpm[]={
 	".........",
 	"........."};
 
-static char *agc_s_xpm[]={
+static const char *agc_s_xpm[]={
 	"9 11 2 1",
 	". c None",
 	"# c #ffffff",
@@ -48,7 +48,7 @@ static char *agc_s_xpm[]={
 	".........",
 	"........."};
 
-static char *agc_m_xpm[]={
+static const char *agc_m_xpm[]={
 	"9 11 2 1",
 	". c None",
 	"# c #ffffff",
@@ -64,7 +64,7 @@ static char *agc_m_xpm[]={
 	".........",
 	"........."};
 
-static char *agc_f_xpm[]={
+static const char *agc_f_xpm[]={
 	"9 11 2 1",
 	". c None",
 	"# c #ffffff",
--- /dev/null
+++ sdr-shell-4~svn156/trxwidget.cpp
@@ -0,0 +1,180 @@
+/***************************************************************************
+                          trxwidget.cpp  -  description
+                             -------------------
+    begin                : Sat May 18 2002
+    copyright            : (C) 2002 by Luc Langehegermann
+    email                : lx2gt@qmx.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <errno.h>
+
+#include <qlcdnumber.h>
+#include <qspinbox.h>
+#include <qcombobox.h>
+#include <qtimer.h>
+#include <qlabel.h>
+#include <kapplication.h>
+#include <stdio.h>
+
+
+#include "globals.h"
+#include "trxwidget.h"
+
+trxWidget::trxWidget(QWidget *parent, const char *name ) : trxWidgetBase(parent,name), DCOPObject("DCOPInterface") {
+  uplinkLCD->setSmallDecimalPoint(true);
+  downlinkLCD->setSmallDecimalPoint(true);
+  QObject::connect(correctionSpinBox, SIGNAL(valueChanged(int)), this, SLOT(newCorrection(int)));
+  sat=NULL;
+  currenttransponder=NULL;
+  // init the message queue to xlog
+
+  /* create the message queue, you need to use 1238 for the key to talk to xlog */
+  msgid = msgget ((key_t) 1238, 0666 | IPC_CREAT);
+  if (msgid == -1)
+    {
+      fprintf (stderr, "msgget failed: %s\n", strerror (errno));
+    }
+  /* you need to set mtype to 88 */
+  msgbuf.mtype = 88;
+
+  mode="";
+  downlinkfrequency=0;
+  uplinkfrequency=0;
+
+  QTimer* timer = new QTimer (this);
+  QObject::connect(timer, SIGNAL(timeout()), this, SLOT(sendToXlog()));
+  timer->start(1000);
+}
+trxWidget::~trxWidget(){
+}
+/** sets the radio control device we should use */
+void trxWidget::setDevice(rigctrl* dev){
+  trxctrl=dev;
+  if (trxctrl) {
+    QObject::connect(trxctrl, SIGNAL(newDownlinkFreq(double)), this,
+      SLOT(slotNewDownlinkFrequency(double)));
+    QObject::connect(trxctrl, SIGNAL(newUplinkFreq(double)), this,
+      SLOT(slotNewUplinkFrequency(double)));
+    QObject::connect(trxctrl->Wrapper(), SIGNAL(newHardwareDownlinkFreq(double)), this,
+      SLOT(slotNewHardwareDownlinkFrequency(double)));
+    QObject::connect(trxctrl->Wrapper(), SIGNAL(newHardwareUplinkFreq(double)), this,
+      SLOT(slotNewHardwareUplinkFrequency(double)));
+  }
+}
+/** No descriptions */
+void trxWidget::slotNewDownlinkFrequency(double freq){
+  downlinkLCD->display(dottedFrequency(freq));
+  downlinkfrequency=freq/1000.0;
+}
+/** No descriptions */
+void trxWidget::slotNewUplinkFrequency(double freq){
+  uplinkLCD->display(dottedFrequency(freq));
+  uplinkfrequency=freq/1000.0;
+}
+
+void trxWidget::slotNewHardwareDownlinkFrequency(double freq) {
+  downlinkHardwareFrequencyLabel->setText(dottedFrequency(freq));
+}
+  
+void trxWidget::slotNewHardwareUplinkFrequency(double freq) {
+  uplinkHardwareFrequencyLabel->setText(dottedFrequency(freq));
+}
+
+
+void trxWidget::setSatellite(satellite* s) {
+  sat=s;
+  // fill in the combo
+  QString str;
+  transponder* t;
+  QList<transponder> list=*sat->translist();
+  transponderCombo->clear();
+  for (t=list.first(); t!=0; t=list.next()) {
+    str = QString::number(t->uplink()/1000.0,'f',0) + "/" + QString::number(t->downlink()/1000.0,'f',0);
+    transponderCombo->insertItem(str);
+  }
+  QObject::connect(transponderCombo, SIGNAL(activated(int)), this, SLOT(newTransponder(int)));
+  newTransponder(0);
+}
+
+void trxWidget::updateTransponderList() {
+  // for now: do as if we had a new satellite - but with the old one
+  if (sat)
+    setSatellite(sat);
+}
+
+/** No descriptions */
+void trxWidget::newTransponder(int id){
+  QList<transponder> list = *sat->translist();
+  currenttransponder=list.at(id);
+  if (!currenttransponder) return;
+  if(trxctrl) {
+    trxctrl->setTransponder(currenttransponder);
+    trxctrl->setCorrection(currenttransponder->getLastOffset());
+  }
+  if (currenttransponder->mode() == MODE_SSB)
+    mode="SSB";
+  if (currenttransponder->mode() == MODE_FM)
+    mode="FM";
+  if (currenttransponder->mode() == MODE_CW)
+    mode="CW";
+//  currenttransponder->setLastOffset(correctionSpinBox->value());
+  correctionSpinBox->setValue(currenttransponder->getLastOffset());
+  satname=sat->name();
+}
+/** No descriptions */
+void trxWidget::newCorrection(int c){
+  if(trxctrl)
+    trxctrl->setCorrection(c);
+  if (currenttransponder)
+    currenttransponder->setLastOffset(c);
+}
+
+double trxWidget::getUplinkFrequency() {
+  return uplinkfrequency;
+}
+
+double trxWidget::getDownlinkFrequency() {
+  return downlinkfrequency;
+}
+
+QString trxWidget::getMode() {
+  return mode;
+}
+
+QString trxWidget::getSatellite() {
+  if (sat)
+    return sat->name();
+  else
+    return "";
+}
+
+/** No descriptions */
+void trxWidget::sendToXlog(){
+  QString xlogstr;
+  xlogstr="program:ktrack\1version:1\1mhz:";
+  xlogstr+=QString::number(downlinkfrequency/1000.0, 'f', 3);
+  xlogstr+="\1free1:" + satname; 
+  xlogstr+="\1free2:" + QString::number(uplinkfrequency/1000.0, 'f', 3);
+  xlogstr+="\1mode:" + mode + "\1";
+  strcpy (msgbuf.mtext, xlogstr.latin1());
+  msgsnd (msgid, (void *) &msgbuf, 1024, IPC_NOWAIT);
+  lastmsg = xlogstr;
+}
+/** No descriptions */
+QString trxWidget::dottedFrequency(double freq){
+  QString str=QString::number(freq,'f',0);
+  str.insert(str.length()-3, '.');
+  str.insert(str.length()-7, '.');
+  if(freq>999999999.0)
+    str.insert(str.length()-11, '.');
+  return str;
+}
--- /dev/null
+++ sdr-shell-4~svn156/idbutton.cpp
@@ -0,0 +1,24 @@
+
+#include <cstdio>
+#include "idbutton.h"
+
+//IdPushButton::IdPushButton(QPushButton *parent)
+IdPushButton::IdPushButton(QWidget *parent) : QPushButton (parent)
+{
+	id = -1;
+	connect ( this, SIGNAL ( clicked() ), this, SLOT ( nclick() ) );
+}
+
+void IdPushButton::setID( int v )
+{
+	id = v;
+}
+
+int IdPushButton::getID( )
+{
+	return id;
+}
+void IdPushButton::nclick ( )
+{
+	emit selected ( id );
+}
--- /dev/null
+++ sdr-shell-4~svn156/rigctl.h
@@ -0,0 +1,58 @@
+/*
+ * Server for hamlib's TCP rigctl protocol.
+ * Copyright (C) 2010 Adam Sampson <ats@offog.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef RIGCTL_H
+#define RIGCTL_H
+
+#include <QtCore/QObject>
+#include <QtNetwork/QTcpServer>
+#include <QtNetwork/QTcpSocket>
+
+class Main_Widget;
+
+class RigCtlSocket : public QObject {
+	Q_OBJECT
+
+	public:
+		RigCtlSocket(QObject *parent = 0, Main_Widget *main = 0,
+		             QTcpSocket *conn = 0);
+
+	public slots:
+		void disconnected(void);
+		void readyRead(void);
+
+	private:
+		Main_Widget *main;
+		QTcpSocket *conn;
+};
+
+class RigCtlServer : public QObject {
+	Q_OBJECT
+
+	public:
+		RigCtlServer(QObject *parent = 0, Main_Widget *main = 0);
+
+	public slots:
+		void newConnection(void);
+
+	private:
+		Main_Widget *main;
+		QTcpServer *server;
+};
+
+#endif
--- /dev/null
+++ sdr-shell-4~svn156/lcdfreq.cpp
@@ -0,0 +1,76 @@
+
+#include <cstdio>
+#include "lcdfreq.h"
+#include "cmath"
+
+LCDFreq::LCDFreq (QWidget *parent) : QLCDNumber (parent)
+{
+}
+
+LCDFreq::LCDFreq (uint numDigits, QWidget *parent) : QLCDNumber (numDigits, parent)
+{
+}
+
+int LCDFreq::digit(int x)
+{
+	int index[] = { 34, 47, 60, 86, 99, 112, 125, 138, 151, 0 };
+	int digit;
+	// map the x offset to a digit on the LCD type display.  The LCD is fixed with, making this
+	// easy.  The index[] array, above, is the left edge of the digit.
+	for (digit=0; index[digit] != 0; digit++) {
+		if (x >= index[digit] && x < index[digit]+13) {
+			break;
+		}
+	}
+	if (index[digit] == 0)
+		digit = -1;
+	digit = 8 - digit;
+	return digit;
+}
+
+void LCDFreq::mouseReleaseEvent( QMouseEvent *e )
+{
+	int d;
+#if 0
+	int index[] = { 34, 47, 60, 86, 99, 112, 125, 138, 151, 0 };
+	int x;
+	int digit;
+	// map the x offset to a digit on the LCD type display.  The LCD is fixed with, making this
+	// easy.  The index[] array, above, is the left edge of the digit.
+	x = e->x();
+	for (digit=0; index[digit] != 0; digit++) {
+		if (x >= index[digit] && x < index[digit]+13) {
+			break;
+		}
+	}
+	if (index[digit] == 0)
+		digit = -1;
+	digit = 8 - digit;
+#endif
+
+	d = digit(e->x());
+	if (d != -1) {
+		if (e->button() & Qt::LeftButton) {
+			printf("left button x %d y %d digit %d\n", e->x(), e->y(), d);
+			emit tuneStep( d );
+		}
+	}
+}
+
+void LCDFreq::wheelEvent(QWheelEvent *event)
+{
+    int numDegrees = event->delta() / 8;
+    int numSteps = numDegrees / 15;
+    int orient = 0;
+	int d;
+
+    if (event->orientation() == Qt::Horizontal) {
+		orient = 0;
+    } else {
+		orient = 1;
+    }
+	d = digit((int)event->x());
+	printf("wheel turn steps %d orientation %d digit %d %f\n", numSteps, orient, d, pow(10, d));
+	emit tune3 ( numSteps * (int)pow(10, d));
+}
+
--- /dev/null
+++ sdr-shell-4~svn156/command.h
@@ -0,0 +1,52 @@
+#ifndef COMMAND_H
+#define COMMAND_H
+
+#include <qlabel.h>
+#include <qstring.h>
+#include <QMouseEvent>
+#include <dttsp.h>
+
+class Command : public QLabel
+{
+    Q_OBJECT
+    
+    public:
+        Command(QWidget *parent = 0 );
+
+		void setCmd (DttSPcmd *, DttSPcmd *);
+        void setID( int );
+        void setName( QString );
+        void setCommand( QString, QString );
+        void setOnCommand( QString );
+        void setOffCommand( QString );
+        void setTargets( bool, bool );
+        void setTargets( QString );
+ 
+        int getID();
+        QString getName();
+		QString getOnCommand();
+		QString getOffCommand();
+		int getTargets();
+		QString getTo();
+		bool getToRX();
+		bool getToTX();
+		bool toggle();
+		bool sendCmd(DttSPcmd *, QString *);
+
+    private:
+		DttSPcmd *rxCmd, *txCmd;
+                bool state;
+        int id;
+        QString name;
+		QString OnCommand;
+		QString OffCommand;
+        bool sendRx, sendTx;
+
+    protected:
+        void mouseReleaseEvent ( QMouseEvent * );
+
+    signals:
+        void mouseReleaseL ( Command * );
+        void mouseReleaseR ( Command * );
+};
+#endif
--- /dev/null
+++ sdr-shell-4~svn156/AUTHORS
@@ -0,0 +1,3 @@
+SDR-Shell
+
+* Edson Pereira (pu1jte, n1vtn, jf1afn)
--- /dev/null
+++ sdr-shell-4~svn156/idbutton.h
@@ -0,0 +1,27 @@
+#ifndef IDBUTTON_H
+#define IDBUTTON_H
+
+#include <QLabel>
+#include <QPushButton>
+
+class IdPushButton : public QPushButton
+{
+    Q_OBJECT
+    
+    public:
+		IdPushButton(QWidget *parent = 0);
+		//IdPushButton(QPushButton *parent = 0);
+        void setID( int );
+        int getID();
+
+    private:
+        int id;
+
+	public slots:
+		void nclick ();
+
+    signals:
+		void selected ( int );
+
+};
+#endif
--- sdr-shell-4~svn156.orig/modes.h
+++ sdr-shell-4~svn156/modes.h
@@ -1,5 +1,5 @@
 /* XPM */
-static char *lsb_xpm[]={
+static const char *lsb_xpm[]={
 "21 11 2 1",
 ". c None",
 "# c #ffffff",
@@ -16,7 +16,7 @@ static char *lsb_xpm[]={
 "....................."};
 
 
-static char *usb_xpm[]={
+static const char *usb_xpm[]={
 "21 11 2 1",
 ". c None",
 "# c #ffffff",
@@ -32,7 +32,7 @@ static char *usb_xpm[]={
 "......................",
 "....................."};
 
-static char *dsb_xpm[]={
+static const char *dsb_xpm[]={
 "21 11 2 1",
 ". c None",
 "# c #ffffff",
@@ -48,7 +48,7 @@ static char *dsb_xpm[]={
 ".....................",
 "....................."};
 
-static char *am_xpm[]={
+static const char *am_xpm[]={
 "21 11 2 1",
 ". c None",
 "# c #ffffff",
@@ -64,7 +64,7 @@ static char *am_xpm[]={
 ".....................",
 "....................."};
 
-static char *cwl_xpm[]={
+static const char *cwl_xpm[]={
 "21 11 2 1",
 ". c None",
 "# c #ffffff",
@@ -80,7 +80,7 @@ static char *cwl_xpm[]={
 ".....................",
 "....................."};
 
-static char *cwu_xpm[]={
+static const char *cwu_xpm[]={
 "21 11 2 1",
 ". c None",
 "# c #ffffff",
@@ -96,7 +96,7 @@ static char *cwu_xpm[]={
 ".....................",
 "....................."};
 
-static char *sam_xpm[]={
+static const char *sam_xpm[]={
 "21 11 2 1",
 ". c None",
 "# c #ffffff",
@@ -112,7 +112,7 @@ static char *sam_xpm[]={
 ".....................",
 "....................."};
 
-static char *fmn_xpm[]={
+static const char *fmn_xpm[]={
 "21 11 2 1",
 ". c None",
 "# c #ffffff",
--- /dev/null
+++ sdr-shell-4~svn156/IDEAS
@@ -0,0 +1,91 @@
+Ideas for enhancements to sdr-shell
+
+- use a selection widget to select band by name
+
+- filter settings: error checking interferes with LSB filters
+
+apparently the setting of the filter using the keyboard when in LSB mode 
+has some error checking that makes it not work
+
+- click mouse button 3 on LCD to zero lower numbers.
+e.g. click on the 1xxxkhz value, and it goes to 1.000 khz.
+
+- use usbsoftrock via hamlib instead of a direct socket
+
+- reading of spectrogram color tables from a file.
+  nh7o has a lot of color tables.
+
+- band setting for "not a band" or something like that.
+Start-up frequency squashes band 1.
+  - alternatively, save the frequency in the band memory and save what band
+    was active on exit.
+
+- set output gain on RX dttsp to as low as possible, instead of muting.
+
+- nh7o
+
+*The waterfall type spectrogram used by most dsp programs at the moment is I
+think preferable. So is a colorized display, as it shows fading and signal
+strength with more visual immediacy.
+
+*The baseband spectrum would benefit from averaging. At the moment it is too
+jittery to show weak signals. It would also help to have the upper and lower
+dB points on the scale be user definable, and have the vertical area be a bit
+taller (or even adjustable). A smoother display would be easier on the eyes
+as well.
+
+- ab2kt
+(1) For spectrum colormap and other issues, have a look at snd:
+<https://ccrma.stanford.edu/software/snd/>
+
+(2) For visual identification of weak signals, think about adaptive
+histogram equalization on the sonogram itself:
+<http://en.wikipedia.org/wiki/Histogram_equalization>
+This stuff really works :-) and the running-update version of the
+algorithm is really cute, adding virtually nothing to the
+computational overhead.
+
+- ab2kt
+You know how most digimode programs have programmable buttons for text
+to transmit? I wonder whether having a bank of programmable buttons
+for controlling sdr-core might not be a good idea. Each button would
+have some associated editable text that would be sent verbatim as an
+update string to sdr-core. That way, not every controllable feature of
+sdr-core would need to be brought out to the front panel, but
+individual users could have their favorites available as button
+pushes.
+
+- kc0iyt
+
+Expanding on the above suggestion, it would be nice to make all of the
+hard-coded dttsp commands editable.  Additional commands would be useful for:
+
+ - rx-on, rx-off
+ - tx-on, tx-off
+ - program start-up, shut-down
+
+- w3sz
+So I would suggest that you also make FFT size selectable.  I settled on 
+262144 for the bin size I use for my really-weak-signal work with 192kHz 
+sampling rate, but I also included each power of 2 from 4096 up to that 
+value.  I would suggest that you do the same, if you haven't done so 
+already.  I selected 262144 as the size I use on the basis of much 
+testing and comparison of actual over-the-air and digitally saved very 
+weak EME and microwave signals.  Except for 160 Meter CW dx, you really 
+don't see similarly weak, challenging signals elsewhere.  I did NOT find 
+this large FFT size [262144] to be ANY problem in terms of CPU 
+utilization, etc.  I did not try values higher than 262144 because I 
+found that when using it combined with the Linrad palette I could 
+without fail always see on the waterfall CW signals very much below the 
+level at which they could be 'copied'.  Of course, if you are sampling 
+at a much lower rate [and thus limiting your waterfall bandwidth], you 
+don't need these larger FFT sizes.  But at microwave frequencies you 
+need both the bandwidth AND the weak signal detection abilities to make 
+contacts with stations who often have little idea of their actual 
+frequency and who are running only milliwatts of power under conditions 
+where the path losses are extreme, even if you yourself are GPS-locked 
+and have high-gain antennas and high gain/low noise receive preamps and 
+front ends.
+
+ -- The FFT is in dttsp.  I don't know where to set that.
+
--- /dev/null
+++ sdr-shell-4~svn156/rigctl.cpp
@@ -0,0 +1,168 @@
+/*
+ * Server for hamlib's TCP rigctl protocol.
+ * Copyright (C) 2010 Adam Sampson <ats@offog.org>
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+// Modified for setFreq and SetMode by Glenn VE9GJ Jan 22 2010
+
+#include <cstdio>
+#include <hamlib/rig.h>
+
+#include "main_widget.h"
+#include "rigctl.h"
+#include <string>
+#include <vector>
+
+
+RigCtlSocket::RigCtlSocket(QObject *parent, Main_Widget *main, QTcpSocket *conn)
+	: QObject(parent),
+	  main(main) {
+	this->conn = conn;
+}
+
+void RigCtlSocket::disconnected() {
+	deleteLater();
+}
+
+
+void RigCtlSocket::readyRead() {
+	if (!conn->canReadLine()) {
+		return;
+	}
+
+	QByteArray command(conn->readLine());
+	command.chop(1);
+	if (command.size() == 0) {
+		command.append("?");
+	}
+
+        QString cmdstr = command.constData();
+        QStringList cmdlist = cmdstr.split(QRegExp("\\s+"));
+        int cmdlistcnt = cmdlist.count();
+        bool output = false;
+	int retcode = RIG_OK;
+	QTextStream out(conn);
+
+	/* This isn't a full implementation of the rigctl protocol; it's
+	   essentially just enough to keep fldigi happy.  (And not very happy
+	   at that; you will need to up the delays to stop it sending a
+	   command, ignoring the reply owing to a timeout, then getting
+	   confused the next time it sends a command because the old reply is
+	   already in the buffer.)
+
+	   Not implemented but used by fldigi:
+             v           get_vfo  -fixed
+             F 1.234     set_freq -fixed
+	 */
+
+	int space = command.indexOf(' ');
+	if (command[0] == 'f') { // get_freq
+		out << main->rigGetFrequency() << "\n";
+		output = true;
+        }else if(cmdlist[0].compare("F") == 0 && cmdlistcnt == 2) { // set_freq
+                main->rigSetFrequency(atol(cmdlist[1].toAscii().data()));
+	} else if (command[0] == 'm') { // get_mode
+		out << rig_strrmode(main->rigGetMode()) << "\n";
+		out << main->rigGetFilterWidth() << "\n";
+		output = true;
+	} else if (command[0] == 'v') { // get_vfo
+		out << rig_strvfo(RIG_VFO_A) << "\n";
+		output = true;
+        } else if (command[0] == 'j') { // get_rit
+                    out << "0" << "\n";
+                    output = true;
+        } else if (command[0] == 's') { // get_split_vfo
+                            out << "0" << "\n";
+                            out << "VFOA" << "\n";
+                            output = true;
+	} else if (command[0] == 'T') { // set_ptt
+		int enabled = command.mid(space + 1).toInt();
+		main->rigSetPTT(enabled);
+	} else if (command[0] == 'q') { // quit
+		conn->close();
+		return;
+        } else if (cmdlist[0].compare("M") == 0 && cmdlistcnt == 3) { // set_mode
+                if (cmdlist[1].compare("USB") == 0 ) {
+                   main->setMode (  RIG_MODE_USB, FALSE, FALSE );
+                } else if (cmdlist[1].compare("LSB") == 0) {
+                   main->setMode (  RIG_MODE_LSB, FALSE, FALSE );
+                } else if (cmdlist[1].compare("AM") == 0) {
+                  main->setMode (  RIG_MODE_AM, FALSE, FALSE );
+                } else if (cmdlist[1].compare("FM") == 0) {
+                  main->setMode (  RIG_MODE_FM, FALSE, FALSE );
+                } else if (cmdlist[1].compare("SAM") == 0) {
+                  main->setMode (  RIG_MODE_SAM, FALSE, FALSE );
+                } else if (cmdlist[1].compare("CW") == 0) {
+                  main->setMode (  RIG_MODE_CW, FALSE, FALSE );
+                } else if (cmdlist[1].compare("CWR") == 0) {
+                  main->setMode (  RIG_MODE_CWR, FALSE, FALSE );
+                }
+                retcode =  RIG_OK;
+
+        } else if (command == "\\dump_state" || command[0] == '1') {
+		// See dump_state in rigctl_parse.c for what this means.
+		out << "0\n"; // protocol version
+		out << RIG_MODEL_NETRIGCTL << "\n";
+		out << RIG_ITU_REGION2 << "\n";
+                // Not sure exactly what to send here but this seems to work
+                out << "150000.000000 30000000.000000  0x900af -1 -1 0x10 000003 0x3\n"; //("%"FREQFMT" %"FREQFMT" 0x%x %d %d 0x%x 0x%x\n",start,end,modes,low_power,high_power,vfo,ant)
+                out << "0 0 0 0 0 0 0\n";
+                out << "150000.000000 30000000.000000  0x900af -1 -1 0x10 000003 0x3\n";
+		out << "0 0 0 0 0 0 0\n";
+		out << "0 0\n";
+		out << "0 0\n";
+		out << "0\n";
+		out << "0\n";
+		out << "0\n";
+		out << "0\n";
+		out << "\n";
+		out << "\n";
+		out << "0x0\n";
+		out << "0x0\n";
+		out << "0x0\n";
+		out << "0x0\n";
+		out << "0x0\n";
+		out << "0\n";
+		output = true;
+	} else {
+		fprintf(stderr, "rigctl: unknown command \"%s\"\n",
+		        command.constData());
+		retcode = -RIG_ENAVAIL;
+	}
+        //fprintf(stderr, "rigctl:  command \"%s\"\n", command.constData());
+	if (!output) {
+		out << "RPRT " << retcode << "\n";
+	}
+}
+
+RigCtlServer::RigCtlServer(QObject *parent, Main_Widget *main)
+	: QObject(parent),
+	  main(main) {
+	server = new QTcpServer(this);
+//	if (!server->listen(QHostAddress::LocalHost, 19090)) {
+	if (!server->listen(QHostAddress::Any, 19090)) {
+		fprintf(stderr, "rigctl: failed to bind socket\n");
+		return;
+	}
+	connect(server, SIGNAL(newConnection()), this, SLOT(newConnection()));
+}
+
+void RigCtlServer::newConnection() {
+	QTcpSocket *conn = server->nextPendingConnection();
+	RigCtlSocket *sock = new RigCtlSocket(this, main, conn);
+	connect(conn, SIGNAL(disconnected()), conn, SLOT(deleteLater()));
+	connect(conn, SIGNAL(disconnected()), sock, SLOT(disconnected()));
+	connect(conn, SIGNAL(readyRead()), sock, SLOT(readyRead()));
+}
--- sdr-shell-4~svn156.orig/main_widget.h
+++ sdr-shell-4~svn156/main_widget.h
@@ -1,33 +1,45 @@
 #ifndef SDXCVR_MAINWIDGET_H
 #define SDXCVR_MAINWIDGET_H
 
+#define	VERSION 4.25
+
+#include <stdlib.h>
 #include <qwidget.h>
 #include <qapplication.h>
 #include <qpushbutton.h>
-#include <qscrollview.h>
 #include <qfont.h>
 #include <qpixmap.h>
 #include <qlistview.h>
-#include <qlabel.h>
+#include <QLabel>
 #include <qslider.h>
 #include <qlineedit.h>
 #include <qtimer.h>
 #include <qdatetime.h>
 #include <qfile.h>
-#include <qsettings.h>
+#include <QSettings>
 #include <qpainter.h>
+#include <QPaintDevice>
 #include <qimage.h>
 #include <qlcdnumber.h>
-#include <qheader.h>
 #include <qdir.h>
-#include <qtextedit.h>
+#include <QTextEdit>
+#include <QTextOption>
+#include <QIODevice>
+#include <QDataStream>
 #include <qscrollbar.h>
 #include <qtabwidget.h>
 #include <qspinbox.h>
-#include <qtextedit.h>
 #include <qgroupbox.h>
 #include <qbuttongroup.h>
 #include <qradiobutton.h>
+#include <qmutex.h>
+
+#include <QKeyEvent>
+#include <QMouseEvent>
+#include <QPalette>
+#include <QString>
+#include <QVBoxLayout>
+#include <QComboBox>
 
 #include <time.h>
 #include <sys/timeb.h>
@@ -36,12 +48,16 @@
 #include "spectrum.h"
 #include "varilabel.h"
 #include "memorycell.h"
-#include "worldmap.h"
 #include "pbscale.h"
+#include "hamlibwrapper.h"
+#include "rigctl.h"
+#include "dttsp.h"
+#include "freqlabel.h"
+#include "lcdfreq.h"
+#include "command.h"
+#include "idbutton.h"
 
-#define CMD_FILE "/dev/shm/SDRcommands"
-#define MTR_FILE "/dev/shm/SDRmeter"
-#define FFT_FILE "/dev/shm/SDRspectrum"
+#include "cmath"
 
 // DttSP constants
 #define DEFSPEC (4096)
@@ -49,260 +65,486 @@
 #define RXMETERPTS (5)
 #define TXMETERPTS (9)
 
-#define DEFSPEC (4096)
 #define SPECTRUM_HISTORY_SIZE (1000)
 
+#define ONE_OVER_F_GUARD_FREQUENCY (2000)  /*This is for the usbsoftrock which uses 
+only the upper half of the spectrum in order to omit the 1/f noise near DC */
+
 #define NUM_MODES 12
 
+#define NUM_BANDMEMS 10
+#define NUM_MEMS 8
+#define	NUM_CMD	8
+
+#define TOPFRM_V 35
+#define PBSFRM_V 15
+#define SPECFRM_V 120
+
+const int FREQUENCY_UPDATE = 2;
+const int OFFSET = 10000;
+
 class Main_Widget : public QWidget
 {
-    Q_OBJECT
+		Q_OBJECT
 
-    private:
-        QPushButton *quit_button;
-        QScrollView *scroll_view;
-        QFont *font;
-        QLineEdit *cfgCallInput, *cfgLOFreqInput;
-		QSpinBox *cfgIQPhaseInput, *cfgIQGainInput;
-		QSpinBox *specCalSpinBox, *metrCalSpinBox;
-        QPixmap *rxPix, *txPix;
-        QFrame *trxFrame;
-
-        Varilabel *NR_label;
-        Varilabel *ANF_label;
-        Varilabel *NB_label;
-        Varilabel *BIN_label;
-        Varilabel *MUTE_label;
-        Varilabel *SPEC_label;
-		
-		Varilabel *LSB_label;
-		Varilabel *USB_label;
-		Varilabel *DSB_label;
-		Varilabel *AM_label;
-		Varilabel *CWL_label;
-		Varilabel *CWU_label;
-		Varilabel *SAM_label;
-		Varilabel *FMN_label;		
+	private:
+                //Argument variables from main//
+                int rxCMDPort;
+                int txCMDPort;
+                int usbPort;
+                int meterPort;
+                int spectrumPort;
+                char *host;
+                bool verbose;
+                QSettings *settings;
+
+                //QPushButton *quit_button;
+		QPushButton *updateLOFreqButton;
+		QPushButton *updateTuneOffsetButton;
+		QPushButton *cmd0reset;
+		//QScrollView *scroll_view;
+		QFont *font;
+		QLineEdit *cfgCallInput, *cfgLOFreqInput, *cfgIFreqInput, *cfgHamlibRigInput, *cfgHamlibSpeedInput, *cfgHamlibPortInput;
+		QLineEdit *cfgTuneOffsetInput;
+		QSpinBox *cfgIQPhaseInput, *cfgIQGainInput, *cfgUSBOffsetInput;
+		QSpinBox *cfgTxIQPhaseInput, *cfgTxIQGainInput;
+		QSpinBox *cfgTxMicGainInput, *cfgTxOutputGainInput;
+		QSpinBox *specCalSpinBox, *metrCalSpinBox, *cfgLSBOffsetInput;
+		QSpinBox *cfgSlopeLowOffsetInput, *cfgSlopeHighOffsetInput;
+        QSpinBox *NR_TapsSpinBox, *NR_DelaySpinBox; 
+        QDoubleSpinBox *NR_GainSpinBox, *NR_LeakageSpinBox; 
+        QSpinBox *ANF_TapsSpinBox, *ANF_DelaySpinBox; 
+        QDoubleSpinBox *ANF_GainSpinBox, *ANF_LeakageSpinBox; 
+        QDoubleSpinBox *NB_ThresholdSpinBox;
+		QSpinBox *cfgSpecAvgInput, *cfgSpecLowInput, *cfgSpecHighInput;
+ 
+		QPixmap *rxPix, *txPix;
+		QFrame *trxFrame;
+        hamlibWrapper *ourHamlibWrapper;
+		RigCtlServer *rigCtl;
+		QMutex displayMutex, update_freqMutex;
+
+        //hamlib parameters.
+		QString portString;
+		rig_model_t rig;
+		QString rigString;
+		int speed;
+		QString speedString;
+		bool useHamlib;
+        void initHamlib ();
+		void initRigCtl();
+		bool useSlopeTune;
+		bool muteXmit;
+
+		bool useIF;
+		int usbOffset;
+		int lsbOffset;
+		int slopeLowOffset;
+		int slopeHighOffset;
+		int slopeTuneOffset;
+		int cwPitch;
+		QLabel *cfgSlopeLowOffsetLabel;
+		QLabel *cfgSlopeHighOffsetLabel;
+		bool rock_bound;	// True if Crystal, False USBSoftrock
+		bool enableTransmit;
+		bool dualConversion;
+		bool enableRIT;
+		bool enableSPLIT;
+
+		Varilabel *TRX_label;
+		Varilabel *NR_label;
+		Varilabel *ANF_label;
+		Varilabel *NB_label;
+		Varilabel *BIN_label;
+		Varilabel *MUTE_label;
+		Varilabel *SPEC_label;
+		Varilabel *UP_label;
+		Varilabel *DOWN_label;
+		Varilabel *RIT_label;
+		Varilabel *SPLIT_label;
+		QLabel *RX_label;
+		QLabel *MHz_label;
+
+		VariModelabel *LSB_label;
+		VariModelabel *USB_label;
+		VariModelabel *DSB_label;
+		VariModelabel *AM_label;
+		VariModelabel *CWL_label;
+		VariModelabel *CWU_label;
+		VariModelabel *SAM_label;
+		VariModelabel *FMN_label;
 		Varilabel *CFG_label;
-		Varilabel *AGC_O_label, *AGC_L_label, 
-			*AGC_S_label, *AGC_M_label, *AGC_F_label;
+		Varilabel *HELP_label;
+		Varilabel *AGC_O_label, *AGC_L_label, *AGC_S_label, *AGC_M_label, *AGC_F_label;
+		Varilabel *Zoom_in_label, *Zoom_out_label;
+
+		Freqlabel *THOUSANDS_label, *HUNDREDS_label, *TENS_label, *UNITS_label;
 
-        PassBandScale *pbscale;
+		PassBandScale *pbscale;
 
 		QFont *font1;
+		QFont *font2;
+		QFont *fontlcd;
 		QFontMetrics *font1Metrics;
-        QLabel *signal_S;
-        QLabel *signal_dBm;
-        QLabel *qtrLabel;
-        QLabel *CA_label;
-        QLabel *iqGainLabel, *iqPhaseLabel;
-        QLabel *callsignLabel;
-        QLabel *cmdLabel;
-        QLabel *CPU_label;
+		QFontMetrics *font2Metrics;
+		QFontMetrics *fontlcdMetrics;
+		QLabel *signal_S;
+		QLabel *signal_dBm;
+		QLabel *qtrLabel;
+		QLabel *CA_label;
+		QLabel *iqGainLabel, *iqPhaseLabel;
+		QLabel *callsignLabel;
+		QLabel *cmdLabel;
+		QLabel *CPU_label;
 		QLabel *f_label;
 		QLabel *logoLabel;
 		QLabel *M_label;
 		QLabel *AGC_label;
+		QLabel *Zoom_label;
 		QLabel *Spacer_label;
 
 		QFrame *logoFrame;
+
+		MemoryCell *f_cell[NUM_MEMS];
+
+		MemoryCell *band_cell[NUM_BANDMEMS];
+
+		Command		*c_cell[NUM_CMD];
+		QLineEdit	*cmdName[NUM_CMD], *cmdOnCommand[NUM_CMD];
+		QLineEdit	*cmdOffCommand[NUM_CMD];
+		QRadioButton *cmdRXbutton[NUM_CMD], *cmdTXbutton[NUM_CMD];
+		//IdPushButton *cmd0accept; //, *cmd0reset;
+
+		QLabel *af1_label;
+		QLabel *af2_label;
+		QLabel *af3_label;
+		QLabel *af4_label;
+		QLabel *af5_label;
+		QLabel *af6_label;
+		QLabel *af7_label;
+		QLabel *af8_label;
 		
-        MemoryCell *f1_cell;
-        MemoryCell *f2_cell;
-        MemoryCell *f3_cell;
-        MemoryCell *f4_cell;
-        MemoryCell *f5_cell;
-        MemoryCell *f6_cell;
-        MemoryCell *f7_cell;
-        MemoryCell *f8_cell;
-
-        QLabel *af1_label;
-        QLabel *af2_label;
-        QLabel *af3_label;
-        QLabel *af4_label;
-        QLabel *af5_label;
-        QLabel *af6_label;
-        QLabel *af7_label;
-        QLabel *af8_label;        
-        
-        Spectrogram *spectrogram;
-        Spectrum *spectrumFrame;
-        QFrame *spectrogramFrame;
-        QFrame *spectrumScale;
-        QPixmap *spectrumPix;
-        
-        QFrame *ctlFrame;
-        QFrame *ctlFrame2;
-        QFrame *cfgFrame;
-        QFrame *cmdFrame;
-        QFrame *signalFrame;
-        QFrame *signalBargraph[34];
-        QFrame *map;
-        QFrame *filterFrame;
-        QColor *signalColor[34];
-        QString *modeName[NUM_MODES];
-        QString stationCallsign;
-        QString stationQTH;
-        QLCDNumber *lcd;
-        QTextStream cmdStream;
-        QTextEdit *textFrame;
-		QTable *configTable;
+		QLabel *cfgRigLabel;
+		QLabel *cfgSpeedLabel;
+		QLabel *cfgPortLabel;
+
+		Spectrogram *spectrogram;
+		Spectrum *spectrumFrame;
+		QFrame *spectrogramFrame;
+		QFrame *spectrumScale;
+		QPixmap *spectrumPix;
+
+		QFrame *ctlFrame;
+		QFrame *ctlFrame2;
+		QFrame *cfgFrame;
+		QFrame *cmdFrame;
+		QFrame *helpFrame;
+		QFrame *dspFrame;
+		QFrame *signalFrame;
+		QFrame *signalBargraph[34];
+		QFrame *map;
+		QFrame *filterFrame;
+		QColor *signalColor[34];
+		QString *modeName[NUM_MODES];
+		QString stationCallsign;
+		QString stationQTH;
+		//QLCDNumber *lcd;
+		LCDFreq *lcd;
+		QLabel *rit;
+		QTextEdit *textFrame;
+        QRadioButton *polyFFT_button, *preFilter_button, *postFilter_button,
+			*fftWindow_0, *fftWindow_1, *fftWindow_2, *fftWindow_3, *fftWindow_4, *fftWindow_5,
+			*fftWindow_6, *fftWindow_7, *fftWindow_8, *fftWindow_9,*fftWindow_10, *fftWindow_11,
+			*fftWindow_12;
+		QRadioButton *specLineFillButton;
+		QRadioButton *cfgUseUSBsoftrock;
+		QRadioButton *cfgDualConversion;
+
+		QPalette p;
 
 		QFrame *step_1Hz_frame;
 		QFrame *step_10Hz_frame;
 		QFrame *step_100Hz_frame;
-		QFrame *step_1000Hz_frame;
-
-        WorldMap *worldmap;
-        
-        unsigned long long int rx_f;
-        QString rx_f_string;
-        int sample_rate;
-        int rx_delta_f, tuneStep;
-        int *filter_l, *filter_h, filter_w;
-        int USB_filter_l, USB_filter_h;
-        int LSB_filter_l, LSB_filter_h;
-        int DSB_filter_l, DSB_filter_h;
-        int CWL_filter_l, CWL_filter_h;
-        int CWU_filter_l, CWU_filter_h;
-        int SAM_filter_l, SAM_filter_h;
-        int FMN_filter_l, FMN_filter_h;
-        int AM_filter_l, AM_filter_h;
-        int s_dbm[34];
-        int spec_r[120], spec_g[120], spec_b[120];
-        int mode;
-        int iqGain, iqPhase;
+		QFrame *step_1KHz_frame;
+		QFrame *step_10KHz_frame;
+		QFrame *step_100KHz_frame;
+		QFrame *step_1MHz_frame;
+		QFrame *step_10MHz_frame;
+		QFrame *step_100MHz_frame;
+		
+		unsigned long long int rx_f, rx_if;
+		unsigned long long int tx_f;
+		QString rx_f_string, rx_if_string;
+		QString tx_f_string;
+		QString	TuneOffset_string;
+		bool specLineFill;	// true=enables spectrum display line filled
+                int sample_rate;
+		int tuneCenter;		// where to put tune center when using usbsoftrock
+		int spec_width;		// spectrum display width
+		int rx_delta_f;		// relative to center frequeny
+		int tx_delta_f;		// relative to center frequeny
+		int tuneStep;
+		int *filter_l, *filter_h, filter_w;
+		int USB_filter_l, USB_filter_h;
+		int LSB_filter_l, LSB_filter_h;
+		int DSB_filter_l, DSB_filter_h;
+		int CWL_filter_l, CWL_filter_h;
+		int CWU_filter_l, CWU_filter_h;
+		int SAM_filter_l, SAM_filter_h;
+		int FMN_filter_l, FMN_filter_h;
+		int AM_filter_l, AM_filter_h;
+		int s_dbm[34];
+		int spec_r[120], spec_g[120], spec_b[120];
+		rmode_t mode;
+		int iqGain, iqPhase;
+		int txIQGain, txIQPhase, txGain, micGain;
+		int NR_Taps, NR_Delay;
+        float NR_Gain, NR_Leakage;
+		int ANF_Taps, ANF_Delay;
+        float ANF_Gain, ANF_Leakage;
+		float NB_Threshold;
         int NR_state;
-        int ANF_state;
-        int NB_state;
-        int BIN_state;
-        int MUTE_state;
-        int SPEC_state;
-        int filterLine;
-        int font1PointSize;
-        int theme;
+		int ANF_state;
+		int NB_state;
+		int BIN_state;
+		int MUTE_state;
+		int SPEC_state;
+		int filterLine;
+		int font1PointSize;
+		int font2PointSize;
+		int fontlcdPointSize;
+		int theme;
 		int map_flag;
-		int polyphaseFFT;
+        int polyphaseFFT;
 		int fftWindow;
 		int spectrumType;
 		int agcType;
-
-        float spectrum[DEFSPEC];
-        float oscope[DEFSPEC];
-        float specApertureLow, specApertureHigh;
+		int transmit;
+		int band;
+		int updated;
+		char *sdr_mode;		// mode change script
+		char *sdr_band;		// band change script
+		char *sdr_rxtx;		// rx/tx change script
+
+		int once;
+
+		float spectrum[DEFSPEC];
+		float oscope[DEFSPEC];
+		float specApertureLow, specApertureHigh;
 		float specCal;
 		float metrCal;
-
-        int spectrum_history[SPECTRUM_HISTORY_SIZE][DEFSPEC];
-        int spectrum_head;
-        
-        float loadavg;
-        double my_lon, my_lat;
-        
-        FILE *cmdFile;
-        FILE *mtrFile;
-        FILE *fftFile;
-
-        FILE *loadavg_stream;
-        
-        enum kb_state { RX_F, TX_F, FILTER_L, FILTER_H };
-        enum modes
-		{ LSB, USB, DSB, CWL, CWU, FMN, AM, DIGU, SPEC, DIGL, SAM, DRM };
-        enum spec_type { SEMI_RAW, PRE_FILT, POST_FILT };
+		float hScale;
+		float vsScale;		// vertical Spectrum scale
+		float bin_bw;
+		int specAveraging;		// number of spectrum data points to average on each display
+		int specLow, specHigh;
+
+		int spectrum_history[SPECTRUM_HISTORY_SIZE][DEFSPEC];
+		int spectrum_head;
+		int spectrum_width;
+
+		float loadavg;
+		double my_lon, my_lat;
+
+		DttSPcmd      *pCmd;
+		DttSPspectrum *pSpectrum;
+		DttSPmeter    *pMeter;
+		USBSoftrockCmd *pUSBCmd;
+		DttSPTXcmd    *pTXCmd;
+
+		FILE *fftFile;
+
+		FILE *loadavg_stream;
+
+		enum kb_state { RX_F, TX_F, FILTER_L, FILTER_H };
+		enum modes
+		{ LSB, USB, DSB, CWL, CWU, FMN, AM, DIGU, SPEC, DIGL, SAM, DRM }; 
+		enum spec_type { SEMI_RAW, PRE_FILT, POST_FILT };
+		enum radio_state { RX, TX };
 
 		typedef enum _windowtype {
-			RECTANGULAR_WINDOW,
-			HANNING_WINDOW,
-			WELCH_WINDOW,
-			PARZEN_WINDOW,
-			BARTLETT_WINDOW,
-			HAMMING_WINDOW,
-			BLACKMAN2_WINDOW,
-			BLACKMAN3_WINDOW,
-			BLACKMAN4_WINDOW,
-			EXPONENTIAL_WINDOW,
-			RIEMANN_WINDOW,
-			BLACKMANHARRIS_WINDOW,
-			NUTTALL_WINDOW,
+		    RECTANGULAR_WINDOW,
+		    HANNING_WINDOW,
+		    WELCH_WINDOW,
+		    PARZEN_WINDOW,
+		    BARTLETT_WINDOW,
+		    HAMMING_WINDOW,
+		    BLACKMAN2_WINDOW,
+		    BLACKMAN3_WINDOW,
+		    BLACKMAN4_WINDOW,
+		    EXPONENTIAL_WINDOW,
+		    RIEMANN_WINDOW,
+		    BLACKMANHARRIS_WINDOW,
+		    NUTTALL_WINDOW,
 		} Windowtype;
 
-        void initConstants();
-        void rx_cmd( int );
-        void process_key( int );
-        void setRxFrequency();
-        void loadSettings();
-        void saveSettings();
-        void setScrollBarColors( QScrollBar * );
-        void setCA_label();
-        void set_NR( int );
-  
-        void set_ANF( int );
-        void set_NB( int );
-        void set_BIN( int );
-        void set_MUTE( int );
-        void set_SPEC( int );
-        void setIQGain();
-        void setIQPhase();
-        void drawSpectrogram();
-        void drawSpectrogram_2();
-        void drawSpectrumScale();
-        void drawSpectrumScale_2();
+		void initConstants();
+		void rx_cmd ( int );
+		void process_key ( int );
+		void setRxFrequency( int );
+		void setTxFrequency();
+		void setDefaultRxFrequency();
+                void loadSettings();
+                void setupSDR();
+                void saveSettings();
+		void setScrollBarColors ( QScrollBar * );
+		void setCA_label();
+		void set_NR ( int );
+		void set_ANF ( int );
+		void set_NB ( int );
+		void set_BIN ( int );
+		void set_SPEC ( int );
+		void set_RIT ( int );
+		void set_SPLIT ( int );
+		void setIQGain();
+		void setIQPhase();
+		void setTxIQGain();
+		void setTxIQPhase();
+		void setTxGain( int );
+		void drawSpectrogram();
+		void drawSpectrogram_2();
+		void drawSpectrumScale();
+		void drawSpectrumScale_2();
 		void drawPassBandScale();
-        void setTheme( int );
+		void setTheme ( int );
 		void updateLayout();
 		void loadMemoryCells();
+		void loadCommandCells();
 
-    public:
-        Main_Widget(QWidget *parent = 0, const char *name = 0);
-
-    public slots:
-        void finish();
-        void readMeter();
-        void readSpectrum();
-        //void processCmdLine();
-        void spectrogramClicked( int );
-        void plotSpectrum( int );
-        void tune( int );
-        void processorLoad();
-
-        void setTuneStep( int );
-        void toggle_NR( int );
-        void toggle_ANF( int );
-        void toggle_NB( int );
-        void toggle_BIN( int );
-        void toggle_MUTE( int );
-        void toggle_SPEC( int );
-        
-        void setFilter_l( int );
-        void setFilter_h( int );
-        void setMode( int );
-        void setFilter();
-		void f_at_mousepointer( int );
-		void setLowerFilterScale( int );
-		void setUpperFilterScale( int );
-		void setCfg( int);
-
-        void readMem( MemoryCell * );
-        void writeMem( MemoryCell * );
-        void displayMem( MemoryCell * );
-        void displayNCO( int );
+	public:
+                Main_Widget();
+                void init();
+                void set_rxCMDPort( int );
+                void set_txCMDPort( int );
+                void set_USBPort( int );
+                void set_SpectrumPort( int );
+                void set_MeterPort( int );
+                void set_SampleRate( int );
+                void set_Host( char * );
+                void set_Verbose( bool );
+                void set_InitFile(char *);
+
+		rmode_t rigGetMode();
+		int rigGetFilterWidth();
+                unsigned long long int rigGetFrequency();
+                void rigSetFrequency(unsigned long long int rigctlfreq);
+                void rigSetPTT ( int );
+
+	public slots:
+		void finish();
+		void readMeter();
+		void readSpectrum();
+		void spectrogramClicked ( int );
+		void plotSpectrum ( int );
+		void tune ( int );
+		void tunef ( int );
+		void tunewheel ( int );
+		void processorLoad();
+
+		void setTuneStep ( int );
+		void toggle_NR ( int );
+		void toggle_ANF ( int );
+		void toggle_NB ( int );
+		void toggle_BIN ( int );
+		void toggle_MUTE ( int );
+		void toggle_SPEC ( int );
+		void leave_band ( int );
+		void enter_band ( int );
+		void band_UP ( int );
+		void band_DOWN ( int );
+		void toggle_TX ( int );
+		void TXon();
+		void TXoff();
+		void toggle_RIT ( int );
+		void toggle_SPLIT ( int );
+
+		void setFilter_l ( int );
+		void setFilter_h ( int );
+		void setMode ( rmode_t, bool, bool );
+		void setFilter();
+		void f_at_mousepointer ( int );
+		void setLowerFilterScale ( int );
+		void setUpperFilterScale ( int );
+		void setCfg ( int );
+		void setHelp ( int );
+		void setDSP ( int );
+
+		void readMem ( MemoryCell * );
+		void writeMem ( MemoryCell * );
+		void displayMem ( MemoryCell * );
+		void toggleCmd ( Command *);
+		void configCmd ( Command * );
+		void displayNCO ( int );
 
 		void updateCallsign();
 		void updateLOFreq();
-		void updateIQGain( int );
-		void updateIQPhase( int );
-		void setPolyFFT( int );
-		void setFFTWindow( int );
-		void setSpectrumType( int );
-		void setAGC( int );
-		void calibrateSpec( int );
-		void calibrateMetr( int );
-
-    protected:
-        void keyPressEvent( QKeyEvent * );
-        void paintEvent( QPaintEvent * );
-		void focusInEvent( QFocusEvent * );
-        void focusOutEvent( QFocusEvent * );
-        void closeEvent( QCloseEvent * );
+		void updateIFreq();
+		void updateUSBOffset ( int );
+		void updateLSBOffset ( int );
+		void updateSlopeHighOffset ( int offset );
+		void updateSlopeLowOffset ( int offset );	
+		void updateHamlib();
+		void updateIQGain ( int );
+		void updateIQPhase ( int );
+		void updateTxIQGain ( int );
+		void updateTxIQPhase ( int );
+		void updateTxMicGain ( int );
+		void updateTxOutputGain ( int );
+                void setPolyFFT ( );
+		void setFFTWindow ( );
+		void updateSpecAvg ( int );
+		void updateSpecLow ( int );
+		void updateSpecHigh ( int );
+		void setLineFill ( );
+		void setSpectrumType ( );
+		void setSpectrumDefaults ( );
+		void setAGC ( int );
+		void zoomIN ( int );
+		void zoomOUT ( int );
+		void calibrateSpec ( int );
+		void calibrateMetr ( int );
+        void setNR_Taps ( int );
+        void setNR_Delay ( int );
+        void setNR_Gain ( double);
+        void setNR_Leakage ( double);
+        void set_NRvals ( );
+        void setANF_Taps ( int );
+        void setANF_Delay ( int );
+        void setANF_Gain ( double );
+        void setANF_Leakage ( double );
+        void set_ANFvals ( );
+        void setNB_Threshold ( double );
+        void set_NBvals ( );
+		void updateUseUSBsoftrock ( bool );
+		void updateTransmit ( bool );
+		void updateDualConversion ( bool );
+		void updateTuneOffset ( );
+		void updateCmd (int n);
+		void resetCmd (int n);
+		void updatePTT();
+		void updateFreq();
+		
+		void set_MUTE ( int );
+		void setOurRxFrequency ( double );
+		void setIF ( bool );
+		void setHamlib ( bool );
+		void setSlopeLowOffset ( int );
+		void setSlopeHighOffset (int );
+		void setSlopeTune ( bool );
+		void setCWPitch ( int );
+		void setMuteXmit ( bool );
+
+	protected:
+		void keyPressEvent ( QKeyEvent * );
+		void paintEvent ( QPaintEvent * );
+		void focusInEvent ( QFocusEvent * );
+		void focusOutEvent ( QFocusEvent * );
+		void closeEvent ( QCloseEvent * );
+		
+	signals:
+		void changeRigMode (rmode_t, pbwidth_t );
+		void changeSlopeTune ( bool );
+		void toggleHamlibButton ( bool );
+		void tellMuteXmit ( bool );
 };
 #endif
--- sdr-shell-4~svn156.orig/main.cpp
+++ sdr-shell-4~svn156/main.cpp
@@ -2,15 +2,108 @@
 #include <qfontdatabase.h>
 #include "main_widget.h"
 #include "app.xpm"
+#include <getopt.h>
+#include <QSettings>
 
 
 int main (int argc, char **argv)
 {
+    // Specify options and their syntax
+    static struct option long_options[] =
+    {
+        /* These options set a flag. */
+        {"verbose", no_argument, 0, 'v'},
+
+        {"rx-command-port", required_argument, 0, 'r'},
+        {"spectrum-port", required_argument, 0, 's'},
+        {"meter-port", required_argument, 0, 'm'},
+        {"tx-command-port", required_argument, 0, 't'},
+        {"sample_rate", required_argument, 0, 'f'},
+        {"host", required_argument, 0, 'h'},
+        {"usbsoftrock-port", required_argument, 0, 'u'},
+        {"conf-file", required_argument, 0, 'l'},
+        {"help", no_argument, 0, '?'},
+        {"?", no_argument, 0, '?'},
+        {0, 0, 0, 0}
+    };
+
+
     QApplication app(argc, argv);
-   
-    Main_Widget *w = new Main_Widget( 0, "mainwidget");
-    w->setIcon( app_xpm ); 
-    app.setMainWidget( w );
+    Main_Widget* w = new Main_Widget;
+
+    // Iterate over options and handle each one as appropriate
+    char c;
+    // The function getopt_long stores the option index here.
+    int option_index = 0;
+
+    while ( (c = getopt_long ( argc, argv, "v?h:r:s:m:t:f:h:u:l:",
+                               long_options, &option_index )) != -1 )
+    {
+        switch ( c )
+        {
+        case 0:
+            // If this option set a flag, do nothing else now.
+            if ( long_options[option_index].flag != 0 )
+                break;
+        case 'f':
+            w->set_SampleRate(atoi(optarg));
+            break;
+        case 'h':
+            w->set_Host(optarg);
+            fprintf(stderr, "host is: %s",optarg);
+            break;
+        case 'm':
+            w->set_MeterPort(atoi(optarg));
+            break;
+        case 'l':
+            w->set_InitFile(optarg);
+            break;
+        case 'r':
+            w->set_rxCMDPort(atoi(optarg));
+            break;
+        case 's':
+            w->set_SpectrumPort(atoi(optarg));
+            break;
+        case 't':
+            w->set_txCMDPort(atoi(optarg));
+            break;
+        case 'u':
+            w->set_USBPort(atoi(optarg));
+            break;
+        case 'v':
+            w->set_Verbose(true);
+            break;
+        case '?':
+
+        default :
+                printf(
+                        "Options are: \n"
+                        "-v or --verbose for verbose output\n"
+                        "-f or --sample-rate=<samplerate>\n"
+                        "-r or --rx-command-port=<portnum> \n"
+                        "   Use port <portnum> as a conduit for update commands\n"
+                        "   Default is 19001\n"
+                        "-s or --spectrum-port=<portnum> \n"
+                        "   Use port <portnum> as conduit for spectrum data\n"
+                        "   Default is 19002\n"
+                        "-m or --meter-port=<portnum> \n"
+                        "   Use port <portnum> as conduit for meter data\n"
+                        "   Default is 19003\n"
+                        "-t or --tx-command-port=<portnum> \n"
+                        "   Use port <portnum> as a conduit for update commands\n"
+                        "   Default is 19005\n"
+                        "-u or --usbsoftrock-port=<portnum> \n"
+                        "   Use port <portnum> as a conduit for update commands\n"
+                        "   Default is 19004\n"
+                        "-l or --conf-file=<configuration file>\n"
+                        "   The file is in ~/.config/freesoftware/ on Linux.\n"
+                        "   \n"
+                        );
+        exit ( 0 );
+        }
+    }
+    w->init();
+    app.setWindowIcon( QIcon(app_xpm) );
     w->show();
     return app.exec();
 }
--- /dev/null
+++ sdr-shell-4~svn156/README
@@ -0,0 +1,267 @@
+
+Getting started using SDR-Shell with the SoftRock RXTX 6.3
+
+sdr-shell is a graphical user interface for interfacing with the DttSP
+(sdr-core) software-defined radio (SDR).  It can use two sdr-core
+processes, one each for receive and transmit, and usbsoftrock for tuning
+the USB-controllable synthesizer on the SoftRock SDR.
+
+Getting a radio working with sdr-shell, dttsp, and utilities is a lot like
+building your own radio, but with less solder.  Instead of solder wick and
+a solder sucker, you have a reset button.
+
+For information about the SoftRock SDR, see:
+
+	http://www.kb9yig.com		The designer's site
+	http://www.wb5rvz.com/sdr	Build instructions
+	softrock40@yahoogroups.com	Soft Rock discussion group 
+					(Very active)
+	dttsp-linux@yahoogroups.com	the dttsp discussion group
+
+sdr-shell requires:
+  dttsp (two copies: one recieve one transmit)
+  usbsoftrock 1.0.1
+
+usbsoftrock is available from the softrock40 Yahoo Groups files area,
+under VK6JBL's directory (usbsoftrock-1.0.1.tar.gz).
+
+The best place to get dttsp source is:
+	https://www.cgran.org/cgran/projects/dttsp/branches/ab2kt/sdr-core
+
+Please see the file "INSTALL" for build instructions.
+
+Running on Linux
+
+The shell script 'start-delta44' will start jackd, usbsoftrock and sdr-shell.
+You will need to adjust the settings in that script for your si570 oscillator
+(usbsoftrock -x *value*), and your sound card's ports.
+
+
+to send commands to the dttsp command port, use:
+  nc -v -u localhost 19001
+
+Delta-44 card owners: Use 'envy24control' to set the card's hardware settings.
+Under Analog Volume, I set everything to maximum.
+ (Fedora: alsa-tools, Ubuntu: alsa-tools-gui)
+
+qjackctl is a graphical configuration/connection program for the JACK Audio
+Connection Kit.
+ (Fedora: qjackctl)
+
+
+Running on OSX
+
+I am running on a Macbook Pro (2009 vintage) with a Creative Audigy USB audio
+adapter.  It has 5+1 output and a Line/Mic input.  This adapter has given me
+some problems: it always requires power cycling following the mac going to
+sleep, but has been adequate for occasional use.  With four output channels
+and 2 input channels in 24-bit mode, I can only use it for 4800 kHz of spectrum.
+With usbsoftrock and the way sdr-shell displays spectrum this been adequate
+for me.
+
+1) increase the maximum UDP datagram size:
+	sudo sysctl -w net.inet.udp.maxdgram=32768
+
+2)   start the audio midi tool (Applications -> Utilities Audio MIDI Setup)
+   create an aggregate device consisting of:
+	audio output
+	I/Q output
+	I/Q input
+	audio input (I use the microphone)
+   set each to a 48khz input rate.
+
+   deselect the 'thru' selection of the external line connector input source
+ 
+
+3) start jackd using JackPilot.  I've never gotten jackd to start from
+   the command-line due to problems finding shared libraries.
+
+  Configuration:
+      Jack Server
+	Driver: coreaudio
+	Interface: Aggregate Device
+	Sample Rate: 4800
+	Buffer Size: 2048
+	Interface Output Channels: 4
+	Interface Input Channels: 4
+
+      Jack Router
+	Virtual Input Channels: 4
+	Virtual Output Channels: 4
+	Auto Connect with physical ports: 4
+
+If you find a way to start jack and midi tool from a shell script, please
+post your solution!
+
+4) start usbsoftrock, dttsp and sdr-shell:
+
+start-audigy.sh
+
+
+Use Notes
+
+     Clicking the 'rx' symbol switches from receive to transmit and changes the
+symbol to tx.  Clicking the 'tx' symbol turns transmit off.
+
+     The receive dttsp is muted during transmit.  I found it unnerving to talk
+while hearing myself echoed back with a 1/2 second delay.
+
+     Bands are memories (there are ten of them) that are automatically saved when
+a band change occurs.  Bands wrap from ten to one going up, and from one to ten
+when going down.
+
+	Tuning:
+
+	Tuning is done on two levels: within the bandwidth of the audio card,
+and by using a programmable oscillator.  For example, the recent SoftRock
+SDRs use an Si570 synthesized oscillator that can be configured over USB.
+This is enabled when the "Use usbsoftrock" option is selected (General
+Configuration tab), sdr-shell communicates with the usbsoftrock program
+which in turn communicates with the USB-based controller.
+
+If sdr-shell is configured to monitor the IF of another radio, it can
+communicate with the radio using hamblib to display the radio's frequency.
+It can also set it.  These options are on the IF Configuration tab.
+No better description is available; experiment with it.
+
+The largest granularity tuning is done using the arrow keys.  The left/right
+arrow keys tune up or down, with the step size selected by the up/down
+arrow keys.  There is a highlighted bar under the frequency display that
+indicates the step size. (This always sets the external oscillator).
+When using the usbsoftrock, this permits tuning anywhere that the SDR is
+capable of tuning.
+
+Positioning the mouse cursor over one of the numbers in the frequency display
+and using the scroll wheel, the SDR can be tuned by that granularity.  If it
+is 1khz, or less, tuning with the DttSP oscillator is done, and this will tune
+past the edge of the sound card by retuning usbsoftrock.  Clicking on one of
+the numbers sets the tuning step size for the mouse wheel and arrow keys to
+that value.
+
+By clicking one of the mouse buttons and dragging the cursor in the
+spectrogram window, tuning on a finger granularity of 1hz, 10hz or 100hz
+for the left, right and middle buttons, respectively.  However, this is
+limited to tuning only the dttsp "Oscillator".
+
+The mouse scroll wheel tunes by the step size underlined on the frequency
+display.
+
+By clicking in the spectrum window, sdr-shell tunes to center the frequency
+at the mouse pointer in the center of the filter.
+
+When usbsoftrock mode is selected, the dttsp Oscillator frequency is set to
+be half-way between DC and the upper end of the audio card's bandwidth.
+This keeps signals out of the muddy area near DC.  This value can be
+changed on the General Configuration tab.
+
+	Arbitrary DttSP commands
+
+With the huge number of features available in dttsp, it it a big job to
+create a GUI to operate on all of them.  Instead, 8 arbitrary commands are
+available.  These are labeled "C0" - "C8" along the bottom of the display.
+Each can hold two command strings: one to send to turn on and another to
+send to turn off.  If there is no off command, then only the on command
+is sent.  Left-click on the C# label to toggle, and bring up the configure
+window by right-clicking on any of the labels.
+
+Example:
+	Name:   NR2
+	On:     setSDROM 1
+	Off:    setSDROM 0
+	send to RX DttSP
+
+click Accept.  The C0 label will change to NR2 and further clicks on the label will
+send the setSDROM command.
+
+Multiple commands can be sent at once by separating the commands with a semicolon
+(resemblance to shell commands is purely cosmetic):
+
+	Name:   NR2
+	On:     setSDROM 1;setSDROMvals 2.5
+	Off:    setSDROM 0
+	send to RX DttSP
+
+the default SDROM threshold happens to be 2.5.
+
+
+     I set the dttsp transmit gain to about 15-18 to get maximum power
+out of my RXTX.
+
+     Configuration between runs is written to the file using the normal QT
+mechanisms.  The file is:
+	.config/freesoftware/sdr-shell.conf
+
+Keyboard Commands
+	t	toggle transmit on/off
+	space	turn transmit off
+U	set_filer_l -1
+I	set_filer_l +1
+O	set_filter_h -1
+P	set_filter_h +1
+[	filter[lh] -= step
+]	filter[lh] += step
+q	iqGain--
+w	iqGain++
+e	iqPhase--
+r	iqPhase++
+z	specAperatureLow--
+x	specAperatureLow++
+c	specAperatureHigh--
+v	specAperatureHigh++
+
+h	up arrow
+j	left arrow
+k	right arrow
+l	down arrow
+
+
+
+Miscellaneous
+
+
+Two Cards
+I have, as a test, used two audio cards on Linux with dttsp, by running two
+copies of jack:
+
+   default jackd instance:
+   /usr/bin/jackd -R -P55 -p128 -t2000 -dalsa -r48000 -D -Chw:2 -Phw:0 -s&
+   start the receive dttsp
+
+   second jackd instance:
+   export JACK_DEFAULT_SERVER=tx
+   /usr/bin/jackd -R -P55 -p128 -t2000 -dalsa -r48000 -D -Chw:0 -Phw:2 -s&
+   start the transmit dttsp
+
+
+I/Q Input on Speakers
+
+If your audio output is on the same audio card as the I/Q input, you'll likely
+hear some of the I/Q passed through.
+
+To mute line input:
+	amixer -c 0 controls
+look for
+	numid=18,iface=MIXER,name='Line Playback Switch'
+
+run:
+	amixer -c 0 cset numid=18 0
+
+To change the input source:
+
+	amixer controls
+
+look for Capture Source
+
+	amixer -c 0 cset numid=26 0     # set to mic
+	amixer -c 0 cset numid=26 4     # set to line
+
+I built the dttsp keyers with:
+	gcc -g -O2 -I . -c keyboard-keyer.c
+	gcc -g -O2 -I . -c iambic-keyer.c
+	gcc  -g -O2   -o keyboard-keyer keyboard-keyer.o  libDttSP.a -llo \
+		-lpthread -lm -ljack -lfftw3f
+	gcc  -g -O2   -o iambic-keyer iambic-keyer.o  libDttSP.a -llo \
+		-lpthread -lm -ljack -lfftw3f
+
+Glen Overby, kc0iyt  gpoverby@gmail.com  January, 2011
+
--- sdr-shell-4~svn156.orig/varilabel.cpp
+++ sdr-shell-4~svn156/varilabel.cpp
@@ -1,8 +1,7 @@
 #include "varilabel.h"
 
-Varilabel::Varilabel(QWidget *parent, const char *name) : QLabel(parent, name)
+Varilabel::Varilabel(QWidget *parent) : QLabel(parent)
 {
-
 }
 
 void Varilabel::mouseMoveEvent( QMouseEvent *e )
@@ -20,12 +19,39 @@ void Varilabel::mouseMoveEvent( QMouseEv
     emit y( e->y() );
 }
 
-void Varilabel::mouseReleaseEvent ( QMouseEvent * )
+void Varilabel::mouseReleaseEvent ( QMouseEvent *e )
 {
-    emit mouseRelease( label );
+	if (e->button() & Qt::LeftButton)
+    	emit mouseRelease( label );
+	if (e->button() & Qt::RightButton)
+    	emit mouseRelease2( label );
+	if (e->button() & Qt::MidButton)
+    	emit mouseRelease3( label );
 }
 
 void Varilabel::setLabel( int l )
 {
   label = l;
 }
+
+
+VariModelabel::VariModelabel(QWidget *parent) : Varilabel (parent)
+{
+}
+
+void VariModelabel::mouseReleaseEvent ( QMouseEvent *e )
+{
+    bool force = 0;
+#if 0
+    if (e->state() & ShiftButton) {
+	fprintf( stderr, "VariModelabel mouseReleaseEvent: ShiftButton\n");
+	force = 1;
+    }
+#endif
+    emit mouseRelease( label, FALSE, force );
+}
+
+void VariModelabel::setLabel( rmode_t l )
+{
+	label = l;
+}
--- sdr-shell-4~svn156.orig/text.h
+++ sdr-shell-4~svn156/text.h
@@ -1,5 +1,5 @@
 
-char *helptext = 
+const char *helptext = 
 "<center> \
 Table of Contents<br> \
 ----------------------------------<br> \
@@ -14,7 +14,8 @@ Spectrogram<br> \
 Filter Control<br> \
 Spectrum<br> \
 Virtual VFOs<br> \
-Automatic Gain Control (AGC) \
+Automatic Gain Control (AGC)<br>\
+USB Tuned Softrock \
 </center><br> \
 <center><a name=\"S-Meter\">S-Meter</a><br> \
 ----------------------------------</center><br> \
@@ -118,4 +119,32 @@ VFO cell.<br> \
 The AGC Control is located at the AGC label on the lower Control Frame. The \
 AGC types are long (L), slow (S), medium (M), and fast (F). To select a type, \
 right-click on the type letter.<br> \
-";
+<br> \
+<center>Use as IF for Older Rig<br> \
+----------------------------------</center><br> \
+With a Softrock, you can connect into the IF of an older rig.   This software \
+in conjunction with Hamlib, allows you to display the correct frequency on the \
+computer.  You can use the DSP features described above with the exception that \
+tuning by clicking on the spectrum will not change your frequency.  You can effect \
+IF shift by using the arrow keys.  The left and right arrows shift the IF, the up and down \
+arrows change the amount the IF is shifted.  The G key will center the IF again. Slope \
+Tuning on the (Kenwood TS-850S anyway with a Softrock on the 455 KHz IF) is compensated \
+for if you select it.  You can adjust \
+the offsets for LSB and USB separately.  Mode selection can be made from the rig or the \
+computer.  <br> \
+<br> \
+<center>USB Tuned Softrock<br> \
+----------------------------------</center><br> \
+A SoftRock v9.0 Lite+USB Xtall Receiver (or similar receiver using the USB I2C kit \
+to provide control of the Si570 local oscillator) can be controlled from sdr-shell.  To set this up, \
+prior to startding sdr-shell, \
+start usbsoftrock with the -d option to make it respond to UDP commands from \
+sdr-shell.  Then start sdr-shell and select the radio button to use usbsoftrock via \
+UDP on the General Config pannel.\
+<br> <br> USBsoftrock is software by Andrew Nilsson, VK6JBL, to control the USB-I2C controller \
+for the Si570 multi-band softrock receivers. It is available in the Files section of the Yahoo Softrock40 Group \
+under VK6JBL.  The URL at this time is:  http://groups.yahoo.com/group/softrock40/files/VK6JBL/ \
+<br> \
+<br> "
+;
+
--- sdr-shell-4~svn156.orig/spectrum.h
+++ sdr-shell-4~svn156/spectrum.h
@@ -2,23 +2,27 @@
 #define SDXCVR_SPECTRUM_H
 
 #include <qwidget.h>
+#include <QMouseEvent>
 
 class Spectrum : public QWidget
 {
     Q_OBJECT
     
     public:
-        Spectrum(QWidget *parent = 0, const char *name = 0, WFlags f = 0 );
-
+//        Spectrum(QWidget *parent = 0, const char *name = 0, WFlags f = 0 );
+        Spectrum(QWidget *parent = 0);
     private:
         int mouseMoving;
 
     protected:
         void mouseReleaseEvent( QMouseEvent * );
         void mouseMoveEvent( QMouseEvent * );
+	void wheelEvent(QWheelEvent *event);
 
     signals:
 		void movement( int );
 		void tune( int );
+       	void tune2( int );
+       	void tune3( int );
 };
 #endif
--- sdr-shell-4~svn156.orig/memorycell.h
+++ sdr-shell-4~svn156/memorycell.h
@@ -3,23 +3,27 @@
 
 #include <qlabel.h>
 #include <qstring.h>
+#include <hamlib/rig.h>
+#include <QMouseEvent>
 
 class MemoryCell : public QLabel
 {
     Q_OBJECT
     
     public:
-        MemoryCell(QWidget *parent = 0, const char *name = 0);
+        MemoryCell(QWidget *parent = 0);
 
         void setID( int );
         void setMemo( QString );
         void setFrequency( long long int );
-        void setMode( int );
+        void setTxFrequency( long long int );
+        void setMode( rmode_t );
         void setFilter( int, int );
         
         int getID();
         int getMemo();
         long long int getFrequency();        
+        long long int getTxFrequency();        
         int getMode();
         int getFilter_l();
         int getFilter_h(); 
@@ -28,6 +32,7 @@ class MemoryCell : public QLabel
         int id;
         QString memo;
         long long int frequency;
+        long long int txFrequency;
         int mode;
         int filter_l;
         int filter_h;
@@ -35,6 +40,7 @@ class MemoryCell : public QLabel
     protected:
         void mouseReleaseEvent ( QMouseEvent * );
         void enterEvent ( QEvent * );
+        void leaveEvent ( QEvent * );
 
     signals:
         void read( MemoryCell * );
--- sdr-shell-4~svn156.orig/spectrogram.h
+++ sdr-shell-4~svn156/spectrogram.h
@@ -2,24 +2,27 @@
 #define SDXCVR_SPECTROGRAM_H
 
 #include <qwidget.h>
+#include <QMouseEvent>
 
 class Spectrogram : public QWidget
 {
     Q_OBJECT
     
     public:
-        Spectrogram(QWidget *parent = 0, const char *name = 0);
-
+//        Spectrogram(QWidget *parent = 0, const char *name = 0);
+        Spectrogram(QWidget *parent = 0);
     private:
         int mouseMoving;
 
     protected:
         void mouseReleaseEvent( QMouseEvent * );
         void mouseMoveEvent( QMouseEvent * );
+	void wheelEvent(QWheelEvent *event);
 
     signals:
         void tune1( int );
         void tune2( int );
+        void tune3( int );
         void plot( int );
 	void movement( int );
 };
--- sdr-shell-4~svn156.orig/mhz.xpm
+++ sdr-shell-4~svn156/mhz.xpm
@@ -1,5 +1,5 @@
 /* XPM */
-static char *mhz_xpm[]={
+static const char *mhz_xpm[]={
 "19 9 2 1",
 ". c #000000",
 "# c #ffffff",
--- sdr-shell-4~svn156.orig/sdr-shell.pro
+++ sdr-shell-4~svn156/sdr-shell.pro
@@ -1,14 +1,59 @@
-######################################################################
 # Automatically generated by qmake (1.07a) Wed Apr 27 20:45:03 2005
-######################################################################
-
+# #####################################################################
 TEMPLATE = app
 INCLUDEPATH += .
+CONFIG += qt \
+    debug
+LIBS += `pkg-config \
+    --cflags \
+    --libs \
+    hamlib`
+
+QT += network
 
 # Input
-HEADERS += main_widget.h spectrogram.h varilabel.h memorycell.h \
-           pbscale.h sunpropagator.h moonpropagator.h worldmap.h \
-           spectrum.h text.h
-SOURCES += main.cpp main_widget.cpp spectrogram.cpp varilabel.cpp \
-           memorycell.cpp spectrum.cpp \
-           pbscale.cpp sunpropagator.cpp moonpropagator.cpp worldmap.cpp
+HEADERS += main_widget.h \
+    spectrogram.h \
+    varilabel.h \
+    memorycell.h \
+    pbscale.h \
+    spectrum.h \
+    text.h \
+    hamlibwrapper.h \
+    rigctl.h \
+    dttsp.h \
+    lcdfreq.h \
+    command.h \
+    idbutton.h \
+
+SOURCES += main.cpp \
+    main_widget.cpp \
+    spectrogram.cpp \
+    varilabel.cpp \
+    memorycell.cpp \
+    spectrum.cpp \
+    hamlibwrapper.cpp \
+    rigctl.cpp \
+    pbscale.cpp \
+    dttsp.cpp \
+    lcdfreq.cpp \
+    command.cpp \
+    idbutton.cpp \
+
+DISTFILES += test \
+    KL7NA_Notes
+
+#DEFINES += PTT_POLL
+#DEFINES += FREQ_POLL
+
+
+OTHER_FILES += \
+    CHANGELOG
+
+# Installation
+target.path += /usr/bin
+startupfiles.path += /usr/share/doc/sdr-shell/startup/
+startupfiles.files += startup/*
+INSTALLS += target
+INSTALLS += startupfiles
+
--- sdr-shell-4~svn156.orig/pbscale.cpp
+++ sdr-shell-4~svn156/pbscale.cpp
@@ -1,7 +1,9 @@
 #include "pbscale.h"
 
-PassBandScale::PassBandScale(QWidget *parent, const char *name, WFlags f ) 
-	: QWidget(parent, name, f)
+//PassBandScale::PassBandScale(QWidget *parent, const char *name, WFlags f ) 
+//	: QWidget(parent, name, f)
+PassBandScale::PassBandScale(QWidget *parent) : QWidget(parent) 
+//PassBandScale::PassBandScale(QWidget *parent, const char *name) : QWidget(parent, name)
 {
 	setMouseTracking( true );
 }
@@ -15,8 +17,8 @@ void PassBandScale::mousePressEvent( QMo
 {
 	x0 = e->x();
 
-	if ( e->button() == LeftButton )
+	if ( e->button() == Qt::LeftButton )
 		emit set_lower_pb( x0 );
-	if ( e->button() == RightButton )	
+	if ( e->button() == Qt::RightButton )	
 		emit set_upper_pb( x0 );
 }
--- sdr-shell-4~svn156.orig/main_widget.cpp
+++ sdr-shell-4~svn156/main_widget.cpp
@@ -9,1615 +9,2788 @@
 #include "tx.xpm"
 #include "logo.xpm"
 #include "text.h"
+#include "dttsp.h"
 
-Main_Widget::Main_Widget(QWidget *parent, const char *name) 
-	: QWidget(parent, name) 
-{
-    setFocusPolicy( QWidget::TabFocus );
-    setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-	setMinimumWidth( 650 );
-	setMinimumHeight( 300 );
 
-    initConstants();
-    loadSettings();
+/* formatting note: in vi :set tab=4 */
+
+
+static int old_PTT = 1;		// start with checking PTT, and do a reset to Rx
+int CW_tone = 700;		// default CW tone 700 Hz
+
+
+Main_Widget::Main_Widget()
+        : QWidget()
+{
+    char *ep;
+    sample_rate = 0; //Set Default Values//
+    rxCMDPort=19001;
+    txCMDPort=19005;
+    meterPort=19003;
+    spectrumPort=19002;
+    host = NULL;
+    usbPort =19004;
+    verbose = false;
+    settings = new QSettings("freesoftware", "sdr-shell");
+    if ( ( ep = getenv ( "SDR_DEFRATE" ) ) )
+    {
+        sample_rate = atoi ( ep );
+        if(verbose) fprintf ( stderr, "sample_rate = %d\n", sample_rate );
+        tuneCenter = -sample_rate / 4;
+    }
+}
+void Main_Widget::init()
+{
+    QString version;
+	setFocusPolicy ( Qt::TabFocus );
+	setMinimumWidth ( 650 );
+	setMinimumHeight ( 300 );
+
+	//setAttribute( Qt::WA_OpaquePaintEvent, true);
+	setAttribute( Qt::WA_NoSystemBackground, true);
+    setPalette(QPalette(QColor(0, 0, 0)));
+    setAutoFillBackground(true);
+    setMinimumWidth( 650 );
+    setMinimumHeight( 300 );
+	initConstants();
+	slopeTuneOffset = 0;
+
+	loadSettings();
+    if (sample_rate == 0) {
+        fprintf ( stderr, "Unable to get SDR_DEFRATE environment variable.\n"
+                 "Use the -f or --sample-rate option or\n"
+                 "you can set SDR_DEFRATE as follows:\n"
+                 "bash$ export SDR_DEFRATE=48000\n" );
+        exit ( 1 );
+    }
+    bin_bw = sample_rate / 4096.0;
+	setupSDR();
 
-	setCaption( "SDR-Shell v2b @ " + stationCallsign );
+	version.sprintf("%5.2f", VERSION);
+	setWindowTitle("SDR-Shell " + version + " @ " + stationCallsign );
 
 	font1PointSize = 14;
-    font1 = new QFont( "Andale Mono", font1PointSize, FALSE);
-    font1Metrics = new QFontMetrics( *font1 );
+	font1 = new QFont ( "Andale Mono", font1PointSize, FALSE );
+	font1Metrics = new QFontMetrics ( *font1 );
+	
+	fontlcdPointSize = 15;
+	fontlcd = new QFont ( "Andald Mono", fontlcdPointSize, FALSE );
+	fontlcdMetrics = new QFontMetrics ( *fontlcd );
 
 	//printf( "Font %d %d\n", font1Metrics->ascent(), font1Metrics->descent());
 
 	// Remediate font pathology
-	for ( int i = font1PointSize; font1Metrics->ascent() > 11; i-- ) {
-		printf( "Adjusting font... Ascent %d\n", font1Metrics->ascent() );
-		font1->setPointSize( i );
+	for ( int i = font1PointSize; font1Metrics->ascent() > 11; i-- )
+	{
+                //printf ( "Adjusting font... Ascent %d\n", font1Metrics->ascent() );
+		font1->setPointSize ( i );
 		delete font1Metrics;
-		font1Metrics = new QFontMetrics( *font1 );
+		font1Metrics = new QFontMetrics ( *font1 );
 	}
+	
+	/*for ( int i = fontlcdPointSize; fontlcdMetrics->ascent() > 18; i-- )
+	{
+                if(verbose) printf ( "Adjusting font... Ascent %d\n", fontlcdMetrics->ascent() );
+		fontlcd->setPointSize ( i );
+		delete fontlcdMetrics;
+		fontlcdMetrics = new QFontMetrics ( *fontlcd );
+	}*/
+
+	font2PointSize = 16;
+	font2 = new QFont( "Andale Mono", font2PointSize, FALSE);
+    font2Metrics = new QFontMetrics( *font2 );
+	QColor borderColor ( 255, 200, 55 );
+
+	// -----------------------------------------------------------------------
+	// Spectrogram
+
+	spectrogramFrame = new QFrame ( this );
+
+	spectrogram = new Spectrogram ( spectrogramFrame );
+	connect ( spectrogram, SIGNAL ( tune1 ( int ) ),
+	          this, SLOT ( spectrogramClicked ( int ) ) );
+        //This seems to occasionally cause a seg fault (just above).  Rob 10/3/10
+	connect ( spectrogram, SIGNAL ( tune2 ( int ) ),
+	          this, SLOT ( tune ( int ) ) );
+	connect ( spectrogram, SIGNAL ( tune3 ( int ) ),
+	          this, SLOT ( tunewheel ( int ) ) );
+	connect ( spectrogram, SIGNAL ( movement ( int ) ),
+	          this, SLOT ( f_at_mousepointer ( int ) ) );
+
+	// -----------------------------------------------------------------------
+	// Pass Band Filter Scale
+	pbscale = new PassBandScale( spectrogramFrame );
+	connect ( pbscale, SIGNAL ( set_lower_pb ( int ) ),
+	          this, SLOT ( setLowerFilterScale ( int ) ) );
+	connect ( pbscale, SIGNAL ( set_upper_pb ( int ) ),
+	          this, SLOT ( setUpperFilterScale ( int ) ) );
+	connect ( pbscale, SIGNAL ( movement ( int ) ),
+	          this, SLOT ( displayNCO ( int ) ) );
+
+	// -----------------------------------------------------------------------
+	// Spectrum
+	spectrumFrame = new Spectrum( spectrogramFrame );
+	connect ( spectrumFrame, SIGNAL ( movement ( int ) ),
+	          this, SLOT ( f_at_mousepointer ( int ) ) );
+	connect ( spectrumFrame, SIGNAL ( tune ( int ) ),
+	          this, SLOT ( spectrogramClicked ( int ) ) );
+	connect ( spectrumFrame, SIGNAL ( tune2 ( int ) ),
+	          this, SLOT ( tune ( int ) ) );
 
-    QFont font2( "Bitstream Vera Sans", 10, FALSE);
-    QFontMetrics fm2( font2 );
-
-    QColor borderColor( 255, 200, 55 );
-    //QColor borderColor( 200, 200, 100 );
-
-    // -----------------------------------------------------------------------
-    // Spectrogram
-    
-    spectrogramFrame = new QFrame( this );
-    spectrogramFrame->setFrameStyle( QFrame::StyledPanel | QFrame::Plain );
-    spectrogramFrame->setPaletteForegroundColor( borderColor );
-    
-    spectrogram = new Spectrogram( spectrogramFrame );
-    spectrogram->setPaletteBackgroundColor( QColor( 20, 20, 50 ) );
-    connect( spectrogram, SIGNAL(tune1(int)), 
-			 this, SLOT(spectrogramClicked(int)) );
-    connect( spectrogram, SIGNAL(tune2(int)), 
-			 this, SLOT(tune(int)) );
-    connect( spectrogram, SIGNAL(plot(int)), 
-			 this, SLOT(plotSpectrum(int)) );
-    
-    // -----------------------------------------------------------------------
-    // Pass Band Filter Scale
-    pbscale = new PassBandScale( spectrogramFrame, 
-								 "pbscale", Qt::WResizeNoErase );
-    pbscale->setPaletteBackgroundColor( QColor( 100, 0, 0 ) );
-    connect( pbscale, SIGNAL(set_lower_pb(int)), 
-			 this, SLOT(setLowerFilterScale(int)) );
-    connect( pbscale, SIGNAL(set_upper_pb(int)), 
-			 this, SLOT(setUpperFilterScale(int)) );
-    connect( pbscale, SIGNAL(movement(int)), 
-			 this, SLOT(displayNCO(int)) );
-
-    // -----------------------------------------------------------------------
-    // Spectrum
-    spectrumFrame = new Spectrum( spectrogramFrame, "SpectrumFrame", 
-								  Qt::WResizeNoErase );
-    spectrumFrame->setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-    connect( spectrumFrame, SIGNAL(movement(int)), 
-			 this, SLOT(f_at_mousepointer(int)) );
-    connect( spectrumFrame, SIGNAL(tune(int)), 
-			 this, SLOT(spectrogramClicked(int)) );
-
-    // -----------------------------------------------------------------------
-    // Control Frame
+	// -----------------------------------------------------------------------
+	// Control Frame
 
 	// Top
-    ctlFrame = new QFrame( this );
-    ctlFrame->setFrameStyle( QFrame::StyledPanel | QFrame::Plain );
-    ctlFrame->setPaletteForegroundColor( borderColor );
-    ctlFrame->setBackgroundColor( QColor( 0, 15, 150 ) );
-
-	// Top Filler
-    QFrame *ctlFrame1 = new QFrame( ctlFrame );
-    ctlFrame1->setPaletteForegroundColor( QColor( 255, 255, 255 ) );
-    ctlFrame1->setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-           
-	// Bottom
-    ctlFrame2 = new QFrame( this );
-    ctlFrame2->setFrameStyle( QFrame::StyledPanel | QFrame::Plain );
-    ctlFrame2->setPaletteForegroundColor( borderColor );
-    ctlFrame2->setPaletteBackgroundColor( QColor( 255, 200, 0 ) );
+	ctlFrame = new QFrame ( this, Qt::Widget );
+	ctlFrame->setFrameStyle ( QFrame::StyledPanel | QFrame::Plain );
+    ctlFrame->setPalette(QColor(0, 255, 0) );
+    ctlFrame->setAutoFillBackground(true);
 
-    // -----------------------------------------------------------------------
-    // Configuration Frame
-    
-    cfgFrame = new QFrame();
-	cfgFrame->setGeometry( 50, 50, 360, 300 );
-	cfgFrame->setMinimumWidth( 360 );
-	cfgFrame->setMaximumWidth( 360 );
-	cfgFrame->setMinimumHeight( 300 );
-	cfgFrame->setMaximumHeight( 300 );
-	cfgFrame->setCaption( "SDR-Shell : Config" );
-
-    QFrame *cfgFrame1 = new QFrame();
-    QFrame *cfgFrame2 = new QFrame();
-    QFrame *cfgFrame3 = new QFrame();
-    QFrame *cfgFrame4 = new QFrame();
-    QFrame *cfgFrame5 = new QFrame();
-
-	QTabWidget *configTab = new QTabWidget( cfgFrame );
-	configTab->setFont( *font1 );
-	configTab->addTab( cfgFrame1, "General" );
-	configTab->addTab( cfgFrame2, "IQ" );
-	configTab->addTab( cfgFrame3, "Spectrum" );
-	configTab->addTab( cfgFrame4, "Help" );
-	configTab->addTab( cfgFrame5, "About" );
-	configTab->setGeometry( 2, 2, 
-							cfgFrame->width() - 4, 
-							cfgFrame->height() - 2 );
-
-	// Staion Callsign
-	QGroupBox *cfgCallBox = new QGroupBox( cfgFrame1 );
-	cfgCallBox->setTitle( "Station Callsign" );
-	cfgCallBox->setGeometry( 5, 5, 340, 45 );
-
-	cfgCallInput = new QLineEdit( cfgCallBox );
-	cfgCallInput->setGeometry( 10, 18, 120, 20 );
-	cfgCallInput->setText( stationCallsign );
-	
-	QPushButton *updateCallButton = new QPushButton( cfgCallBox );
-	updateCallButton->setText( "Update" );
-	updateCallButton->setGeometry( 140, 18, 70, 20 );
-	connect( updateCallButton, SIGNAL(pressed()),
-			 this, SLOT(updateCallsign()) );
+	// Bottom
+	ctlFrame2 = new QFrame ( this, Qt::Widget );
+	ctlFrame2->setFrameStyle ( QFrame::StyledPanel | QFrame::Plain );
+    //ctlFrame2->setPalette(QPalette(QColor(0, 255, 0)));
+    ctlFrame2->setPalette(QPalette(QColor(0, 0, 0)));
+    ctlFrame2->setAutoFillBackground(true);
+
+	// -----------------------------------------------------------------------
+	// Configuration Frame
+
+	cfgFrame = new QFrame();
+	cfgFrame->setGeometry ( 50, 50, 380, 400 );
+	cfgFrame->setMinimumWidth ( 380 );
+	cfgFrame->setMaximumWidth ( 380 );
+	cfgFrame->setMinimumHeight ( 500 );
+	cfgFrame->setMaximumHeight ( 500 );
+    cfgFrame->setWindowTitle("SDR-Shell : Config ");
+
+	QFrame *cfgFrame1 = new QFrame( cfgFrame );
+	QFrame *cfgFrame2 = new QFrame( cfgFrame );
+	QFrame *cfgFrame3 = new QFrame( cfgFrame );
+	QFrame *cfgFrame6 = new QFrame( cfgFrame );
+	QFrame *cfgFrame7 = new QFrame( cfgFrame );
+	QFrame *cfgFrame4 = new QFrame( cfgFrame );
+	QFrame *cfgFrame5 = new QFrame( cfgFrame );
+
+	QTabWidget *configTab = new QTabWidget ( cfgFrame );
+	configTab->setFont ( *font1 );
+	configTab->addTab ( cfgFrame1, "General" );
+	configTab->addTab ( cfgFrame2, "IQ" );
+	configTab->addTab ( cfgFrame3, "Spectrum" );
+	configTab->addTab ( cfgFrame6, "IF" );
+	configTab->addTab ( cfgFrame7, "TX" );
+	configTab->addTab ( cfgFrame4, "Help" );
+	configTab->addTab ( cfgFrame5, "About" );
+	configTab->setGeometry ( 2, 2,
+	                         cfgFrame->width() - 4,
+	                         cfgFrame->height() - 2 );
+
+	// Station Callsign
+	QGroupBox *cfgCallBox = new QGroupBox ( cfgFrame1 );
+	cfgCallBox->setTitle ( "Station Callsign" );
+	cfgCallBox->setGeometry( 5, 5, 330, 45 );
+
+	cfgCallInput = new QLineEdit ( cfgCallBox );
+	cfgCallInput->setGeometry ( 10, 18, 120, 20 );
+	cfgCallInput->setText ( stationCallsign );
+
+	QPushButton *updateCallButton = new QPushButton ( cfgCallBox );
+	updateCallButton->setText ( "Update" );
+	updateCallButton->setGeometry ( 140, 18, 70, 20 );
+	connect ( updateCallButton, SIGNAL ( pressed() ),
+	          this, SLOT ( updateCallsign() ) );
 
 	// Local Oscilator Frequency in Hertz
-	QGroupBox *cfgLOFreqBox = new QGroupBox( cfgFrame1 );
-	cfgLOFreqBox->setTitle( "LO Frequency (Hz)" );
-	cfgLOFreqBox->setGeometry( 5, 53, 340, 45 );
-
-	cfgLOFreqInput = new QLineEdit( cfgLOFreqBox );
-	cfgLOFreqInput->setGeometry( 10, 18, 120, 20 );
-	cfgLOFreqInput->setText( rx_f_string );
-
-	QPushButton *updateLOFreqButton = new QPushButton( cfgLOFreqBox );
-	updateLOFreqButton->setText( "Update" );
-	updateLOFreqButton->setGeometry( 140, 18, 70, 20 );
-	connect( updateLOFreqButton, SIGNAL(pressed()),
-			 this, SLOT(updateLOFreq()) );
+	QGroupBox *cfgLOFreqBox = new QGroupBox ( cfgFrame1 );
+	cfgLOFreqBox->setTitle ( "LO Frequency (Hz)" );
+	cfgLOFreqBox->setGeometry( 5, 53, 330, 90 );
+
+	cfgLOFreqInput = new QLineEdit ( cfgLOFreqBox );
+	cfgLOFreqInput->setGeometry( 10, 37, 120, 20 );
+	cfgLOFreqInput->setText ( rx_f_string );
+    cfgLOFreqInput->setEnabled(true);
+
+	updateLOFreqButton = new QPushButton( cfgLOFreqBox );
+	updateLOFreqButton->setText ( "Update" );
+	updateLOFreqButton->setGeometry( 140, 37, 70, 20 );
+    updateLOFreqButton->setEnabled(true);
+	connect ( updateLOFreqButton, SIGNAL ( pressed() ),
+	          this, SLOT ( updateLOFreq() ) );
+
+	// Use USBSoftrock
+	QGroupBox *cfgUSBBox = new QGroupBox ( cfgFrame1 );
+	cfgUSBBox->setTitle ( "USBSoftrock Control" );
+    cfgUSBBox->setGeometry ( 5, 143, 330, 90 );
+
+	QRadioButton *cfgUseUSBsoftrock = new QRadioButton ( cfgUSBBox );
+	cfgUseUSBsoftrock->setText ( "Use usbsoftrock via UDP" );
+	cfgUseUSBsoftrock->setGeometry ( 25, 18, 200, 20 );
+    cfgUseUSBsoftrock->setAutoExclusive(false);
+	connect ( cfgUseUSBsoftrock, SIGNAL ( toggled ( bool ) ),
+	          this, SLOT ( updateUseUSBsoftrock ( bool ) ) );
+	if( !rock_bound)
+		cfgUseUSBsoftrock->setChecked (true);
+
+	// USBSoftrock 5/4 tuning for dual-conversion
+	cfgDualConversion = new QRadioButton ( cfgUSBBox );
+	cfgDualConversion->setText ( "5/4 Tuning" );
+	cfgDualConversion->setGeometry ( 25, 36, 200, 20 );
+    cfgDualConversion->setAutoExclusive(false);
+	connect ( cfgDualConversion, SIGNAL ( toggled ( bool ) ),
+	          this, SLOT ( updateDualConversion ( bool ) ) );
+	if( dualConversion)
+		cfgDualConversion->setChecked (true);
+
+	// USB-tune offset
+	cfgTuneOffsetInput = new QLineEdit ( cfgUSBBox );
+	cfgTuneOffsetInput->setGeometry( 25, 60, 120, 20 );
+	TuneOffset_string.sprintf("%d", tuneCenter);
+	cfgTuneOffsetInput->setText ( TuneOffset_string );
+    cfgTuneOffsetInput->setEnabled(true);
+
+	updateTuneOffsetButton = new QPushButton( cfgUSBBox );
+	updateTuneOffsetButton->setText ( "Update" );
+	updateTuneOffsetButton->setGeometry( 150, 60, 70, 20 );
+    updateTuneOffsetButton->setEnabled(true);
+	connect ( updateTuneOffsetButton, SIGNAL ( pressed() ),
+	          this, SLOT ( updateTuneOffset() ) );
 
 	// Spectrum and S-Meter calibration
-	QGroupBox *calibrationBox = new QGroupBox( cfgFrame1 );
-	calibrationBox->setTitle( "Calibration" );
-	calibrationBox->setGeometry( 5, 101, 340, 45 );
-
-	QLabel *specCalLabel = new QLabel( calibrationBox );
-	specCalLabel->setText( "Spectrum: " );
-	specCalLabel->setGeometry( 10, 18, 70, 20 );
-	specCalLabel->setAlignment( Qt::AlignRight | Qt::AlignVCenter );
-
-	specCalSpinBox = new QSpinBox( calibrationBox );
-	specCalSpinBox->setGeometry( 80, 18, 70, 20 );
-	specCalSpinBox->setMinValue( 0 );
-	specCalSpinBox->setMaxValue( 100 );
-	specCalSpinBox->setValue( (int)specCal );
-	connect( specCalSpinBox, SIGNAL(valueChanged(int)),
-			 this, SLOT(calibrateSpec(int)) );
-
-	QLabel *metrCalLabel = new QLabel( calibrationBox );
-	metrCalLabel->setText( "S-Meter: " );
-	metrCalLabel->setGeometry( 175, 18, 70, 20 );
-	metrCalLabel->setAlignment( Qt::AlignRight | Qt::AlignVCenter );
-
-	metrCalSpinBox = new QSpinBox( calibrationBox );
-	metrCalSpinBox->setGeometry( 245, 18, 70, 20 );
-	metrCalSpinBox->setMinValue( 0 );
-	metrCalSpinBox->setMaxValue( 100 );
-	metrCalSpinBox->setValue( (int)metrCal );
-	connect( metrCalSpinBox, SIGNAL(valueChanged(int)),
-			 this, SLOT(calibrateMetr(int)) );
-
+	QGroupBox *calibrationBox = new QGroupBox ( cfgFrame1 );
+	calibrationBox->setTitle ( "Calibration" );
+    //calibrationBox->setGeometry( 5, 209, 330, 45 );
+    calibrationBox->setGeometry( 5, 250, 330, 45 );
+	///calibrationBox->setFrameStyle ( QFrame::StyledPanel | QFrame::Plain );
+
+	QLabel *specCalLabel = new QLabel ( calibrationBox );
+	specCalLabel->setText ( "Spectrum: " );
+	specCalLabel->setGeometry ( 10, 18, 70, 20 );
+	specCalLabel->setAlignment ( Qt::AlignRight | Qt::AlignVCenter );
+
+	specCalSpinBox = new QSpinBox ( calibrationBox );
+	specCalSpinBox->setGeometry ( 80, 18, 70, 20 );
+	specCalSpinBox->setMinimum( 0 );
+	specCalSpinBox->setMaximum( 100 );
+	specCalSpinBox->setValue ( ( int ) specCal );
+	connect ( specCalSpinBox, SIGNAL ( valueChanged ( int ) ),
+	          this, SLOT ( calibrateSpec ( int ) ) );
+
+	QLabel *metrCalLabel = new QLabel ( calibrationBox );
+	metrCalLabel->setText ( "S-Meter: " );
+	metrCalLabel->setGeometry ( 175, 18, 70, 20 );
+	metrCalLabel->setAlignment ( Qt::AlignRight | Qt::AlignVCenter );
+
+	metrCalSpinBox = new QSpinBox ( calibrationBox );
+	metrCalSpinBox->setGeometry ( 245, 18, 70, 20 );
+	metrCalSpinBox->setMinimum( 0 );
+	metrCalSpinBox->setMaximum( 100 );
+	metrCalSpinBox->setValue ( ( int ) metrCal );
+	connect ( metrCalSpinBox, SIGNAL ( valueChanged ( int ) ),
+	          this, SLOT ( calibrateMetr ( int ) ) );
 	// IQ Phase Calibration
-	QGroupBox *cfgIQCal = new QGroupBox( cfgFrame2 );
-	cfgIQCal->setTitle( "IQ Calibration" );
-	cfgIQCal->setGeometry( 5, 5, 340, 45 );
-
-	QLabel *cfgIQPhaseLabel = new QLabel( cfgIQCal );
-	cfgIQPhaseLabel->setText( "IQ Phase: " );
-	cfgIQPhaseLabel->setGeometry( 10, 18, 70, 20 );
-	cfgIQPhaseLabel->setAlignment( Qt::AlignRight | Qt::AlignVCenter );
-
-	cfgIQPhaseInput = new QSpinBox( cfgIQCal );
-	cfgIQPhaseInput->setGeometry( 80, 18, 70, 20 );
-	cfgIQPhaseInput->setMinValue( -1000 );
-	cfgIQPhaseInput->setMaxValue( 1000 );
-	cfgIQPhaseInput->setValue( iqPhase );
-	connect( cfgIQPhaseInput, SIGNAL(valueChanged(int)),
-			 this, SLOT(updateIQPhase(int)) );
+	QGroupBox *cfgIQCal = new QGroupBox ( cfgFrame2 );
+	cfgIQCal->setTitle ( "RX IQ Calibration" );
+	cfgIQCal->setGeometry( 5, 5, 330, 45 );
+
+#if 1
+	QLabel *cfgIQPhaseLabel = new QLabel ( cfgIQCal );
+	cfgIQPhaseLabel->setText ( "IQ Phase: " );
+	cfgIQPhaseLabel->setGeometry ( 10, 18, 70, 20 );
+	cfgIQPhaseLabel->setAlignment ( Qt::AlignRight | Qt::AlignVCenter );
+
+	cfgIQPhaseInput = new QSpinBox ( cfgIQCal );
+	cfgIQPhaseInput->setGeometry ( 80, 18, 70, 20 );
+	cfgIQPhaseInput->setMinimum( -1000 );
+	cfgIQPhaseInput->setMaximum( 1000 );
+	cfgIQPhaseInput->setValue ( iqPhase );
+	connect ( cfgIQPhaseInput, SIGNAL ( valueChanged ( int ) ),
+	          this, SLOT ( updateIQPhase ( int ) ) );
+#endif
+
+	// IQ Gain Calibration
+	QLabel *cfgIQGainLabel = new QLabel ( cfgIQCal );
+	cfgIQGainLabel->setText ( "IQ Gain: " );
+	cfgIQGainLabel->setGeometry ( 175, 18, 70, 20 );
+	cfgIQGainLabel->setAlignment ( Qt::AlignRight | Qt::AlignVCenter );
+
+	cfgIQGainInput = new QSpinBox ( cfgIQCal );
+	cfgIQGainInput->setGeometry ( 245, 18, 70, 20 );
+	cfgIQGainInput->setMinimum( -1000 );
+	cfgIQGainInput->setMaximum( 1000 );
+	cfgIQGainInput->setValue ( iqGain );
+	connect ( cfgIQGainInput, SIGNAL ( valueChanged ( int ) ),
+	          this, SLOT ( updateIQGain ( int ) ) );
+
+	// Transmit IQgain, IQphase
+	QGroupBox *cfgTxIQCal = new QGroupBox ( cfgFrame2 );
+	cfgTxIQCal->setTitle ( "TX IQ Calibration" );
+	cfgTxIQCal->setGeometry ( 5, 50, 340, 45 );
+
+#if 1
+	QLabel *cfgTxIQPhaseLabel = new QLabel ( cfgTxIQCal );
+	cfgTxIQPhaseLabel->setText ( "IQ Phase: " );
+	cfgTxIQPhaseLabel->setGeometry ( 10, 18, 70, 20 );
+	cfgTxIQPhaseLabel->setAlignment ( Qt::AlignRight | Qt::AlignVCenter );
+
+	cfgTxIQPhaseInput = new QSpinBox ( cfgTxIQCal );
+	cfgTxIQPhaseInput->setGeometry ( 80, 18, 70, 20 );
+	cfgTxIQPhaseInput->setMinimum ( -1000 );
+	cfgTxIQPhaseInput->setMaximum ( 1000 );
+	cfgTxIQPhaseInput->setValue ( txIQPhase );
+	connect ( cfgTxIQPhaseInput, SIGNAL ( valueChanged ( int ) ),
+	          this, SLOT ( updateTxIQPhase ( int ) ) );
+#endif
 
 	// IQ Gain Calibration
-	QLabel *cfgIQGainLabel = new QLabel( cfgIQCal );
-	cfgIQGainLabel->setText( "IQ Gain: " );
-	cfgIQGainLabel->setGeometry( 175, 18, 70, 20 );
-	cfgIQGainLabel->setAlignment( Qt::AlignRight | Qt::AlignVCenter );
-
-	cfgIQGainInput = new QSpinBox( cfgIQCal );
-	cfgIQGainInput->setGeometry( 245, 18, 70, 20 );
-	cfgIQGainInput->setMinValue( -1000 );
-	cfgIQGainInput->setMaxValue( 1000 );
-	cfgIQGainInput->setValue( iqGain );
-	connect( cfgIQGainInput, SIGNAL(valueChanged(int)),
-			 this, SLOT(updateIQGain(int)) );
+	QLabel *cfgTxIQGainLabel = new QLabel ( cfgTxIQCal );
+	cfgTxIQGainLabel->setText ( "IQ Gain: " );
+	cfgTxIQGainLabel->setGeometry ( 175, 18, 70, 20 );
+	cfgTxIQGainLabel->setAlignment ( Qt::AlignRight | Qt::AlignVCenter );
+
+	cfgTxIQGainInput = new QSpinBox ( cfgTxIQCal );
+	cfgTxIQGainInput->setGeometry ( 245, 18, 70, 20 );
+	cfgTxIQGainInput->setMinimum ( -1000 );
+	cfgTxIQGainInput->setMaximum ( 1000 );
+	cfgTxIQGainInput->setValue ( txIQGain );
+	connect ( cfgTxIQGainInput, SIGNAL ( valueChanged ( int ) ),
+	          this, SLOT ( updateTxIQGain ( int ) ) );
 
 	// Polyphase FFT
-	QButtonGroup *cfgPolyFFTGroup = new QButtonGroup( cfgFrame3 );
-	cfgPolyFFTGroup->setTitle( "Polyphase FFT" );
-	cfgPolyFFTGroup->setGeometry( 5, 5, 340, 45 );
-	cfgPolyFFTGroup->setRadioButtonExclusive( true );
-	connect( cfgPolyFFTGroup, SIGNAL(clicked(int)),
-			 this, SLOT(setPolyFFT(int)) );
-
-	QRadioButton *polyFFT_off_button = new QRadioButton( cfgPolyFFTGroup );
-	polyFFT_off_button->setText( "Off" );
-	polyFFT_off_button->setGeometry( 10, 18, 70, 20 );
-
-	QRadioButton *polyFFT_on_button = new QRadioButton( cfgPolyFFTGroup );
-	polyFFT_on_button->setText( "On" );
-	polyFFT_on_button->setGeometry( 160, 18, 70, 19 );
+	QGroupBox *cfgPolyFFTGroup = new QGroupBox( cfgFrame3 );
+    cfgPolyFFTGroup->setTitle("Polyphase FFT");	
+	cfgPolyFFTGroup->setGeometry( 5, 5, 330, 45 );
+
+    polyFFT_button = new QRadioButton( tr("Use Polyphase FFT"),cfgPolyFFTGroup);
+    polyFFT_button->setGeometry ( 10, 18, 200, 20 );
+    connect( polyFFT_button, SIGNAL(clicked()),
+			 this, SLOT ( setPolyFFT () ) );
+	if (polyphaseFFT)
+    	polyFFT_button->setChecked(true);
 
-	cfgPolyFFTGroup->setButton( polyphaseFFT );	
-	
 	// Spectrum Type
-	QButtonGroup *cfgSpecTypeGroup = new QButtonGroup( cfgFrame3 );
-	cfgSpecTypeGroup->setTitle( "Spectrum Type" );
-	cfgSpecTypeGroup->setGeometry( 5, 53, 340, 45 );
-	cfgSpecTypeGroup->setRadioButtonExclusive( true );
-	connect( cfgSpecTypeGroup, SIGNAL(clicked(int)),
-			 this, SLOT(setSpectrumType(int)) );
-
-	QRadioButton *preFilter_button = new QRadioButton( cfgSpecTypeGroup );
-	preFilter_button->setText( "Pre Filter" );
-	preFilter_button->setGeometry( 10, 18, 100, 20 );
-
-	QRadioButton *postFilter_button = new QRadioButton( cfgSpecTypeGroup );
-	postFilter_button->setText( "Post Filter" );
-	postFilter_button->setGeometry( 160, 18, 100, 20 );
+	QGroupBox *cfgSpecTypeGroup = new QGroupBox( cfgFrame3 );
+	cfgSpecTypeGroup->setTitle ( "Spectrum Type" );
+	cfgSpecTypeGroup->setGeometry( 5, 53, 330, 45 );
+
+	preFilter_button = new QRadioButton( tr("Pre Filter"), cfgSpecTypeGroup );
+	preFilter_button->setGeometry ( 10, 18, 100, 20 );
+	connect( preFilter_button, SIGNAL(clicked()),
+			 this, SLOT(setSpectrumType()) );
+	if (spectrumType == 1)
+        preFilter_button->setChecked(true);	
+
+	postFilter_button = new QRadioButton( tr("Post Filter"), cfgSpecTypeGroup );
+	postFilter_button->setGeometry ( 160, 18, 100, 20 );
+	connect( postFilter_button, SIGNAL(clicked()),
+			 this, SLOT(setSpectrumType()) );
+	if (spectrumType == 2)
+        postFilter_button->setChecked(true);	
 
-	cfgSpecTypeGroup->setButton( spectrumType );	
-	
-	// FFT Windowing Function
-	QButtonGroup *cfgFFTWindowGroup = new QButtonGroup( cfgFrame3 );
+
+	// FFT Windowing Functionplot
+	QGroupBox *cfgFFTWindowGroup = new QGroupBox( cfgFrame3 );
 	cfgFFTWindowGroup->setTitle( "FFT Windowing Function" );
-	cfgFFTWindowGroup->setGeometry( 5, 101, 340, 162 );
-	cfgFFTWindowGroup->setRadioButtonExclusive( true );
-	connect( cfgFFTWindowGroup, SIGNAL(clicked(int)),
-			 this, SLOT(setFFTWindow(int)) );
+	cfgFFTWindowGroup->setGeometry( 5, 101, 330, 162 );
 
-	QRadioButton *fftWindow_0 = new QRadioButton( cfgFFTWindowGroup );
-	fftWindow_0->setText( "Rectangular" );
+	fftWindow_0 = new QRadioButton( tr("Rectangular"), cfgFFTWindowGroup );
 	fftWindow_0->setGeometry( 10, 18, 140, 19 );
-
-	QRadioButton *fftWindow_1 = new QRadioButton( cfgFFTWindowGroup );
-	fftWindow_1->setText( "Hanning" );
+	connect( fftWindow_0, SIGNAL(clicked()),
+			 this, SLOT(setFFTWindow()) );
+	if (fftWindow == 0)
+        fftWindow_0->setChecked(true);	
+			 
+	fftWindow_1 = new QRadioButton( tr("Hanning"), cfgFFTWindowGroup );
 	fftWindow_1->setGeometry( 10, 38, 140, 19 );
+	connect( fftWindow_1, SIGNAL(clicked()),
+			 this, SLOT(setFFTWindow()) );	
+	if (fftWindow == 1)
+        fftWindow_1->setChecked(true);	
 
-	QRadioButton *fftWindow_2 = new QRadioButton( cfgFFTWindowGroup );
-	fftWindow_2->setText( "Welch" );
+	fftWindow_2 = new QRadioButton( tr("Welch"), cfgFFTWindowGroup );
 	fftWindow_2->setGeometry( 10, 58, 140, 19 );
+	connect( fftWindow_2, SIGNAL(clicked()),
+			 this, SLOT(setFFTWindow()) );	
+	if (fftWindow == 2)
+        fftWindow_2->setChecked(true);	
 
-	QRadioButton *fftWindow_3 = new QRadioButton( cfgFFTWindowGroup );
-	fftWindow_3->setText( "Parzen" );
+	fftWindow_3 = new QRadioButton( tr("Parzen"), cfgFFTWindowGroup );
 	fftWindow_3->setGeometry( 10, 78, 140, 19 );
+	connect( fftWindow_3, SIGNAL(clicked()),
+			 this, SLOT(setFFTWindow()) );
+	if (fftWindow == 3)
+        fftWindow_3->setChecked(true);	
 
-	QRadioButton *fftWindow_4 = new QRadioButton( cfgFFTWindowGroup );
-	fftWindow_4->setText( "Bartlett" );
+	fftWindow_4 = new QRadioButton( tr("Bartlett"), cfgFFTWindowGroup );
 	fftWindow_4->setGeometry( 10, 98, 140, 19 );
+	connect( fftWindow_4, SIGNAL(clicked()),
+			 this, SLOT(setFFTWindow()) );
+	if (fftWindow == 4)
+        fftWindow_4->setChecked(true);	
 
-	QRadioButton *fftWindow_5 = new QRadioButton( cfgFFTWindowGroup );
-	fftWindow_5->setText( "Hamming" );
+	fftWindow_5 = new QRadioButton( tr("Hamming"), cfgFFTWindowGroup );
 	fftWindow_5->setGeometry( 10, 118, 140, 19 );
+	connect( fftWindow_5, SIGNAL(clicked()),
+			 this, SLOT(setFFTWindow()) );
+	if (fftWindow == 5)
+        fftWindow_5->setChecked(true);	
 
-	QRadioButton *fftWindow_6 = new QRadioButton( cfgFFTWindowGroup );
-	fftWindow_6->setText( "Blackman 2" );
+	fftWindow_6 = new QRadioButton( tr("Blackman 2"), cfgFFTWindowGroup );
 	fftWindow_6->setGeometry( 10, 138, 140, 19 );
+	connect( fftWindow_6, SIGNAL(clicked()),
+			 this, SLOT(setFFTWindow()) );
+	if (fftWindow == 6)
+        fftWindow_6->setChecked(true);	
 
-	QRadioButton *fftWindow_7 = new QRadioButton( cfgFFTWindowGroup );
-	fftWindow_7->setText( "Blackman 3" );
+	fftWindow_7 = new QRadioButton( tr("Blackman 3"), cfgFFTWindowGroup );
 	fftWindow_7->setGeometry( 160, 18, 140, 19 );
+	connect( fftWindow_7, SIGNAL(clicked()),
+			 this, SLOT(setFFTWindow()) );
+	if (fftWindow == 7)
+        fftWindow_7->setChecked(true);	
 
-	QRadioButton *fftWindow_8 = new QRadioButton( cfgFFTWindowGroup );
-	fftWindow_8->setText( "Blackman 4" );
+	fftWindow_8 = new QRadioButton( tr("Blackman 4"), cfgFFTWindowGroup );
 	fftWindow_8->setGeometry( 160, 38, 140, 19 );
+	connect( fftWindow_8, SIGNAL(clicked()),
+			 this, SLOT(setFFTWindow()) );
+	if (fftWindow == 8)
+        fftWindow_8->setChecked(true);	
 
-	QRadioButton *fftWindow_9 = new QRadioButton( cfgFFTWindowGroup );
-	fftWindow_9->setText( "Exponential" );
+	fftWindow_9 = new QRadioButton( tr("Exponential"), cfgFFTWindowGroup );
 	fftWindow_9->setGeometry( 160, 58, 140, 19 );
+	connect( fftWindow_9, SIGNAL(clicked()),
+			 this, SLOT(setFFTWindow()) );
+	if (fftWindow == 9)
+        fftWindow_9->setChecked(true);	
 
-	QRadioButton *fftWindow_10 = new QRadioButton( cfgFFTWindowGroup );
-	fftWindow_10->setText( "Riemann" );
+	fftWindow_10 = new QRadioButton( tr("Riemann"), cfgFFTWindowGroup );
 	fftWindow_10->setGeometry( 160, 78, 140, 19 );
+	connect( fftWindow_10, SIGNAL(clicked()),
+			 this, SLOT(setFFTWindow()) );
+	if (fftWindow == 10)
+        fftWindow_10->setChecked(true);	
 
-	QRadioButton *fftWindow_11 = new QRadioButton( cfgFFTWindowGroup );
-	fftWindow_11->setText( "Blackman-Harris" );
+	fftWindow_11 = new QRadioButton( tr("Blackman-Harris"), cfgFFTWindowGroup );
 	fftWindow_11->setGeometry( 160, 98, 140, 19 );
+	connect( fftWindow_11, SIGNAL(clicked()),
+			 this, SLOT(setFFTWindow()) );
+	if (fftWindow == 11)
+        fftWindow_11->setChecked(true);	
 
-	QRadioButton *fftWindow_12 = new QRadioButton( cfgFFTWindowGroup );
-	fftWindow_12->setText( "Nuttall" );
+	fftWindow_12 = new QRadioButton( tr("Nuttall"), cfgFFTWindowGroup );
 	fftWindow_12->setGeometry( 160, 118, 140, 19 );
+	connect( fftWindow_12, SIGNAL(clicked()),
+			 this, SLOT(setFFTWindow()) );
+	if (fftWindow == 12)
+        fftWindow_12->setChecked(true);	
+
+	// Spectrum display 
+	QGroupBox *cfgSpecDisplay = new QGroupBox( cfgFrame3 );
+    cfgSpecDisplay->setTitle("Spectrum Display");	
+	cfgSpecDisplay->setGeometry( 5, 265, 330, 90 );
+
+	// SpecLineFill
+    specLineFillButton = new QRadioButton( tr("Fill Spectrum Line"), cfgSpecDisplay);
+    specLineFillButton->setGeometry ( 10, 18, 200, 20 );
+    connect( specLineFillButton, SIGNAL(clicked()),
+			 this, SLOT ( setLineFill () ) );
+
+	// Spectrum Averaging
+	QLabel *cfgSpecAvgInputLabel = new QLabel ( cfgSpecDisplay );
+	cfgSpecAvgInputLabel->setText ( "Spectrum Averaging" );
+	cfgSpecAvgInputLabel->setGeometry ( 10, 40, 160, 20 );
+	cfgSpecAvgInputLabel->setAlignment ( Qt::AlignRight | Qt::AlignVCenter );
+	cfgSpecAvgInput = new QSpinBox ( cfgSpecDisplay );
+	cfgSpecAvgInput->setGeometry ( 180, 40, 70, 20 );
+	cfgSpecAvgInput->setMinimum ( 0 );
+        cfgSpecAvgInput->setMaximum ( 255 );
+	cfgSpecAvgInput->setValue ( specAveraging );
+	connect ( cfgSpecAvgInput, SIGNAL ( valueChanged ( int ) ),
+	          this, SLOT ( updateSpecAvg ( int ) ) );
+
+	// filterLine
+	// Spectrum Scale
+	QLabel *cfgSpecScaleLabel = new QLabel ( cfgSpecDisplay );
+	cfgSpecScaleLabel->setText ( "Spectrum Scale" );
+	cfgSpecScaleLabel->setGeometry ( 10, 60, 160, 20 );
+	cfgSpecScaleLabel->setAlignment ( Qt::AlignRight | Qt::AlignVCenter );
+	cfgSpecLowInput = new QSpinBox ( cfgSpecDisplay );
+	cfgSpecLowInput->setGeometry ( 180, 60, 70, 20 );
+	cfgSpecLowInput->setMinimum ( -140 );
+        cfgSpecLowInput->setMaximum ( 0 );
+	cfgSpecLowInput->setValue ( -140 );
+	connect ( cfgSpecLowInput, SIGNAL ( valueChanged ( int ) ),
+	          this, SLOT ( updateSpecLow ( int ) ) );
+	cfgSpecHighInput = new QSpinBox ( cfgSpecDisplay );
+	cfgSpecHighInput->setGeometry ( 250, 60, 70, 20 );
+	cfgSpecHighInput->setMinimum ( -139 );
+        cfgSpecHighInput->setMaximum ( 0 );
+	cfgSpecHighInput->setValue ( -40 );
+	connect ( cfgSpecHighInput, SIGNAL ( valueChanged ( int ) ),
+	          this, SLOT ( updateSpecHigh ( int ) ) );
+
+	// IF Settings
+	QGroupBox *cfgIfBox = new QGroupBox ( cfgFrame6 );
+	cfgIfBox->setTitle ( "IF Setup" );
+	cfgIfBox->setGeometry ( 5, 160, 340, 50 );
+
+	QRadioButton *cfgIFAligned = new QRadioButton ( cfgIfBox );
+	cfgIFAligned->setText ( "Use IF Mode" );
+	cfgIFAligned->setGeometry ( 5, 5, 340, 45 );
+    cfgDualConversion->setAutoExclusive(false);
+	connect ( cfgIFAligned, SIGNAL ( toggled ( bool ) ),
+	          this, SLOT ( setIF ( bool ) ) );
+	if (useIF)
+		cfgIFAligned->setChecked (true);
+
+	QGroupBox *cfgIFreqBox = new QGroupBox ( cfgFrame6 );
+	cfgIFreqBox->setTitle ( "IF Frequencies (Hz)" );
+	cfgIFreqBox->setGeometry ( 5, 353, 340, 110 );
+
+	cfgIFreqInput = new QLineEdit ( cfgIFreqBox );
+	cfgIFreqInput->setGeometry ( 10, 25, 120, 20 );
+	cfgIFreqInput->setText ( rx_if_string );
+
+	QPushButton *updateIFreqButton = new QPushButton ( cfgIFreqBox );
+	updateIFreqButton->setText ( "Update" );
+	updateIFreqButton->setGeometry ( 140, 25, 70, 20 );
+	connect ( updateIFreqButton, SIGNAL ( pressed() ),
+	          this, SLOT ( updateIFreq() ) );
+
+	QGroupBox *cfgSlopeTuneBox = new QGroupBox ( cfgFrame6 );
+	cfgSlopeTuneBox->setTitle ( "Slope Tuning Offsets (Hz)" );
+	cfgSlopeTuneBox->setGeometry ( 5, 195, 340, 150 );
+
+	QLabel *cfgSlopeLowOffsetLabel = new QLabel ( cfgSlopeTuneBox );
+	cfgSlopeLowOffsetLabel->setText ( "Low Offset" );
+	cfgSlopeLowOffsetLabel->setGeometry ( 10, 28, 120, 20 );
+	cfgSlopeLowOffsetLabel->setAlignment ( Qt::AlignRight | Qt::AlignVCenter );
+
+	cfgSlopeLowOffsetInput = new QSpinBox ( cfgSlopeTuneBox );
+	cfgSlopeLowOffsetInput->setGeometry ( 180, 28, 70, 20 );
+	cfgSlopeLowOffsetInput->setMinimum ( 0 );
+        cfgSlopeLowOffsetInput->setMaximum ( 9999 );
+	cfgSlopeLowOffsetInput->setValue ( slopeLowOffset );
+	connect ( cfgSlopeLowOffsetInput, SIGNAL ( valueChanged ( int ) ),
+	          this, SLOT ( updateSlopeLowOffset ( int ) ) );
+
+	QLabel *cfgSlopeHighOffsetLabel = new QLabel ( cfgSlopeTuneBox );
+	cfgSlopeHighOffsetLabel->setText ( "High Offset" );
+	cfgSlopeHighOffsetLabel->setGeometry ( 10, 58, 120, 20 );
+	cfgSlopeHighOffsetLabel->setAlignment ( Qt::AlignRight | Qt::AlignVCenter );
+
+	cfgSlopeHighOffsetInput = new QSpinBox ( cfgSlopeTuneBox );
+	cfgSlopeHighOffsetInput->setGeometry ( 180, 58, 70, 20 );
+	cfgSlopeHighOffsetInput->setMinimum ( 0 );
+        cfgSlopeHighOffsetInput->setMaximum ( 9999 );
+	cfgSlopeHighOffsetInput->setValue ( slopeHighOffset );
+	connect ( cfgSlopeHighOffsetInput, SIGNAL ( valueChanged ( int ) ),
+	          this, SLOT ( updateSlopeHighOffset ( int ) ) );
+	
+	QRadioButton *cfgUseSlopeTune = new QRadioButton ( cfgSlopeTuneBox );
+	cfgUseSlopeTune->setText ( "Poll Slope Tuning" );
+	cfgUseSlopeTune->setGeometry ( 40, 88, 200, 45 );
+	cfgUseSlopeTune->setChecked ( useSlopeTune );
+	connect ( cfgUseSlopeTune, SIGNAL ( toggled ( bool ) ),
+		  this, SLOT ( setSlopeTune ( bool ) ) );
+
+
+	QLabel *cfgUSBOffsetLabel = new QLabel ( cfgIFreqBox );
+	cfgUSBOffsetLabel->setText ( "USB Offset" );
+	cfgUSBOffsetLabel->setGeometry ( 10, 53, 70, 20 );
+	cfgUSBOffsetLabel->setAlignment ( Qt::AlignRight | Qt::AlignVCenter );
+
+	cfgUSBOffsetInput = new QSpinBox ( cfgIFreqBox );
+	cfgUSBOffsetInput->setGeometry ( 90, 53, 70, 20 );
+	cfgUSBOffsetInput->setMinimum ( 0 );
+	cfgUSBOffsetInput->setMaximum ( 9999 );
+	cfgUSBOffsetInput->setValue ( usbOffset );
+	connect ( cfgUSBOffsetInput, SIGNAL ( valueChanged ( int ) ),
+	          this, SLOT ( updateUSBOffset ( int ) ) );
+
+	QLabel *cfgLSBOffsetLabel = new QLabel ( cfgIFreqBox );
+	cfgLSBOffsetLabel->setText ( "LSB Offset" );
+	cfgLSBOffsetLabel->setGeometry ( 10, 83, 70, 20 );
+	cfgLSBOffsetLabel->setAlignment ( Qt::AlignRight | Qt::AlignVCenter );
+
+	cfgLSBOffsetInput = new QSpinBox ( cfgIFreqBox );
+	cfgLSBOffsetInput->setGeometry ( 90, 83, 70, 20 );
+	cfgLSBOffsetInput->setMinimum ( 0 );
+	cfgLSBOffsetInput->setMaximum ( 9999 );
+	cfgLSBOffsetInput->setValue ( lsbOffset );
+	connect ( cfgLSBOffsetInput, SIGNAL ( valueChanged ( int ) ),
+	          this, SLOT ( updateLSBOffset ( int ) ) );
+
+
+	//Hamlib Setup
+	QGroupBox *cfgHamlibBox = new QGroupBox ( cfgFrame6 );
+	cfgHamlibBox->setTitle ( "Hamlib Setup" );
+	cfgHamlibBox->setGeometry ( 5, 5, 340, 150 );
+
+	cfgHamlibRigInput = new QLineEdit ( cfgHamlibBox );
+	cfgHamlibRigInput->setGeometry ( 10, 18, 120, 20 );
+	cfgHamlibRigInput->setText ( rigString );
+
+	cfgRigLabel = new QLabel ( cfgHamlibBox );
+	cfgRigLabel->setGeometry ( 140, 18, 180, 20 );
+	cfgRigLabel->setText ( "Rig ID" );
+
+	cfgHamlibPortInput = new QLineEdit ( cfgHamlibBox );
+	cfgHamlibPortInput->setGeometry ( 10, 48, 120, 20 );
+	cfgHamlibPortInput->setText ( portString );
+
+	cfgPortLabel = new QLabel ( cfgHamlibBox );
+	cfgPortLabel->setGeometry ( 140, 48, 180, 20 );
+	cfgPortLabel->setText ( "Serial Port" );
+
+	cfgHamlibSpeedInput = new QLineEdit ( cfgHamlibBox );
+	cfgHamlibSpeedInput->setGeometry ( 10, 78, 120, 20 );
+	cfgHamlibSpeedInput->setText ( speedString );
+
+	cfgSpeedLabel = new QLabel ( cfgHamlibBox );
+	cfgSpeedLabel->setGeometry ( 140, 78, 180, 20 );
+	cfgSpeedLabel->setText ( "Baud Rate" );
+
+	QPushButton *updateHamlibButton = new QPushButton ( cfgHamlibBox );
+	updateHamlibButton->setText ( "Update Hamlib \n Parameters" );
+	updateHamlibButton->setGeometry ( 230, 28, 100, 50 );
+	connect ( updateHamlibButton, SIGNAL ( pressed() ),
+	          this, SLOT ( updateHamlib() ) );
+
+    QRadioButton *cfgUseHamlib = new QRadioButton ( cfgHamlibBox );
+	cfgUseHamlib->setText ( "Use Hamlib" );
+    cfgUseHamlib->setAutoExclusive(FALSE);
+	cfgUseHamlib->setGeometry ( 5, 100, 150, 45 );
+	connect ( cfgUseHamlib, SIGNAL ( toggled ( bool ) ),
+	          this, SLOT ( setHamlib ( bool ) ) );
+	connect ( this, SIGNAL ( toggleHamlibButton ( bool ) ), 
+		  cfgUseHamlib, SLOT ( setChecked ( bool ))); 
+	
+    QRadioButton *cfgMuteXmitHamlib = new QRadioButton ( cfgHamlibBox );
+	cfgMuteXmitHamlib->setText ( "Mute in Xmit" );
+    cfgMuteXmitHamlib->setAutoExclusive(FALSE);
+	cfgMuteXmitHamlib->setGeometry ( 150, 100, 180, 45 );
+	cfgMuteXmitHamlib->setChecked ( useHamlib );
+	connect ( cfgMuteXmitHamlib, SIGNAL ( toggled ( bool ) ),
+		  this, SLOT ( setMuteXmit ( bool ) ) );
+
+	// Transmit Tab
+	// Transmit Enable
+	QGroupBox *cfgTXBox = new QGroupBox ( cfgFrame7 );
+	cfgTXBox->setTitle ( "Transmit" );
+	cfgTXBox->setGeometry ( 5, 5, 340, 45 );
+
+	QRadioButton *cfgTransmit = new QRadioButton ( cfgTXBox );
+	cfgTransmit->setText ( "Enable transmit" );
+	cfgTransmit->setGeometry ( 25, 18, 200, 20 );
+	connect ( cfgTransmit, SIGNAL ( toggled ( bool ) ),
+	          this, SLOT ( updateTransmit ( bool ) ) );
+
+	// TX Microphone Gain and Output Gain
+	QGroupBox *cfgTxGain = new QGroupBox ( cfgFrame7 );
+	cfgTxGain->setTitle ( "TX Gain" );
+	cfgTxGain->setGeometry ( 5, 50, 340, 45 );
+
+	QLabel *cfgTxMicGainLabel = new QLabel ( cfgTxGain );
+	cfgTxMicGainLabel->setText ( "Mic Gain: " );
+	cfgTxMicGainLabel->setGeometry ( 10, 18, 70, 20 );
+	cfgTxMicGainLabel->setAlignment ( Qt::AlignRight | Qt::AlignVCenter );
+
+	cfgTxMicGainInput = new QSpinBox ( cfgTxGain );
+	cfgTxMicGainInput->setGeometry ( 80, 18, 70, 20 );
+	cfgTxMicGainInput->setMinimum ( -255 );
+	cfgTxMicGainInput->setMaximum ( 255 );
+	cfgTxMicGainInput->setValue ( micGain );
+	connect ( cfgTxMicGainInput, SIGNAL ( valueChanged ( int ) ),
+	          this, SLOT ( updateTxMicGain ( int ) ) );
+
+	QLabel *cfgTxOutputGainLabel = new QLabel ( cfgTxGain );
+	cfgTxOutputGainLabel->setText ( "Out Gain: " );
+	cfgTxOutputGainLabel->setGeometry ( 175, 18, 70, 20 );
+	cfgTxOutputGainLabel->setAlignment ( Qt::AlignRight | Qt::AlignVCenter );
+
+	cfgTxOutputGainInput = new QSpinBox ( cfgTxGain );
+	cfgTxOutputGainInput->setGeometry ( 245, 18, 70, 20 );
+	cfgTxOutputGainInput->setMinimum ( -255 );
+	cfgTxOutputGainInput->setMaximum ( 255 );
+	cfgTxOutputGainInput->setValue ( txGain );
+	connect ( cfgTxOutputGainInput, SIGNAL ( valueChanged ( int ) ),
+	          this, SLOT ( updateTxOutputGain ( int ) ) );
 
-	cfgFFTWindowGroup->setButton( fftWindow );	
-
+	
 	// About
-	QTextEdit *helpText = new QTextEdit( cfgFrame4 );
-	helpText->setGeometry( 2, 2, 347, 262 );
-	helpText->setReadOnly( true );
-	helpText->append( helptext );
+	QTextEdit *helpText = new QTextEdit ( cfgFrame4 );
+	helpText->setGeometry ( 2, 2, 347, 462 );
+	helpText->setReadOnly ( true );
+	helpText->append ( helptext );
 
 	// About
-	QTextEdit *aboutText = new QTextEdit( cfgFrame5 );
-	aboutText->setGeometry( 2, 2, 347, 262 );
-	aboutText->setReadOnly( true );
-	aboutText->append(
-		QString( "<center><br>SDR-Shell Version 2 Alpha<br>" ) +
-		"Copyright (c) 2006<br>" +
-		"Edson Pereira, PU1JTE, N1VTN<br>" +
-		"ewpereira@gmail.com<br><br></center>" );
-	aboutText->append(
-		QString( "This program is free software. You can redistribute " ) +
-		"it and/or modify it under the terms and conditions of the GNU " +
-		"General Public License Version 2 as published by the Free " +
-		"Software Foundation.\n\n" );
-		
-    // -----------------------------------------------------------------------
-    // S meter
-    QPixmap *meter1_pix = new QPixmap( meter1_xpm );
-    signalFrame = new QFrame( ctlFrame );
-    signalFrame->setPaletteBackgroundPixmap( *meter1_pix );
-    
-    for ( int i = 0; i < 34; i++ ) {
-        signalBargraph[i] = new QFrame( signalFrame );
-        signalBargraph[i]->setPaletteBackgroundColor( QColor( 50, 50, 50 ) );
-        signalBargraph[i]->setGeometry( 3 + 4 * i, 3, 3, 9 );
-        signalBargraph[i]->show();
-    }
+	QTextEdit *aboutText = new QTextEdit ( cfgFrame5 );
+	aboutText->setGeometry ( 2, 2, 347, 262 );
+	helpText->setWordWrapMode(QTextOption::WordWrap);
+	helpText->setLineWrapMode(QTextEdit::WidgetWidth);
+	aboutText->setReadOnly ( true );
+	aboutText->append (
+	    QString ( "<center><br>SDR-Shell Version " + version + "<br>" ) +
+	    "Copyright (c) 2006, 2007, 2009 2011<br>" +
+	    "Edson Pereira, PU1JTE, N1VTN<br>" +
+	    "ewpereira@gmail.com<br>" +
+	    "Rob Frohne, KL7NA<br>" +
+	    "kl7na@arrl.net<br>" +
+		"Glen Overby, KC0IYT<br></center>" );
+	aboutText->append (
+	    QString ( "This program is free software. You can redistribute " ) +
+	    "it and/or modify it under the terms and conditions of the GNU " +
+	    "General Public License Version 2 as published by the Free " +
+	    "Software Foundation.\n\n" );
+
+	// -----------------------------------------------------------------------
+	// Help frame
+	helpFrame = new QFrame();
+	helpFrame->setGeometry ( 50, 50, 380, 400 );
+	helpFrame->setMinimumWidth ( 380 );
+	helpFrame->setMaximumWidth ( 380 );
+	helpFrame->setMinimumHeight ( 500 );
+	helpFrame->setMaximumHeight ( 500 );
+    helpFrame->setWindowTitle("SDR-Shell : Help ");
+
+	QFrame *helpFrame1 = new QFrame( helpFrame );
+
+	QTabWidget *helpTab = new QTabWidget ( helpFrame );
+	helpTab->addTab ( helpFrame1, "General" );
+	helpTab->setGeometry ( 2, 2,
+	                         helpFrame->width() - 4,
+	                         helpFrame->height() - 2 );
+
+	QTextEdit *helpFText = new QTextEdit ( helpFrame1 );
+	helpFText->setGeometry ( 2, 2, 360, 460 );
+	helpFText->setReadOnly ( true );
+	helpFText->append ( helptext );
+	helpFText->setWordWrapMode(QTextOption::WordWrap);
+	helpFText->setLineWrapMode(QTextEdit::WidgetWidth);
+
+	// -----------------------------------------------------------------------
+	// DSP frame
+	dspFrame = new QFrame();
+	dspFrame->setGeometry ( 50, 50, 380, 250 );
+	dspFrame->setMinimumWidth ( 380 );
+	dspFrame->setMaximumWidth ( 380 );
+	dspFrame->setMinimumHeight ( 250 );
+	dspFrame->setMaximumHeight ( 250 );
+    dspFrame->setWindowTitle("SDR-Shell : DSP ");
+
+	QFrame *dspFrame1 = new QFrame( dspFrame );
+	QFrame *dspFrame2 = new QFrame( dspFrame );
+	QFrame *dspFrame3 = new QFrame( dspFrame );
+
+	QTabWidget *dspTab = new QTabWidget ( dspFrame );
+	dspTab->addTab ( dspFrame1, "NR" );
+	dspTab->addTab ( dspFrame2, "ANF" );
+	dspTab->addTab ( dspFrame3, "NB" );
+	dspTab->setGeometry ( 2, 2,
+	                         dspFrame->width() - 4,
+	                         dspFrame->height() - 2 );
+
+    //NR Vals Glenn VE9GJ
+	QGroupBox *nrvaluesBox = new QGroupBox ( dspFrame1 );
+	nrvaluesBox->setTitle ( "NR Values" );
+    nrvaluesBox->setGeometry( 5, 5, 330, 200 );
+	QLabel *NR_TapsLabel = new QLabel ( nrvaluesBox );
+	NR_TapsLabel->setText ( "Adaptive Filter Size (taps 128) :" );
+	NR_TapsLabel->setGeometry ( 10, 18, 250, 20 );
+	NR_TapsLabel->setAlignment ( Qt::AlignLeft | Qt::AlignVCenter );
+    NR_TapsSpinBox = new QSpinBox ( nrvaluesBox );
+	NR_TapsSpinBox->setGeometry (260, 18, 70, 20 );
+	NR_TapsSpinBox->setMinimum( 0 );
+	NR_TapsSpinBox->setMaximum( 255 );
+	NR_TapsSpinBox->setValue ( ( int ) NR_Taps );
+	connect ( NR_TapsSpinBox, SIGNAL ( valueChanged ( int ) ),
+	          this, SLOT ( setNR_Taps ( int ) ) );
+    QLabel *NR_DelayLabel = new QLabel ( nrvaluesBox );
+	NR_DelayLabel->setText ( "Delay (75):" );
+	NR_DelayLabel->setGeometry ( 10, 48, 250, 20 );
+	NR_DelayLabel->setAlignment ( Qt::AlignLeft | Qt::AlignVCenter );
+    NR_DelaySpinBox = new QSpinBox ( nrvaluesBox );
+	NR_DelaySpinBox->setGeometry ( 260, 48, 70, 20 );
+	NR_DelaySpinBox->setMinimum( 0 );
+	NR_DelaySpinBox->setMaximum( 255 );
+	NR_DelaySpinBox->setValue ( ( int ) NR_Delay );
+	connect ( NR_DelaySpinBox, SIGNAL ( valueChanged ( int ) ),
+	          this, SLOT ( setNR_Delay ( int ) ) );
+    QLabel *NR_GainLabel = new QLabel ( nrvaluesBox );
+	NR_GainLabel->setText ( "Adaptation Rate (gain 1):" );
+	NR_GainLabel->setGeometry ( 10, 78, 250, 20 );
+	NR_GainLabel->setAlignment ( Qt::AlignLeft | Qt::AlignVCenter );
+    NR_GainSpinBox = new QDoubleSpinBox ( nrvaluesBox );
+	NR_GainSpinBox->setGeometry ( 260, 78, 70, 20 );
+	NR_GainSpinBox->setMinimum( 0 );
+	NR_GainSpinBox->setMaximum( 1 );
+    NR_GainSpinBox->setDecimals( 2 );
+    NR_GainSpinBox->setSingleStep( 0.01);
+    NR_GainSpinBox->setValue ( ( double ) NR_Gain );
+    connect ( NR_GainSpinBox, SIGNAL ( valueChanged (double ) ),
+	          this, SLOT ( setNR_Gain (double ) ) );
+    QLabel *NR_LeakageLabel = new QLabel ( nrvaluesBox );
+	NR_LeakageLabel->setText ( "Leakage (leak 1):" );
+	NR_LeakageLabel->setGeometry ( 10, 108, 250, 20 );
+  	NR_LeakageLabel->setAlignment ( Qt::AlignLeft | Qt::AlignVCenter );
+    NR_LeakageSpinBox = new QDoubleSpinBox ( nrvaluesBox );
+	NR_LeakageSpinBox->setGeometry ( 260, 108, 70, 20 );
+	NR_LeakageSpinBox->setMinimum( 0 );
+	NR_LeakageSpinBox->setMaximum( 1 );
+    NR_LeakageSpinBox->setDecimals( 2 );
+    NR_LeakageSpinBox->setSingleStep( 0.01);
+    NR_LeakageSpinBox->setValue ( ( double ) NR_Leakage );
+	connect ( NR_LeakageSpinBox, SIGNAL ( valueChanged (double ) ),
+	          this, SLOT ( setNR_Leakage (double ) ) );
+    // End Glenn NR Values
+
+	// ANF Values
+	QGroupBox *anfvaluesBox = new QGroupBox ( dspFrame2 );
+	anfvaluesBox->setTitle ( "ANF Values" );
+    anfvaluesBox->setGeometry( 5, 5, 340, 200 );
+	QLabel *ANF_TapsLabel = new QLabel ( anfvaluesBox );
+	ANF_TapsLabel->setText ( "Adaptive Filter Size:" );
+	ANF_TapsLabel->setGeometry ( 10, 18, 250, 20 );
+	ANF_TapsLabel->setAlignment ( Qt::AlignLeft | Qt::AlignVCenter );
+    ANF_TapsSpinBox = new QSpinBox ( anfvaluesBox );
+	ANF_TapsSpinBox->setGeometry (260, 18, 70, 20 );
+	ANF_TapsSpinBox->setMinimum( 0 );
+	ANF_TapsSpinBox->setMaximum( 255 );
+	ANF_TapsSpinBox->setValue ( ( int ) ANF_Taps );
+	connect ( ANF_TapsSpinBox, SIGNAL ( valueChanged ( int ) ),
+	          this, SLOT ( setANF_Taps ( int ) ) );
+    QLabel *ANF_DelayLabel = new QLabel ( anfvaluesBox );
+	ANF_DelayLabel->setText ( "Delay:" );
+	ANF_DelayLabel->setGeometry ( 10, 48, 250, 20 );
+	ANF_DelayLabel->setAlignment ( Qt::AlignLeft | Qt::AlignVCenter );
+    ANF_DelaySpinBox = new QSpinBox ( anfvaluesBox );
+	ANF_DelaySpinBox->setGeometry ( 260, 48, 70, 20 );
+	ANF_DelaySpinBox->setMinimum( 0 );
+	ANF_DelaySpinBox->setMaximum( 255 );
+	ANF_DelaySpinBox->setValue ( ( int ) ANF_Delay );
+	connect ( ANF_DelaySpinBox, SIGNAL ( valueChanged ( int ) ),
+	          this, SLOT ( setANF_Delay ( int ) ) );
+    QLabel *ANF_GainLabel = new QLabel ( anfvaluesBox );
+	ANF_GainLabel->setText ( "Adaptation Rate (gain):" );
+	ANF_GainLabel->setGeometry ( 10, 78, 250, 20 );
+	ANF_GainLabel->setAlignment ( Qt::AlignLeft | Qt::AlignVCenter );
+    ANF_GainSpinBox = new QDoubleSpinBox ( anfvaluesBox );
+	ANF_GainSpinBox->setGeometry ( 260, 78, 70, 20 );
+	ANF_GainSpinBox->setMinimum( 0 );
+	ANF_GainSpinBox->setMaximum( 255 );
+    ANF_GainSpinBox->setDecimals( 2 );
+    ANF_GainSpinBox->setSingleStep( 0.01);
+    ANF_GainSpinBox->setValue ( ( double ) ANF_Gain );
+    connect ( ANF_GainSpinBox, SIGNAL ( valueChanged (double ) ),
+	          this, SLOT ( setANF_Gain (double ) ) );
+    QLabel *ANF_LeakageLabel = new QLabel ( anfvaluesBox );
+	ANF_LeakageLabel->setText ( "Leakage:" );
+	ANF_LeakageLabel->setGeometry ( 10, 108, 250, 20 );
+  	ANF_LeakageLabel->setAlignment ( Qt::AlignLeft | Qt::AlignVCenter );
+    ANF_LeakageSpinBox = new QDoubleSpinBox ( anfvaluesBox );
+	ANF_LeakageSpinBox->setGeometry ( 260, 108, 75, 20 );
+	ANF_LeakageSpinBox->setMinimum( 0 );
+	ANF_LeakageSpinBox->setMaximum( 255 );
+    ANF_LeakageSpinBox->setDecimals( 5 );
+    ANF_LeakageSpinBox->setSingleStep( 0.00001);
+    ANF_LeakageSpinBox->setValue ( ( double ) ANF_Leakage );
+	connect ( ANF_LeakageSpinBox, SIGNAL ( valueChanged (double ) ),
+	          this, SLOT ( setANF_Leakage (double ) ) );
+
+	// NB Values
+	QGroupBox *nbvaluesBox = new QGroupBox ( dspFrame3 );
+	nbvaluesBox->setTitle ( "NB Values" );
+    nbvaluesBox->setGeometry( 5, 5, 330, 200 );
+	QLabel *NB_ThresholdLabel = new QLabel ( nbvaluesBox );
+	NB_ThresholdLabel->setText ( "Threshold:" );
+	NB_ThresholdLabel->setGeometry ( 10, 18, 250, 20 );
+	NB_ThresholdLabel->setAlignment ( Qt::AlignLeft | Qt::AlignVCenter );
+    NB_ThresholdSpinBox = new QDoubleSpinBox ( nbvaluesBox );
+	NB_ThresholdSpinBox->setGeometry (260, 18, 70, 20 );
+	NB_ThresholdSpinBox->setMinimum( 0 );
+	NB_ThresholdSpinBox->setMaximum( 255 );
+	NB_ThresholdSpinBox->setValue ( ( int ) NB_Threshold );
+	connect ( NB_ThresholdSpinBox, SIGNAL ( valueChanged ( double ) ),
+	          this, SLOT ( setNB_Threshold ( double ) ) );
+
+	// -----------------------------------------------------------------------
+	// S meter
+	QPixmap *meter1_pix = new QPixmap ( meter1_xpm );
+	signalFrame = new QFrame ( ctlFrame );
+    p = signalFrame->palette();
+    p.setBrush(QPalette::Window, *meter1_pix);
+    //?? p.setColor(QPalette::Window, Qt::black);
+    signalFrame->setPalette(p); 
+    signalFrame->setAutoFillBackground( true );       
+
+	for ( int i = 0; i < 34; i++ )
+	{
+		signalBargraph[i] = new QFrame ( signalFrame );
+        signalBargraph[i]->setPalette( QColor( 50, 50, 50 ) );
+		signalBargraph[i]->setGeometry ( 3 + 4 * i, 3, 3, 9 );
+		//signalBargraph[i]->setFrameStyle ( QFrame::NoFrame | QFrame::Plain );
+        signalBargraph[i]->setAutoFillBackground(true);        
+		signalBargraph[i]->show();
+	}
 
-    signal_dBm = new QLabel( this, "-174", signalFrame );
-    signal_dBm->setFont( *font1 );
-    signal_dBm->setPaletteForegroundColor( QColor( 255, 255, 255 ) );
-    signal_dBm->setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-
-    QLabel *dBmLabel = new QLabel( this, " dBm", signalFrame );
-    dBmLabel->setFont( *font1 );
-    dBmLabel->setPaletteForegroundColor( QColor( 255, 255, 255 ) );
-    dBmLabel->setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-
-    lcd = new QLCDNumber( 12, ctlFrame );
-    lcd->setFrameStyle( QFrame::NoFrame );
-    lcd->setSegmentStyle( QLCDNumber::Filled );
-    lcd->setPaletteForegroundColor( QColor( 255, 255, 255 ) );
-    lcd->setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-
-	step_1Hz_frame = new QFrame( ctlFrame );
-	step_1Hz_frame->setGeometry( 321, 29, 11, 1 );
-
-	step_10Hz_frame = new QFrame( ctlFrame );
-	step_10Hz_frame->setGeometry( 308, 29, 11, 1 );
+    signal_dBm = new QLabel( "-174", signalFrame );    
+	signal_dBm->setFont ( *font1 );
+    p = signal_dBm->palette();
+    p.setColor(QPalette::Window, Qt::black);
+    p.setColor(QPalette::Active, QPalette::WindowText, QColor(255, 255, 255) );
+    signal_dBm->setPalette(p);
+
+    QLabel *dBmLabel = new QLabel( " dBm", signalFrame );    
+	dBmLabel->setFont ( *font1 );
+    p = dBmLabel->palette();
+    p.setColor(QPalette::Window, Qt::black);
+    p.setColor(QPalette::Active, QPalette::WindowText, QColor(255, 255, 255) );
+    dBmLabel->setPalette(p);
+
+    //Frequency display
+    //lcd = new QLCDNumber( 12, ctlFrame );
+    lcd = new LCDFreq( 12, ctlFrame );
+	lcd->setFrameStyle ( QFrame::NoFrame );
+	lcd->setSegmentStyle( QLCDNumber::Filled );
+    p = lcd->palette();
+    //p.setColor(QPalette::Window, Qt::black);
+    //p.setColor(QPalette::Active, QPalette::WindowText, QColor(255, 255, 255) );
+    p.setColor(QPalette::WindowText, QColor(255, 255, 255) );
+    lcd->setPalette(p);
+    lcd->setAutoFillBackground(true);
+	connect ( lcd, SIGNAL ( tune3 ( int ) ),
+	          this, SLOT ( tunef ( int ) ) );
+	connect ( lcd, SIGNAL ( tuneStep ( int ) ),
+	          this, SLOT ( setTuneStep ( int ) ) );
+
+	step_1Hz_frame = new QFrame ( ctlFrame );
+	step_1Hz_frame->setGeometry ( 318, 29, 11, 1 );
 
-	step_100Hz_frame = new QFrame( ctlFrame );
-	step_100Hz_frame->setGeometry( 295, 29, 11, 1 );
+	step_10Hz_frame = new QFrame ( ctlFrame );
+	step_10Hz_frame->setGeometry ( 305, 29, 11, 1 );
 
-	step_1000Hz_frame = new QFrame( ctlFrame );
-	step_1000Hz_frame->setGeometry( 282, 29, 11, 1 );
+	step_100Hz_frame = new QFrame ( ctlFrame );
+	step_100Hz_frame->setGeometry ( 292, 29, 11, 1 );
 
-    rxPix = new QPixmap( rx_xpm );
-    txPix = new QPixmap( tx_xpm );
-    
-    trxFrame = new QFrame( ctlFrame );
-    trxFrame->setPaletteBackgroundPixmap( *rxPix );
-    
-    QPixmap *mhz_pix = new QPixmap( mhz_xpm );
-    QFrame *mhzFrame = new QFrame( ctlFrame );
-    mhzFrame->setPaletteBackgroundPixmap( *mhz_pix );
-    signal_dBm->setGeometry( 140, 2, 35, 12 );
+	step_1KHz_frame = new QFrame ( ctlFrame );
+	step_1KHz_frame->setGeometry ( 279, 29, 11, 1 );
+	
+	step_10KHz_frame = new QFrame ( ctlFrame );
+	step_10KHz_frame->setGeometry ( 266, 29, 11, 1 );
+	
+	step_100KHz_frame = new QFrame ( ctlFrame );
+	step_100KHz_frame->setGeometry ( 253, 29, 11, 1 );
+	
+	step_1MHz_frame = new QFrame ( ctlFrame );
+	step_1MHz_frame->setGeometry ( 234, 29, 11, 1 );
+	
+	step_10MHz_frame = new QFrame ( ctlFrame );
+	step_10MHz_frame->setGeometry ( 221, 29, 11, 1 );
+	
+	step_100MHz_frame = new QFrame ( ctlFrame );
+	step_100MHz_frame->setGeometry ( 208, 29, 11, 1 );
 
-    // -----------------------------------------------------------------------
-    // Mode Frame
-    
-    QFrame *modeFrame = new QFrame( ctlFrame );
-    modeFrame->setBackgroundColor( QColor( 100, 0, 0 ) );
+    QPixmap rxPix(rx_xpm);
+    QPixmap txPix(tx_xpm);
 
-    QPixmap lsb_pix( lsb_xpm );
-    LSB_label = new Varilabel( modeFrame );
-    LSB_label->setPixmap( lsb_pix );
-    LSB_label->setLabel( LSB );
-    LSB_label->setGeometry( 3, 3, 21, 11 );
-    connect( LSB_label, SIGNAL(mouseRelease(int)), 
-			 this, SLOT(setMode(int)) );
-
-    QPixmap usb_pix( usb_xpm );
-    USB_label = new Varilabel( modeFrame );
-    USB_label->setPixmap( usb_pix );
-    USB_label->setLabel( USB );
-    USB_label->setGeometry( 27, 3, 21, 11 );
-    connect( USB_label, SIGNAL(mouseRelease(int)), 
-			 this, SLOT(setMode(int)) );
-
-    QPixmap dsb_pix( dsb_xpm );
-    DSB_label = new Varilabel( modeFrame );
-    DSB_label->setPixmap( dsb_pix );
-    DSB_label->setLabel( DSB );
-    DSB_label->setGeometry( 51, 3, 21, 11 );
-    connect( DSB_label, SIGNAL(mouseRelease(int)), 
-			 this, SLOT(setMode(int)) );
-
-    QPixmap am_pix( am_xpm );
-    AM_label = new Varilabel( modeFrame );
-    AM_label->setPixmap( am_pix );
-    AM_label->setLabel( AM );
-    AM_label->setGeometry( 75, 3, 21, 11 );
-    connect( AM_label, SIGNAL(mouseRelease(int)), 
-			 this, SLOT(setMode(int)) );
-
-    QPixmap cwl_pix( cwl_xpm );
-    CWL_label = new Varilabel( modeFrame );
-    CWL_label->setPixmap( cwl_pix );
-    CWL_label->setLabel( CWL );
-    CWL_label->setGeometry( 3, 17, 21, 11 );
-    connect( CWL_label, SIGNAL(mouseRelease(int)), 
-			 this, SLOT(setMode(int)) );
-
-    QPixmap cwu_pix( cwu_xpm );
-    CWU_label = new Varilabel( modeFrame );
-    CWU_label->setPixmap( cwu_pix );
-    CWU_label->setLabel( CWU );
-    CWU_label->setGeometry( 27, 17, 21, 11 );
-    connect( CWU_label, SIGNAL(mouseRelease(int)), 
-			 this, SLOT(setMode(int)) );
-
-    QPixmap sam_pix( sam_xpm );
-    SAM_label = new Varilabel( modeFrame );
-    SAM_label->setPixmap( sam_pix );
-    SAM_label->setLabel( SAM );
-    SAM_label->setGeometry( 51, 17, 21, 11 );
-    connect( SAM_label, SIGNAL(mouseRelease(int)), 
-			 this, SLOT(setMode(int)) );
-
-    QPixmap fmn_pix( fmn_xpm );
-    FMN_label = new Varilabel( modeFrame );
-    FMN_label->setPixmap( fmn_pix );
-    FMN_label->setLabel( FMN );
-    FMN_label->setGeometry( 75, 17, 21, 11 );
-    connect( FMN_label, SIGNAL(mouseRelease(int)), 
-			 this, SLOT(setMode(int)) );
-
-    // -----------------------------------------------------------------------
-    // Noise Reduction Frame
-
-    QFrame *swFrame = new QFrame( ctlFrame );
-    swFrame->setBackgroundColor( QColor( 0, 80, 0 ) );
-
-    QPixmap nr_pix( nr_xpm );
-    NR_label = new Varilabel( swFrame );
-    NR_label->setPixmap( nr_pix );
-    NR_label->setGeometry( 3, 3, 27, 11 );
-    connect( NR_label, SIGNAL(mouseRelease(int)), 
-			 this, SLOT(toggle_NR(int)) );
-    
-    QPixmap anf_pix( anf_xpm );
-    ANF_label = new Varilabel( swFrame );
-    ANF_label->setPixmap( anf_pix );
-    ANF_label->setGeometry( 33, 3, 27, 11 );
-    connect( ANF_label, SIGNAL(mouseRelease(int)), 
-			 this, SLOT(toggle_ANF(int)) );
-    
-    QPixmap nb_pix( nb_xpm );
-    NB_label = new Varilabel( swFrame );
-    NB_label->setPixmap( nb_pix );
-    NB_label->setGeometry( 63, 3, 27, 11 );
-    connect( NB_label, SIGNAL(mouseRelease(int)), 
-			 this, SLOT(toggle_NB(int)) );
-
-    QPixmap bin_pix( bin_xpm );
-    BIN_label = new Varilabel( swFrame );
-    BIN_label->setPixmap( bin_pix );
-    BIN_label->setGeometry( 3, 17, 27, 11 );
-    connect( BIN_label, SIGNAL(mouseRelease(int)), 
-			 this, SLOT(toggle_BIN(int)) );
-
-    QPixmap mute_pix( mute_xpm );
-    MUTE_label = new Varilabel( swFrame );
-    MUTE_label->setPixmap( mute_pix );
-    MUTE_label->setGeometry( 33, 17, 27, 11 );
-    MUTE_label->setBackgroundColor( QColor( 0, 0, 0 ) );
-    connect( MUTE_label, SIGNAL(mouseRelease(int)), 
-			 this, SLOT(toggle_MUTE(int)) );
-
-    QPixmap spec_pix( spec_xpm );
-    SPEC_label = new Varilabel( swFrame );
-    SPEC_label->setPixmap( spec_pix );
-    SPEC_label->setGeometry( 63, 17, 27, 11 );
-    connect( SPEC_label, SIGNAL(mouseRelease(int)), 
-			 this, SLOT(toggle_SPEC(int)) );
-        
-    // -----------------------------------------------------------------------
-    // Memory Cells
-
-    f1_cell = new MemoryCell( ctlFrame2 );
-    f1_cell->setFont( *font1 );
-    f1_cell->setPaletteForegroundColor( QColor( 255, 255, 255 ) );
-    f1_cell->setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-    f1_cell->setGeometry( 1, 1, 20, 15 );
-    f1_cell->setAlignment( Qt::AlignHCenter | Qt::AlignVCenter );
-    f1_cell->setText( "F1" );
-    connect( f1_cell, SIGNAL(read(MemoryCell *)), 
-			 this, SLOT(readMem(MemoryCell *)) );
-    connect( f1_cell, SIGNAL(write(MemoryCell *)), 
-			 this, SLOT(writeMem(MemoryCell *)) );
-    connect( f1_cell, SIGNAL(display(MemoryCell *)), 
-			 this, SLOT(displayMem(MemoryCell *)) );
-    
-    f2_cell = new MemoryCell( ctlFrame2 );
-    f2_cell->setFont( *font1 );
-    f2_cell->setPaletteForegroundColor( QColor( 255, 255, 255 ) );
-    f2_cell->setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-    f2_cell->setGeometry( 22, 1, 20, 15 );
-    f2_cell->setAlignment( Qt::AlignHCenter | Qt::AlignVCenter );
-    f2_cell->setText( "F2" );
-    connect( f2_cell, SIGNAL(read(MemoryCell *)), 
-			 this, SLOT(readMem(MemoryCell *)) );
-    connect( f2_cell, SIGNAL(write(MemoryCell *)), 
-			 this, SLOT(writeMem(MemoryCell *)) );
-    connect( f2_cell, SIGNAL(display(MemoryCell *)), 
-			 this, SLOT(displayMem(MemoryCell *)) );
-    
-    f3_cell = new MemoryCell( ctlFrame2 );
-    f3_cell->setFont( *font1 );
-    f3_cell->setPaletteForegroundColor( QColor( 255, 255, 255 ) );
-    f3_cell->setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-    f3_cell->setGeometry( 43, 1, 20, 15 );
-    f3_cell->setAlignment( Qt::AlignHCenter | Qt::AlignVCenter );
-    f3_cell->setText( "F3" );
-    connect( f3_cell, SIGNAL(read(MemoryCell *)), 
-			 this, SLOT(readMem(MemoryCell *)) );
-    connect( f3_cell, SIGNAL(write(MemoryCell *)), 
-			 this, SLOT(writeMem(MemoryCell *)) );
-    connect( f3_cell, SIGNAL(display(MemoryCell *)), 
-			 this, SLOT(displayMem(MemoryCell *)) );
-
-    f4_cell = new MemoryCell( ctlFrame2 );
-    f4_cell->setFont( *font1 );
-    f4_cell->setPaletteForegroundColor( QColor( 255, 255, 255 ) );
-    f4_cell->setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-    f4_cell->setGeometry( 64, 1, 20, 15 );
-    f4_cell->setAlignment( Qt::AlignHCenter | Qt::AlignVCenter );
-    f4_cell->setText( "F4" );
-    connect( f4_cell, SIGNAL(read(MemoryCell *)), 
-			 this, SLOT(readMem(MemoryCell *)) );
-    connect( f4_cell, SIGNAL(write(MemoryCell *)), 
-			 this, SLOT(writeMem(MemoryCell *)) );
-    connect( f4_cell, SIGNAL(display(MemoryCell *)), 
-			 this, SLOT(displayMem(MemoryCell *)) );
-            
-    f5_cell = new MemoryCell( ctlFrame2 );
-    f5_cell->setFont( *font1 );
-    f5_cell->setPaletteForegroundColor( QColor( 255, 255, 255 ) );
-    f5_cell->setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-    f5_cell->setGeometry( 85, 1, 20, 15 );
-    f5_cell->setAlignment( Qt::AlignHCenter | Qt::AlignVCenter );
-    f5_cell->setText( "F5" );
-    connect( f5_cell, SIGNAL(read(MemoryCell *)), 
-			 this, SLOT(readMem(MemoryCell *)) );
-    connect( f5_cell, SIGNAL(write(MemoryCell *)), 
-			 this, SLOT(writeMem(MemoryCell *)) );
-    connect( f5_cell, SIGNAL(display(MemoryCell *)), 
-			 this, SLOT(displayMem(MemoryCell *)) );
-    
-    f6_cell = new MemoryCell( ctlFrame2 );
-    f6_cell->setFont( *font1 );
-    f6_cell->setPaletteForegroundColor( QColor( 255, 255, 255 ) );
-    f6_cell->setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-    f6_cell->setGeometry( 106, 1, 20, 15 );
-    f6_cell->setAlignment( Qt::AlignHCenter | Qt::AlignVCenter );
-    f6_cell->setText( "F6" );
-    connect( f6_cell, SIGNAL(read(MemoryCell *)), 
-			 this, SLOT(readMem(MemoryCell *)) );
-    connect( f6_cell, SIGNAL(write(MemoryCell *)), 
-			 this, SLOT(writeMem(MemoryCell *)) );
-    connect( f6_cell, SIGNAL(display(MemoryCell *)), 
-			 this, SLOT(displayMem(MemoryCell *)) );
-    
-    f7_cell = new MemoryCell( ctlFrame2 );
-    f7_cell->setFont( *font1 );
-    f7_cell->setPaletteForegroundColor( QColor( 255, 255, 255 ) );
-    f7_cell->setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-    f7_cell->setGeometry( 127, 1, 20, 15 );
-    f7_cell->setAlignment( Qt::AlignHCenter | Qt::AlignVCenter );
-    f7_cell->setText( "F7" );
-    connect( f7_cell, SIGNAL(read(MemoryCell *)), 
-			 this, SLOT(readMem(MemoryCell *)) );
-    connect( f7_cell, SIGNAL(write(MemoryCell *)),
-			 this, SLOT(writeMem(MemoryCell *)) );
-    connect( f7_cell, SIGNAL(display(MemoryCell *)), 
-			 this, SLOT(displayMem(MemoryCell *)) );
-    
-    f8_cell = new MemoryCell( ctlFrame2 );
-    f8_cell->setFont( *font1 );
-    f8_cell->setPaletteForegroundColor( QColor( 255, 255, 255 ) );
-    f8_cell->setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-    f8_cell->setGeometry( 148, 1, 20, 15 );
-    f8_cell->setAlignment( Qt::AlignHCenter | Qt::AlignVCenter );
-    f8_cell->setText( "F8" );
-    connect( f8_cell, SIGNAL(read(MemoryCell *)), 
-			 this, SLOT(readMem(MemoryCell *)) );
-    connect( f8_cell, SIGNAL(write(MemoryCell *)), 
-			 this, SLOT(writeMem(MemoryCell *)) );
-    connect( f8_cell, SIGNAL(display(MemoryCell *)), 
-			 this, SLOT(displayMem(MemoryCell *)) );
-
-	M_label = new QLabel( ctlFrame2 );
-    M_label->setFont( *font1 );
-    M_label->setPaletteForegroundColor( QColor( 255, 255, 255 ) );
-    M_label->setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-    M_label->setGeometry( 
-		169, 
-		1, 
-		font1Metrics->maxWidth() * 12, 
-		15 );
-    M_label->setAlignment( Qt::AlignHCenter | Qt::AlignVCenter );
+	trxFrame = new QFrame ( ctlFrame );
+    trxFrame->setPalette( QColor( 0, 0, 0) );
+    trxFrame->setAutoFillBackground(true);
+	TRX_label = new Varilabel ( trxFrame );
+	TRX_label->setGeometry ( 0, 0, 19, 11 );
+    TRX_label->setPixmap(rxPix);
+    TRX_label->setLabel( RX );
+	connect ( TRX_label, SIGNAL ( mouseRelease ( int ) ),
+	          this, SLOT ( toggle_TX ( int ) ) );
+
+    QPixmap mhz_pix(mhz_xpm);
+    QFrame *mhzFrame = new QFrame( ctlFrame );
+    mhzFrame->setPalette( QColor( 0, 0, 0) );
+    mhzFrame->setAutoFillBackground(true);
+   
+    MHz_label = new QLabel(mhzFrame);
+    MHz_label->setPixmap(mhz_pix);
+    MHz_label->setPalette( QColor( 0, 0, 0) );
+    MHz_label->setAutoFillBackground(true);
+	signal_dBm->setGeometry ( 140, 2, 35, 12 );
+
+	// -----------------------------------------------------------------------
+	// Mode Frame
+
+    QFrame *modeFrame = new QFrame( this );
+    modeFrame->setFrameStyle( QFrame::StyledPanel | QFrame::Plain );  
+    modeFrame->setPalette( QColor(100, 0, 0) );
+    modeFrame->setAutoFillBackground(true);
+
+	QPixmap lsb_pix ( lsb_xpm );
+	LSB_label = new VariModelabel ( modeFrame );
+	LSB_label->setPixmap ( lsb_pix );
+	LSB_label->setLabel ( RIG_MODE_LSB );
+	LSB_label->setGeometry ( 3, 3, 21, 11 );
+	connect ( LSB_label, SIGNAL ( mouseRelease ( rmode_t, bool, bool ) ),
+	          this, SLOT ( setMode ( rmode_t, bool, bool ) ) );
+
+	QPixmap usb_pix ( usb_xpm );
+	USB_label = new VariModelabel ( modeFrame );
+	USB_label->setPixmap ( usb_pix );
+	USB_label->setLabel ( RIG_MODE_USB );
+	USB_label->setGeometry ( 27, 3, 21, 11 );
+	connect ( USB_label, SIGNAL ( mouseRelease ( rmode_t, bool, bool ) ),
+	          this, SLOT ( setMode ( rmode_t, bool, bool ) ) );
+
+	QPixmap dsb_pix ( dsb_xpm );
+	DSB_label = new VariModelabel ( modeFrame );
+	DSB_label->setPixmap ( dsb_pix );
+	DSB_label->setLabel ( RIG_MODE_DSB );
+	DSB_label->setGeometry ( 51, 3, 21, 11 );
+	connect ( DSB_label, SIGNAL ( mouseRelease ( rmode_t, bool, bool ) ),
+	          this, SLOT ( setMode ( rmode_t, bool, bool ) ) );
+
+	QPixmap am_pix ( am_xpm );
+	AM_label = new VariModelabel ( modeFrame );
+	AM_label->setPixmap ( am_pix );
+	AM_label->setLabel ( RIG_MODE_AM );
+	AM_label->setGeometry ( 75, 3, 21, 11 );
+	connect ( AM_label, SIGNAL ( mouseRelease ( rmode_t, bool, bool ) ),
+	          this, SLOT ( setMode ( rmode_t, bool, bool ) ) );
+
+	QPixmap cwl_pix ( cwl_xpm );
+	CWL_label = new VariModelabel ( modeFrame );
+	CWL_label->setPixmap ( cwl_pix );
+	CWL_label->setLabel ( RIG_MODE_CWR );
+	CWL_label->setGeometry ( 3, 17, 21, 11 );
+	connect ( CWL_label, SIGNAL ( mouseRelease ( rmode_t, bool, bool ) ),
+	          this, SLOT ( setMode ( rmode_t, bool, bool ) ) );
+
+	QPixmap cwu_pix ( cwu_xpm );
+	CWU_label = new VariModelabel ( modeFrame );
+	CWU_label->setPixmap ( cwu_pix );
+	CWU_label->setLabel ( RIG_MODE_CW );
+	CWU_label->setGeometry ( 27, 17, 21, 11 );
+	connect ( CWU_label, SIGNAL ( mouseRelease ( rmode_t, bool, bool ) ),
+	          this, SLOT ( setMode ( rmode_t, bool, bool ) ) );
+
+	QPixmap sam_pix ( sam_xpm );
+	SAM_label = new VariModelabel ( modeFrame );
+	SAM_label->setPixmap ( sam_pix );
+	SAM_label->setLabel ( RIG_MODE_SAM );
+	SAM_label->setGeometry ( 51, 17, 21, 11 );
+	connect ( SAM_label, SIGNAL ( mouseRelease ( rmode_t, bool, bool ) ),
+	          this, SLOT ( setMode ( rmode_t, bool, bool ) ) );
+
+	QPixmap fmn_pix ( fmn_xpm );
+	FMN_label = new VariModelabel ( modeFrame );
+	FMN_label->setPixmap ( fmn_pix );
+	FMN_label->setLabel ( RIG_MODE_FM );
+	FMN_label->setGeometry ( 75, 17, 21, 11 );
+	connect ( FMN_label, SIGNAL ( mouseRelease ( rmode_t, bool, bool ) ),
+	          this, SLOT ( setMode ( rmode_t, bool, bool ) ) );
+
+	// -----------------------------------------------------------------------
+	// Noise Reduction Frame
+
+    QFrame *swFrame = new QFrame( this );
+    swFrame->setFrameStyle( QFrame::StyledPanel | QFrame::Plain );    
+    swFrame->setPalette( QColor( 0, 80, 0 ) );
+    swFrame->setAutoFillBackground( true );
+
+	QPixmap nr_pix ( nr_xpm );
+	NR_label = new Varilabel ( swFrame );
+	NR_label->setPixmap ( nr_pix );
+	NR_label->setGeometry ( 3, 3, 27, 11 );
+	connect ( NR_label, SIGNAL ( mouseRelease ( int ) ),
+	          this, SLOT ( toggle_NR ( int ) ) );
+	connect ( NR_label, SIGNAL ( mouseRelease2 ( int ) ),
+	          this, SLOT ( setDSP ( int ) ) );
+
+	QPixmap anf_pix ( anf_xpm );
+	ANF_label = new Varilabel ( swFrame );
+	ANF_label->setPixmap ( anf_pix );
+	ANF_label->setGeometry ( 33, 3, 27, 11 );
+	connect ( ANF_label, SIGNAL ( mouseRelease ( int ) ),
+	          this, SLOT ( toggle_ANF ( int ) ) );
+	connect ( ANF_label, SIGNAL ( mouseRelease2 ( int ) ),
+	          this, SLOT ( setDSP ( int ) ) );
+
+	QPixmap nb_pix ( nb_xpm );
+	NB_label = new Varilabel ( swFrame );
+	NB_label->setPixmap ( nb_pix );
+	NB_label->setGeometry ( 63, 3, 27, 11 );
+	connect ( NB_label, SIGNAL ( mouseRelease ( int ) ),
+	          this, SLOT ( toggle_NB ( int ) ) );
+	connect ( NB_label, SIGNAL ( mouseRelease2 ( int ) ),
+	          this, SLOT ( setDSP ( int ) ) );
+
+	QPixmap bin_pix ( bin_xpm );
+	BIN_label = new Varilabel ( swFrame );
+	BIN_label->setPixmap ( bin_pix );
+	BIN_label->setGeometry ( 3, 17, 27, 11 );
+	connect ( BIN_label, SIGNAL ( mouseRelease ( int ) ),
+	          this, SLOT ( toggle_BIN ( int ) ) );
+
+	QPixmap mute_pix ( mute_xpm );
+	MUTE_label = new Varilabel ( swFrame );
+	MUTE_label->setPixmap ( mute_pix );
+	MUTE_label->setGeometry ( 33, 17, 27, 11 );
+	connect ( MUTE_label, SIGNAL ( mouseRelease ( int ) ),
+	          this, SLOT ( toggle_MUTE ( int ) ) );
+
+	QPixmap spec_pix ( spec_xpm );
+	SPEC_label = new Varilabel ( swFrame );
+	SPEC_label->setPixmap ( spec_pix );
+	SPEC_label->setGeometry ( 63, 17, 27, 11 );
+	connect ( SPEC_label, SIGNAL ( mouseRelease ( int ) ),
+	          this, SLOT ( toggle_SPEC ( int ) ) );
+
+	// -----------------------------------------------------------------------
+	// Band Frame
+	QFrame *bFrame = new QFrame ( this );
+    bFrame->setFrameStyle( QFrame::StyledPanel | QFrame::Plain );    
+    bFrame->setPalette( QColor( 0, 80, 0 ) );
+    bFrame->setAutoFillBackground( true );
+
+	QPixmap up_pix ( up_xpm );
+	UP_label = new Varilabel ( bFrame );
+	UP_label->setPixmap ( up_pix );
+	UP_label->setGeometry ( 3, 3, 27, 11 );
+   	UP_label->setPalette(QColor(0, 0, 0) );
+    UP_label->setAutoFillBackground( true );
+	connect ( UP_label, SIGNAL ( mouseRelease ( int ) ),
+	          this, SLOT ( band_UP ( int ) ) );
+
+	QPixmap down_pix ( down_xpm );
+	DOWN_label = new Varilabel ( bFrame );
+	DOWN_label->setPixmap ( down_pix );
+	DOWN_label->setGeometry ( 3, 17, 27, 11 );
+   	DOWN_label->setPalette(QColor(0, 0, 0) );
+    DOWN_label->setAutoFillBackground( true );
+	connect ( DOWN_label, SIGNAL ( mouseRelease ( int ) ),
+	          this, SLOT ( band_DOWN ( int ) ) );
+
+	// -----------------------------------------------------------------------
+	// Sub Mode Frame
+	QFrame *subFrame = new QFrame ( this );
+    subFrame->setFrameStyle( QFrame::StyledPanel | QFrame::Plain );    
+    subFrame->setPalette( QColor( 0, 0, 100 ) );
+    subFrame->setAutoFillBackground( true );
+
+	QPixmap rit_pix ( rit_xpm );
+	RIT_label = new Varilabel ( subFrame );
+	RIT_label->setPixmap ( rit_pix );
+	RIT_label->setGeometry ( 3, 3, 27, 11 );
+   	RIT_label->setAutoFillBackground( true );
+	connect ( RIT_label, SIGNAL ( mouseRelease ( int ) ),
+	          this, SLOT ( toggle_RIT ( int ) ) );
+
+	QPixmap split_pix ( split_xpm );
+	SPLIT_label = new Varilabel ( subFrame );
+	SPLIT_label->setPixmap ( split_pix );
+	SPLIT_label->setGeometry ( 3, 17, 27, 11 );
+   	SPLIT_label->setAutoFillBackground( true );
+	connect ( SPLIT_label, SIGNAL ( mouseRelease ( int ) ),
+	          this, SLOT ( toggle_SPLIT ( int ) ) );
+
+	// -----------------------------------------------------------------------
+	// RIT / Split Value
+	rit = new QLabel ( ctlFrame );
+	rit->setFont ( *fontlcd);
+    p = rit->palette();
+    p.setColor(QPalette::Window, Qt::black);
+    p.setColor(QPalette::Active, QPalette::WindowText, QColor(255, 255, 255) );
+    rit->setPalette(p);
+    rit->setAutoFillBackground(true);
+	//rit->setFrameStyle ( QFrame::NoFrame );
+
+	// -----------------------------------------------------------------------
+	// Memory Cells
+
+	for (int i=0; i<NUM_MEMS; i++) {
+	  char buffer[256];
+	  f_cell[i] = new MemoryCell(ctlFrame2);
+      f_cell[i]->setFrameStyle( QFrame::StyledPanel | QFrame::Plain );
+	  f_cell[i]->setFont(*font1);
+	  f_cell[i]->setGeometry((i*21+1), 1, 20, 15);
+      f_cell[i]->setPalette( QColor( 0, 0, 0 ) );
+      f_cell[i]->setAutoFillBackground( true );
+      p = f_cell[i]->palette();
+      p.setColor(QPalette::Active, QPalette::WindowText, QColor( 255, 255, 255) );
+      f_cell[i]->setPalette(p);
+	  f_cell[i]->setGeometry((i*21+1), 1, 20, 15);
+	  f_cell[i]->setAlignment(Qt::AlignHCenter|Qt::AlignVCenter);
+	  snprintf(buffer, 256, "F%d", (i+1));
+	  f_cell[i]->setText (buffer);
+	  f_cell[i]->setID (i+1);
+	  connect(f_cell[i], SIGNAL(read(MemoryCell *)),
+		    this, SLOT(readMem(MemoryCell *)));
+	  connect(f_cell[i],SIGNAL(write(MemoryCell *)),
+		    this, SLOT(writeMem(MemoryCell *)));
+	  connect (f_cell[i], SIGNAL(display(MemoryCell *)),
+		    this, SLOT(displayMem(MemoryCell *)));
+	}
+
+	M_label = new QLabel ( ctlFrame2 );
+	M_label->setFont ( *font1 );
+    M_label->setPalette( QColor( 0, 0, 0 ) );
+    M_label->setAutoFillBackground( true );
+    p = M_label->palette();
+    p.setColor(QPalette::Inactive, QPalette::WindowText, QColor( 255, 255, 255) );
+    M_label->setPalette(p);
+	M_label->setGeometry (
+//	    169,
+		f_cell[(NUM_MEMS-1)]->x() + f_cell[(NUM_MEMS-1)]->width(),
+	    1,
+	    font1Metrics->maxWidth() * 12,
+	    15 );
+	M_label->setAlignment ( Qt::AlignHCenter | Qt::AlignVCenter );
+
+	for (int i=0; i<NUM_BANDMEMS; i++) {
+	  band_cell[i] = new MemoryCell();
+	  band_cell[i]->setID(i+11);
+	}
+	band = 1;
 
 	loadMemoryCells();
 
-    // -----------------------------------------------------------------------
-    // Spectrogram Color Aperture
-    
-    CA_label = new QLabel( ctlFrame2 );
-    CA_label->setFont( *font1 );
-    CA_label->setPaletteForegroundColor( QColor( 255, 100, 100 ) );
-    CA_label->setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-    CA_label->setGeometry( 
-		M_label->x() + M_label->width() + 1, 
-		1, 
-		font1Metrics->maxWidth() * 16, 
-		15 );
-    CA_label->setAlignment( Qt::AlignHCenter | Qt::AlignVCenter );
-    
-   
-    // -----------------------------------------------------------------------
-    // AGC
-    
-    AGC_label = new QLabel( ctlFrame2 );
-    AGC_label->setFont( *font1 );
-    AGC_label->setText( " AGC" );
-    AGC_label->setPaletteForegroundColor( QColor( 0, 180, 255 ) );
-    AGC_label->setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-    AGC_label->setGeometry( 
-		CA_label->x() + CA_label->width() + 1, 
-		1, 
-		font1Metrics->maxWidth() * 5 + 50, 
-		15 );
-    AGC_label->setAlignment( Qt::AlignLeft | Qt::AlignVCenter );
-    
-    //QPixmap agc_o_pix( agc_o_xpm );
-    //AGC_O_label = new Varilabel( AGC_label );
+	// -----------------------------------------------------------------------
+	// Spectrogram Color Aperture
+
+	CA_label = new QLabel ( ctlFrame2 );
+    CA_label->setFrameStyle( QFrame::StyledPanel | QFrame::Plain );
+	CA_label->setFont ( *font1 );
+    p = CA_label->palette();
+    p.setColor(QPalette::Window, Qt::black);
+    p.setColor(QPalette::Active, QPalette::WindowText, QColor(255, 100, 100) );
+    CA_label->setPalette(p);
+    CA_label->setAutoFillBackground( true );
+	CA_label->setGeometry (
+	    M_label->x() + M_label->width() + 1,
+		0, 
+	    font1Metrics->maxWidth() * 16,
+		17 );
+	CA_label->setAlignment ( Qt::AlignHCenter | Qt::AlignVCenter );
+
+
+	// -----------------------------------------------------------------------
+	// AGC
+	AGC_label = new QLabel ( ctlFrame2 );
+    AGC_label->setFrameStyle( QFrame::StyledPanel | QFrame::Plain );
+	AGC_label->setFont ( *font1 );
+	AGC_label->setText ( " AGC" );
+    p = AGC_label->palette();
+    p.setColor(QPalette::Window, Qt::black);
+    p.setColor(QPalette::Active, QPalette::WindowText, QColor( 0, 180, 255 ) );
+    p.setColor(QPalette::Inactive, QPalette::WindowText, QColor( 255, 180, 0 ) );
+    AGC_label->setPalette(p);
+    AGC_label->setAutoFillBackground( true );
+	AGC_label->setGeometry (
+		CA_label->x() + CA_label->width() - 1, 
+		0, 
+	    font1Metrics->maxWidth() * 5 + 50,
+		17 );
+	AGC_label->setAlignment ( Qt::AlignLeft | Qt::AlignVCenter );
+
+	//QPixmap agc_o_pix( agc_o_xpm );
+	//AGC_O_label = new Varilabel( AGC_label );
 	//AGC_O_label->setLabel( 0 );
-    //AGC_O_label->setPixmap( agc_o_pix );
-    //AGC_O_label->setGeometry( font1Metrics->maxWidth() * 5, 2, 9, 11 );
-    //connect( AGC_O_label, SIGNAL(mouseRelease(int)), 
+	//AGC_O_label->setPixmap( agc_o_pix );
+	//AGC_O_label->setGeometry( font1Metrics->maxWidth() * 5, 2, 9, 11 );
+	//connect( AGC_O_label, SIGNAL(mouseRelease(int)),
 	//		 this, SLOT(setAGC(int)) );
 
-    QPixmap agc_l_pix( agc_l_xpm );
-    AGC_L_label = new Varilabel( AGC_label );
-	AGC_L_label->setLabel( 1 );
-    AGC_L_label->setPixmap( agc_l_pix );
-    AGC_L_label->setGeometry( font1Metrics->maxWidth() * 5, 2, 9, 11 );
-    connect( AGC_L_label, SIGNAL(mouseRelease(int)), 
-			 this, SLOT(setAGC(int)) );
-
-    QPixmap agc_s_pix( agc_s_xpm );
-    AGC_S_label = new Varilabel( AGC_label );
-	AGC_S_label->setLabel( 2 );
-    AGC_S_label->setPixmap( agc_s_pix );
-    AGC_S_label->setGeometry( AGC_L_label->x() + 11, 2, 9, 11 );
-    connect( AGC_S_label, SIGNAL(mouseRelease(int)), 
-			 this, SLOT(setAGC(int)) );
-
-    QPixmap agc_m_pix( agc_m_xpm );
-    AGC_M_label = new Varilabel( AGC_label );
-	AGC_M_label->setLabel( 3 );
-    AGC_M_label->setPixmap( agc_m_pix );
-    AGC_M_label->setGeometry( AGC_S_label->x() + 11, 2, 9, 11 );
-    connect( AGC_M_label, SIGNAL(mouseRelease(int)), 
-			 this, SLOT(setAGC(int)) );
-
-    QPixmap agc_f_pix( agc_f_xpm );
-    AGC_F_label = new Varilabel( AGC_label );
-	AGC_F_label->setLabel( 4 );
-    AGC_F_label->setPixmap( agc_f_pix );
-    AGC_F_label->setGeometry( AGC_M_label->x() + 11, 2, 9, 11 );
-    connect( AGC_F_label, SIGNAL(mouseRelease(int)), 
-			 this, SLOT(setAGC(int)) );
-   
-    // -----------------------------------------------------------------------
-    // Sapacer for filling up empty space
-    
-	Spacer_label = new QLabel( ctlFrame2 );
-    Spacer_label->setFont( *font1 );
-    Spacer_label->setPaletteForegroundColor( QColor( 100,255,100 ) );
-    Spacer_label->setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-    Spacer_label->setAlignment( Qt::AlignHCenter | Qt::AlignVCenter );
-
-    f_label = new Varilabel( ctlFrame );
-    f_label->setFont( *font1 );
-    f_label->setPaletteForegroundColor( QColor( 255,255,25 ) );
-    f_label->setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-    f_label->setGeometry( 173, 48, 85, 14 );
-    
-    CFG_label = new Varilabel( ctlFrame2 );
-    CFG_label->setFont( *font1 );
-    CFG_label->setText( "CFG" );
-    CFG_label->setPaletteForegroundColor( QColor( 255,255,255 ) );
-    CFG_label->setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-    CFG_label->setAlignment( Qt::AlignHCenter | Qt::AlignVCenter );
-    connect( CFG_label, SIGNAL(mouseRelease(int)), this, SLOT(setCfg(int)) );
-
-    CPU_label = new QLabel( ctlFrame2 );
-    CPU_label->setFont( *font1 );
-    CPU_label->setPaletteForegroundColor( QColor( 0, 180, 255 ) );
-    CPU_label->setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-    CPU_label->setAlignment( Qt::AlignHCenter | Qt::AlignVCenter );
-
-    ctlFrame1->setGeometry( 1, 1, 361, 31 );
-    signalFrame->setGeometry( 1, 3, 170, 27 );
-    dBmLabel->setGeometry( 140, 14, 35, 12 );
-    lcd->setGeometry( 170, 3, 170, 27 );
-    trxFrame->setGeometry( 337, 4, 19, 11 );
-    mhzFrame->setGeometry( 337, 19, 19, 8 );
-
-    modeFrame->setGeometry( 363, 1, 99, 31 );
-    swFrame->setGeometry( 463, 1, 93, 31 );
-
-    logoFrame = new QFrame( ctlFrame );
-    logoFrame->setBackgroundColor( QColor( 0, 0, 0 ) );
-
-    QPixmap logo_pix( logo_xpm );
-    logoLabel = new QLabel( logoFrame );
-    logoLabel->setPixmap( logo_pix );
-    logoLabel->setBackgroundColor( QColor( 0, 0, 0 ) );
-
-    setRxFrequency();
-    setMode( mode );
-    setIQGain();
-    setIQPhase();
-    set_NR( NR_state );
-    set_ANF( ANF_state );
-    set_NB( NB_state );
-    set_BIN( BIN_state );
-    set_SPEC( SPEC_state );
-    setCA_label();
-    setTuneStep( 0 );
-    setTheme( 2 );
-	setPolyFFT( polyphaseFFT );
-	setFFTWindow( fftWindow );
-	setSpectrumType( spectrumType );
-	setAGC( agcType );
-    processorLoad();
+	QPixmap agc_l_pix ( agc_l_xpm );
+	AGC_L_label = new Varilabel ( AGC_label );
+	AGC_L_label->setLabel ( 1 );
+	AGC_L_label->setPixmap ( agc_l_pix );
+    AGC_L_label->setFrameStyle( QFrame::Box | QFrame::Raised );
+    AGC_L_label->setLineWidth(0);
+    AGC_L_label->setMidLineWidth(0);
+    AGC_L_label->setGeometry( font1Metrics->maxWidth() * 5, 3, 9, 11 );
+	connect ( AGC_L_label, SIGNAL ( mouseRelease ( int ) ),
+	          this, SLOT ( setAGC ( int ) ) );
+
+	QPixmap agc_s_pix ( agc_s_xpm );
+	AGC_S_label = new Varilabel ( AGC_label );
+	AGC_S_label->setLabel ( 2 );
+	AGC_S_label->setPixmap ( agc_s_pix );
+    AGC_S_label->setGeometry( AGC_L_label->x() + 11, 3, 9, 11 );
+	connect ( AGC_S_label, SIGNAL ( mouseRelease ( int ) ),
+	          this, SLOT ( setAGC ( int ) ) );
+
+	QPixmap agc_m_pix ( agc_m_xpm );
+	AGC_M_label = new Varilabel ( AGC_label );
+	AGC_M_label->setLabel ( 3 );
+	AGC_M_label->setPixmap ( agc_m_pix );
+    AGC_M_label->setGeometry( AGC_S_label->x() + 11, 3, 9, 11 );
+	connect ( AGC_M_label, SIGNAL ( mouseRelease ( int ) ),
+	          this, SLOT ( setAGC ( int ) ) );
+
+	QPixmap agc_f_pix ( agc_f_xpm );
+	AGC_F_label = new Varilabel ( AGC_label );
+	AGC_F_label->setLabel ( 4 );
+	AGC_F_label->setPixmap ( agc_f_pix );
+    AGC_F_label->setGeometry( AGC_M_label->x() + 11, 3, 9, 11 );
+	connect ( AGC_F_label, SIGNAL ( mouseRelease ( int ) ),
+	          this, SLOT ( setAGC ( int ) ) );
+
+	// -----------------------------------------------------------------------
+	// Zoom
+	Zoom_label = new QLabel ( ctlFrame2 );
+    Zoom_label->setFrameStyle( QFrame::StyledPanel | QFrame::Plain );
+	Zoom_label->setFont ( *font1 );
+	Zoom_label->setText ( " Zoom" );
+    p = Zoom_label->palette();
+    p.setColor(QPalette::Window, Qt::black);
+    p.setColor(QPalette::Active, QPalette::WindowText, QColor( 0, 180, 255 ) );
+    p.setColor(QPalette::Inactive, QPalette::WindowText, QColor( 255, 180, 0 ) );
+    Zoom_label->setPalette(p);
+    Zoom_label->setAutoFillBackground( true );
+	Zoom_label->setGeometry (
+		AGC_label->x() + AGC_label->width() - 1, 
+		0, 
+	    font1Metrics->maxWidth() * 5 + 50,
+		17 );
+	Zoom_label->setAlignment ( Qt::AlignLeft | Qt::AlignVCenter );
 
-    //worldmap->setObserver( my_lat, my_lon );
-    //worldmap->plot();
-    
-    QTimer *cpuTimer = new QTimer( this );
-    connect( cpuTimer, SIGNAL(timeout()), this, SLOT(processorLoad()) );
-    cpuTimer->start( 5000, FALSE );
-
-    QTimer *meterTimer = new QTimer( this );
-    connect( meterTimer, SIGNAL(timeout()), this, SLOT(readMeter()) );
-    meterTimer->start( 100, FALSE );
-
-    QTimer *fftTimer = new QTimer( this );
-    connect( fftTimer, SIGNAL(timeout()), this, SLOT(readSpectrum()) );
-    fftTimer->start( 100, FALSE );
+	QPixmap zoom_in_pix ( zoom_in_xpm );
+	Zoom_in_label = new Varilabel ( Zoom_label );
+	Zoom_in_label->setLabel ( 3 );
+	Zoom_in_label->setPixmap ( zoom_in_pix );
+    Zoom_in_label->setGeometry( font1Metrics->maxWidth() * 5, 3, 27, 11 );
+	connect ( Zoom_in_label, SIGNAL ( mouseRelease ( int ) ),
+	          this, SLOT ( zoomIN ( int ) ) );
+
+	QPixmap zoom_out_pix ( zoom_out_xpm );
+	Zoom_out_label = new Varilabel ( Zoom_label );
+	Zoom_out_label->setLabel ( 4 );
+	Zoom_out_label->setPixmap ( zoom_out_pix );
+    Zoom_out_label->setGeometry( Zoom_in_label->x() + 27, 3, 27, 11 );
+	connect ( Zoom_out_label, SIGNAL ( mouseRelease ( int ) ),
+	          this, SLOT ( zoomOUT ( int ) ) );
+
+
+
+	// -----------------------------------------------------------------------
+	// Spacer for filling up empty space
+	Spacer_label = new QLabel ( ctlFrame2 );
+	Spacer_label->setFont ( *font1 );
+	Spacer_label->setAlignment ( Qt::AlignHCenter | Qt::AlignVCenter );
+	//Spacer_label->setPalette( QColor( 0, 0, 255 ) );
+	Spacer_label->setPalette( QColor( 0, 0, 0 ) );
+	Spacer_label->setAutoFillBackground( true );
+
+	// -----------------------------------------------------------------------
+	CFG_label = new Varilabel ( ctlFrame2 );
+	CFG_label->setFrameStyle( QFrame::StyledPanel | QFrame::Plain );
+	CFG_label->setFont ( *font1 );
+	CFG_label->setText ( "CFG" );
+	CFG_label->setPalette( QColor( 0, 0, 0 ) );
+	CFG_label->setAutoFillBackground( true );
+	p = CFG_label->palette();
+	p.setColor(QPalette::Active, QPalette::WindowText, QColor( 255, 255, 255) );
+	CFG_label->setPalette(p);
+	CFG_label->setAlignment ( Qt::AlignHCenter | Qt::AlignVCenter );
+	connect ( CFG_label, SIGNAL ( mouseRelease ( int ) ), this, SLOT ( setCfg ( int ) ) );
+
+	// -----------------------------------------------------------------------
+	HELP_label = new Varilabel ( ctlFrame2 );
+	HELP_label->setFrameStyle( QFrame::StyledPanel | QFrame::Plain );
+	HELP_label->setFont ( *font1 );
+	HELP_label->setText ( "Help" );
+	HELP_label->setPalette( QColor( 0, 0, 0 ) );
+	HELP_label->setAutoFillBackground( true );
+	p = HELP_label->palette();
+	p.setColor(QPalette::Active, QPalette::WindowText, QColor( 255, 255, 255) );
+	HELP_label->setPalette(p);
+	HELP_label->setAlignment ( Qt::AlignHCenter | Qt::AlignVCenter );
+	connect ( HELP_label, SIGNAL ( mouseRelease ( int ) ), this, SLOT ( setHelp ( int ) ) );
+
+	// -----------------------------------------------------------------------
+	CPU_label = new QLabel ( ctlFrame2 );
+	CPU_label->setFrameStyle( QFrame::StyledPanel | QFrame::Plain );
+	CPU_label->setFont ( *font1 );
+	CPU_label->setPalette( QColor( 0, 0, 0 ) );
+	CPU_label->setAutoFillBackground( true );
+	p = CPU_label->palette();
+	p.setColor(QPalette::Active, QPalette::WindowText, QColor( 0, 180, 255) );
+	CPU_label->setPalette(p);
+	CPU_label->setAlignment ( Qt::AlignHCenter | Qt::AlignVCenter );
+
+	// -----------------------------------------------------------------------
+	//ctlFrame1->setGeometry ( 1, 1, 641, 31 );
+	signalFrame->setGeometry ( 1, 3, 170, 27 );
+	dBmLabel->setGeometry ( 140, 14, 35, 12 );
+	lcd->setGeometry ( 170, 3, 170, 27 );
+	trxFrame->setGeometry ( 337, 4, 19, 11 );
+	mhzFrame->setGeometry ( 337, 19, 19, 8 );
+
+	bFrame->setGeometry ( 363, 1, 33, 31 );
+	modeFrame->setGeometry ( 397, 1, 99, 31 );
+	swFrame->setGeometry ( 497, 1, 93, 31 );
+	subFrame->setGeometry ( 590, 1, 33, 31 );
+	rit->setGeometry ( 625, 1, 130, 31 );
+
+	logoFrame = new QFrame ( ctlFrame );
+	logoFrame->setPalette( QColor( 0, 0, 0 ) );
+	logoFrame->setAutoFillBackground(true);
+
+	QPixmap logo_pix ( logo_xpm );
+	logoLabel = new QLabel ( logoFrame );
+	logoLabel->setPixmap ( logo_pix );
+	logoLabel->setPalette( QColor( 0, 0, 0 ) );
+	logoLabel->setAutoFillBackground(true);
+
+	// -----------------------------------------------------------------------
+	// Arbitrary SSP commands
+	for (int i=0; i < NUM_CMD; i++) {
+		char buffer[16];
+		c_cell[i] = new Command(ctlFrame2);
+		c_cell[i]->setFrameStyle( QFrame::StyledPanel | QFrame::Plain );
+		c_cell[i]->setFont ( *font1 );
+		snprintf(buffer, 16, "C%d", i);
+		c_cell[i]->setText ( buffer );
+		c_cell[i]->setPalette( QColor( 0, 0, 0 ) );
+		c_cell[i]->setAutoFillBackground( true );
+		p = c_cell[i]->palette();
+		p.setColor(QPalette::Active, QPalette::WindowText, QColor( 255, 255, 255) );
+		c_cell[i]->setPalette(p);
+		c_cell[i]->setGeometry (
+			Zoom_label->x() + Zoom_label->width() - 1 + i * (font1Metrics->maxWidth() * 4),
+			//Zoom_label->x() + Zoom_label->width() - 1 + i * 22,
+			0,
+			font1Metrics->maxWidth() * 4 + 1,
+			17 );
+		c_cell[i]->setAlignment ( Qt::AlignHCenter | Qt::AlignVCenter );
+		connect ( c_cell[i], SIGNAL ( mouseReleaseL ( Command * ) ),
+			this, SLOT ( toggleCmd ( Command * ) ) );
+		connect ( c_cell[i], SIGNAL ( mouseReleaseR ( Command * ) ),
+			this, SLOT ( configCmd ( Command * ) ) );
+
+		c_cell[i]->setName(buffer);
+		c_cell[i]->setCmd((DttSPcmd*)pCmd, (DttSPcmd*)pTXCmd);
+		c_cell[i]->setID(i);
+		c_cell[i]->setCommand(QString("getTXOsc\n"), QString("getRXOsc\n"));
+        if(verbose) fprintf(stderr, "cmd widget %d\n", i);
+	}
+	loadCommandCells();
+
+	// -----------------------------------------------------------------------
+	//	DttSP Command Configuration
+
+	cmdFrame = new QFrame();
+	cmdFrame->setGeometry ( 50, 50, 200, 400 );
+	cmdFrame->setMinimumWidth ( 380 );
+	cmdFrame->setMaximumWidth ( 380 );
+	cmdFrame->setMinimumHeight ( 200 );
+	cmdFrame->setMaximumHeight ( 200 );
+	cmdFrame->setWindowTitle("SDR-Shell : Command Config ");
+
+	QTabWidget *cmdTab = new QTabWidget ( cmdFrame );
+	cmdTab->setFont ( *font1 );
+	cmdTab->setGeometry ( 2, 2,
+							 cfgFrame->width() - 4,
+							 cfgFrame->height() - 2 );
+
+	// >>>Figure out how to put all of this in an object
+	for (int i=0; i < NUM_CMD; i++) {
+		char buffer[8];
+
+		QFrame *cmdSubTab = new QFrame( cmdFrame );
+		snprintf(buffer, 8, "C%d", i);
+		cmdTab->addTab ( cmdSubTab, buffer );
+		// Name (3 or 4 characters)
+		// displayed in place of C#
+		QLabel *namelabel = new QLabel ( cmdSubTab );
+		namelabel->setText ( "Name: " );
+		namelabel->setGeometry ( 10, 15, 50, 20 );
+		namelabel->setAlignment ( Qt::AlignRight | Qt::AlignVCenter );
+		cmdName[i] = new QLineEdit ( cmdSubTab );
+		cmdName[i]->setGeometry( 60, 15, 50, 20 );
+		cmdName[i]->setText ( c_cell[i]->getName() );
+		cmdName[i]->setEnabled(true);
+
+		// set
+		QLabel *onLabel = new QLabel ( cmdSubTab );
+		onLabel->setText ( "On: " );
+		onLabel->setGeometry ( 10, 37, 50, 20 );
+		onLabel->setAlignment ( Qt::AlignRight | Qt::AlignVCenter );
+		cmdOnCommand[i] = new QLineEdit ( cmdSubTab );
+		cmdOnCommand[i]->setGeometry( 60, 37, 300, 20 );
+		cmdOnCommand[i]->setText ( c_cell[i]->getOnCommand() );
+		cmdOnCommand[i]->setEnabled(true);
+
+		// clear
+		QLabel *offLabel = new QLabel ( cmdSubTab );
+		offLabel->setText ( "Off: " );
+		offLabel->setGeometry ( 10, 60, 50, 20 );
+		offLabel->setAlignment ( Qt::AlignRight | Qt::AlignVCenter );
+		cmdOffCommand[i] = new QLineEdit ( cmdSubTab );
+		cmdOffCommand[i]->setGeometry( 60, 60, 300, 20 );
+		cmdOffCommand[i]->setText ( c_cell[i]->getOffCommand() );
+		cmdOffCommand[i]->setEnabled(true);
+
+		// send to RX
+		cmdRXbutton[i] = new QRadioButton ( cmdSubTab );
+		cmdRXbutton[i]->setText ( "Send to RX DttSP" );
+		cmdRXbutton[i]->setGeometry ( 25, 90, 200, 20 );
+		cmdRXbutton[i]->setAutoExclusive(false);
+		if (c_cell[i]->getToRX())
+			cmdRXbutton[i]->setChecked ( true );
+
+		cmdTXbutton[i] = new QRadioButton ( cmdSubTab );
+		cmdTXbutton[i]->setText ( "Send to TX DttSP" );
+		cmdTXbutton[i]->setGeometry ( 25, 110, 200, 20 );
+		cmdTXbutton[i]->setAutoExclusive(false);
+		if (c_cell[i]->getToTX())
+			cmdTXbutton[i]->setChecked ( true );
+
+		IdPushButton *cmdAccept = new IdPushButton( cmdSubTab );
+		cmdAccept->setID(i);
+		cmdAccept->setText ( "Accept" );
+		cmdAccept->setGeometry( 10, 140, 70, 20 );
+		cmdAccept->setEnabled(true);
+		connect ( cmdAccept, SIGNAL ( selected(int) ),
+				this, SLOT ( updateCmd( int ) ) );
+
+		IdPushButton *cmdReset = new IdPushButton( cmdSubTab );
+		cmdReset->setID(i);
+		cmdReset->setText ( "Reset" );
+		cmdReset->setGeometry( 250, 140, 70, 20 );
+		cmdReset->setEnabled(true);
+		connect ( cmdReset, SIGNAL ( selected(int) ),
+			this, SLOT ( resetCmd( int ) ) );
+	}
+	setRxFrequency( 1 );
+	if (useIF)
+	{
+	  setDefaultRxFrequency();
+	}
+	setIQGain();
+	setIQPhase();
+	set_NR ( NR_state );
+	set_ANF ( ANF_state );
+	set_NB ( NB_state );
+	set_BIN ( BIN_state );
+	set_SPEC ( SPEC_state );
+	set_MUTE ( 0 );
+	set_RIT ( 0 );
+	set_SPLIT ( 0 );
+   	UP_label->setPalette(QColor(0, 0, 0) );
+   	DOWN_label->setPalette(QColor(0, 0, 0) );
+	setCA_label();
+	setTuneStep ( 0 );
+	setTheme ( 2 );
+    setPolyFFT ( );
+	setSpectrumDefaults();
+	setAGC ( agcType );
+	setTxIQGain();
+	setTxIQPhase();
+	setTxGain( 0 );
+	setTxGain( 1 );
+	processorLoad();
+	hScale = 1.0;
+	vsScale = 1.0;
+	specLineFill = 0;
+	filterLine = 1;
+	if ( useHamlib )
+	{
+		initHamlib();
+	}
+	initRigCtl();
+	setMode(mode, FALSE, TRUE);
+	specAveraging = 1;
+	specLow = -140;
+	specHigh = -40;
+	cfgTransmit->setChecked ( enableTransmit );
+	if (enableTransmit) {
+		TXoff();
+	}
+
+	QTimer *cpuTimer = new QTimer ( this );
+	connect ( cpuTimer, SIGNAL ( timeout() ), this, SLOT ( processorLoad() ) );
+    cpuTimer->start( 5000 );
+
+	QTimer *meterTimer = new QTimer ( this );
+	connect ( meterTimer, SIGNAL ( timeout() ), this, SLOT ( readMeter() ) );
+    meterTimer->start( 100 );
+
+	QTimer *fftTimer = new QTimer ( this );
+	connect ( fftTimer, SIGNAL ( timeout() ), this, SLOT ( readSpectrum() ) );
+    fftTimer->start( 100 );  
+
+#ifdef PTT_POLL
+    QTimer *pttTimer = new QTimer ( this );
+	connect ( pttTimer, SIGNAL ( timeout() ), this, SLOT ( updatePTT() ) );
+    pttTimer->start( 100 );      
+#endif
+
+#ifdef FREQ_POLL
+    QTimer *freqTimer = new QTimer ( this );
+	connect ( freqTimer, SIGNAL ( timeout() ), this, SLOT ( updateFreq() ) );
+    freqTimer->start( 150 );      
+#endif
 }
 
-void Main_Widget::initConstants()
+void Main_Widget::set_InitFile(char *path)
 {
-    // Modes    
-    modeName[LSB] = new QString( "LSB" );
-    modeName[USB] = new QString( "USB" );
-    modeName[DSB] = new QString( "DSB" );
-    modeName[CWL] = new QString( "CWL" );
-    modeName[CWU] = new QString( "CWU" );
-    modeName[FMN] = new QString( "FMN" );
-    modeName[AM] = new QString( "AM" );
-    modeName[DIGU] = new QString( "DIGU" );
-    modeName[SPEC] = new QString( "SPEC" );
-    modeName[DIGL] = new QString( "DIGL" );
-    modeName[SAM] = new QString( "SAM" );
-    modeName[DRM] = new QString( "DRM" );
-
-    // S meter colors
-    s_dbm[0] = -127; signalColor[0]  = new QColor( 40, 255, 40 );
-    s_dbm[1] = -124; signalColor[1]  = new QColor( 40, 255, 40 );
-    s_dbm[2] = -121; signalColor[2]  = new QColor( 40, 255, 40 ); // S1
-    s_dbm[3] = -118; signalColor[3]  = new QColor( 40, 255, 40 );
-    s_dbm[4] = -115; signalColor[4]  = new QColor( 40, 255, 40 ); // S2
-    s_dbm[5] = -112; signalColor[5]  = new QColor( 40, 255, 40 );
-    s_dbm[6] = -109; signalColor[6]  = new QColor( 40, 255, 40 ); // S3
-    s_dbm[7] = -106; signalColor[7]  = new QColor( 40, 255, 40 );
-    s_dbm[8] = -103; signalColor[8]  = new QColor( 40, 255, 40 ); // S4
-    s_dbm[9] = -100; signalColor[9]  = new QColor( 40, 255, 40 );
-    s_dbm[10] = -97; signalColor[10] = new QColor( 40, 255, 40 ); // S5
-    s_dbm[11] = -94; signalColor[11] = new QColor( 40, 255, 40 );
-    s_dbm[12] = -91; signalColor[12] = new QColor( 40, 255, 40 ); // S6
-    s_dbm[13] = -88; signalColor[13] = new QColor( 40, 255, 40 );
-    s_dbm[14] = -85; signalColor[14] = new QColor( 40, 255, 40 ); // S7
-    s_dbm[15] = -82; signalColor[15] = new QColor( 40, 255, 40 );
-    s_dbm[16] = -79; signalColor[16] = new QColor( 40, 255, 40 ); // S8
-    s_dbm[17] = -76; signalColor[17] = new QColor( 40, 255, 40 );
-    s_dbm[18] = -73; signalColor[18] = new QColor( 40, 255, 40 ); // S9
-    s_dbm[19] = -69; signalColor[19] = new QColor( 255, 255, 40 );
-    s_dbm[20] = -65; signalColor[20] = new QColor( 255, 255, 40 );
-    s_dbm[21] = -61; signalColor[21] = new QColor( 255, 255, 40 );
-    s_dbm[22] = -57; signalColor[22] = new QColor( 255, 255, 40 );
-    s_dbm[23] = -53; signalColor[23] = new QColor( 255, 255, 40 ); // S9+20dB
-    s_dbm[24] = -49; signalColor[24] = new QColor( 255,  70, 40 );
-    s_dbm[25] = -45; signalColor[25] = new QColor( 255,  70, 40 );
-    s_dbm[26] = -41; signalColor[26] = new QColor( 255,  70, 40 );
-    s_dbm[27] = -37; signalColor[27] = new QColor( 255,  70, 40 );
-    s_dbm[28] = -33; signalColor[28] = new QColor( 255,  70, 40 ); // S9+40dB
-    s_dbm[29] = -29; signalColor[29] = new QColor( 255,  40, 40 );
-    s_dbm[30] = -25; signalColor[30] = new QColor( 255,  40, 40 );
-    s_dbm[31] = -21; signalColor[31] = new QColor( 255,  40, 40 );
-    s_dbm[32] = -17; signalColor[32] = new QColor( 255,  40, 40 );
-    s_dbm[33] = -13; signalColor[33] = new QColor( 255,  40, 40 ); // S9+60dB
-
-    // Spectrogram colors
-    spec_r[119] = 250; spec_g[119] = 253; spec_b[119] = 254;
-    spec_r[118] = 245; spec_g[118] = 250; spec_b[118] = 253;
-    spec_r[117] = 240; spec_g[117] = 247; spec_b[117] = 252;
-    spec_r[116] = 235; spec_g[116] = 244; spec_b[116] = 251;
-    spec_r[115] = 230; spec_g[115] = 241; spec_b[115] = 250;
-    spec_r[114] = 225; spec_g[114] = 238; spec_b[114] = 249;
-    spec_r[113] = 220; spec_g[113] = 235; spec_b[113] = 248;
-    spec_r[112] = 215; spec_g[112] = 233; spec_b[112] = 247;
-    spec_r[111] = 210; spec_g[111] = 230; spec_b[111] = 246;
-    spec_r[110] = 205; spec_g[110] = 227; spec_b[110] = 245;
-    spec_r[109] = 201; spec_g[109] = 224; spec_b[109] = 243;
-    spec_r[108] = 196; spec_g[108] = 221; spec_b[108] = 242;
-    spec_r[107] = 192; spec_g[107] = 219; spec_b[107] = 241;
-    spec_r[106] = 187; spec_g[106] = 216; spec_b[106] = 240;
-    spec_r[105] = 183; spec_g[105] = 213; spec_b[105] = 239;
-    spec_r[104] = 179; spec_g[104] = 210; spec_b[104] = 238;
-    spec_r[103] = 174; spec_g[103] = 207; spec_b[103] = 237;
-    spec_r[102] = 170; spec_g[102] = 205; spec_b[102] = 236;
-    spec_r[101] = 166; spec_g[101] = 202; spec_b[101] = 234;
-    spec_r[100] = 162; spec_g[100] = 199; spec_b[100] = 233;
-    spec_r[ 99] = 158; spec_g[ 99] = 197; spec_b[ 99] = 232;
-    spec_r[ 98] = 154; spec_g[ 98] = 194; spec_b[ 98] = 231;
-    spec_r[ 97] = 150; spec_g[ 97] = 191; spec_b[ 97] = 230;
-    spec_r[ 96] = 146; spec_g[ 96] = 188; spec_b[ 96] = 228;
-    spec_r[ 95] = 142; spec_g[ 95] = 186; spec_b[ 95] = 227;
-    spec_r[ 94] = 139; spec_g[ 94] = 183; spec_b[ 94] = 226;
-    spec_r[ 93] = 135; spec_g[ 93] = 181; spec_b[ 93] = 225;
-    spec_r[ 92] = 131; spec_g[ 92] = 178; spec_b[ 92] = 224;
-    spec_r[ 91] = 128; spec_g[ 91] = 175; spec_b[ 91] = 222;
-    spec_r[ 90] = 124; spec_g[ 90] = 173; spec_b[ 90] = 221;
-    spec_r[ 89] = 121; spec_g[ 89] = 170; spec_b[ 89] = 220;
-    spec_r[ 88] = 117; spec_g[ 88] = 167; spec_b[ 88] = 219;
-    spec_r[ 87] = 114; spec_g[ 87] = 165; spec_b[ 87] = 217;
-    spec_r[ 86] = 111; spec_g[ 86] = 162; spec_b[ 86] = 216;
-    spec_r[ 85] = 108; spec_g[ 85] = 160; spec_b[ 85] = 215;
-    spec_r[ 84] = 104; spec_g[ 84] = 157; spec_b[ 84] = 214;
-    spec_r[ 83] = 101; spec_g[ 83] = 155; spec_b[ 83] = 212;
-    spec_r[ 82] = 98; spec_g[ 82] = 152; spec_b[ 82] = 211;
-    spec_r[ 81] = 95; spec_g[ 81] = 149; spec_b[ 81] = 210;
-    spec_r[ 80] = 92; spec_g[ 80] = 147; spec_b[ 80] = 209;
-    spec_r[ 79] = 90; spec_g[ 79] = 144; spec_b[ 79] = 207;
-    spec_r[ 78] = 87; spec_g[ 78] = 142; spec_b[ 78] = 206;
-    spec_r[ 77] = 84; spec_g[ 77] = 140; spec_b[ 77] = 205;
-    spec_r[ 76] = 81; spec_g[ 76] = 137; spec_b[ 76] = 203;
-    spec_r[ 75] = 79; spec_g[ 75] = 135; spec_b[ 75] = 202;
-    spec_r[ 74] = 76; spec_g[ 74] = 132; spec_b[ 74] = 201;
-    spec_r[ 73] = 73; spec_g[ 73] = 130; spec_b[ 73] = 199;
-    spec_r[ 72] = 71; spec_g[ 72] = 127; spec_b[ 72] = 198;
-    spec_r[ 71] = 68; spec_g[ 71] = 125; spec_b[ 71] = 196;
-    spec_r[ 70] = 66; spec_g[ 70] = 122; spec_b[ 70] = 195;
-    spec_r[ 69] = 64; spec_g[ 69] = 120; spec_b[ 69] = 194;
-    spec_r[ 68] = 61; spec_g[ 68] = 118; spec_b[ 68] = 192;
-    spec_r[ 67] = 59; spec_g[ 67] = 115; spec_b[ 67] = 191;
-    spec_r[ 66] = 57; spec_g[ 66] = 113; spec_b[ 66] = 189;
-    spec_r[ 65] = 55; spec_g[ 65] = 111; spec_b[ 65] = 188;
-    spec_r[ 64] = 53; spec_g[ 64] = 108; spec_b[ 64] = 186;
-    spec_r[ 63] = 51; spec_g[ 63] = 106; spec_b[ 63] = 185;
-    spec_r[ 62] = 49; spec_g[ 62] = 104; spec_b[ 62] = 184;
-    spec_r[ 61] = 47; spec_g[ 61] = 101; spec_b[ 61] = 182;
-    spec_r[ 60] = 45; spec_g[ 60] = 99; spec_b[ 60] = 181;
-    spec_r[ 59] = 43; spec_g[ 59] = 97; spec_b[ 59] = 179;
-    spec_r[ 58] = 41; spec_g[ 58] = 95; spec_b[ 58] = 177;
-    spec_r[ 57] = 39; spec_g[ 57] = 93; spec_b[ 57] = 176;
-    spec_r[ 56] = 38; spec_g[ 56] = 90; spec_b[ 56] = 174;
-    spec_r[ 55] = 36; spec_g[ 55] = 88; spec_b[ 55] = 173;
-    spec_r[ 54] = 34; spec_g[ 54] = 86; spec_b[ 54] = 171;
-    spec_r[ 53] = 33; spec_g[ 53] = 84; spec_b[ 53] = 170;
-    spec_r[ 52] = 31; spec_g[ 52] = 82; spec_b[ 52] = 168;
-    spec_r[ 51] = 30; spec_g[ 51] = 79; spec_b[ 51] = 166;
-    spec_r[ 50] = 28; spec_g[ 50] = 77; spec_b[ 50] = 165;
-    spec_r[ 49] = 27; spec_g[ 49] = 75; spec_b[ 49] = 163;
-    spec_r[ 48] = 25; spec_g[ 48] = 73; spec_b[ 48] = 161;
-    spec_r[ 47] = 24; spec_g[ 47] = 71; spec_b[ 47] = 160;
-    spec_r[ 46] = 23; spec_g[ 46] = 69; spec_b[ 46] = 158;
-    spec_r[ 45] = 22; spec_g[ 45] = 67; spec_b[ 45] = 156;
-    spec_r[ 44] = 20; spec_g[ 44] = 65; spec_b[ 44] = 155;
-    spec_r[ 43] = 19; spec_g[ 43] = 63; spec_b[ 43] = 153;
-    spec_r[ 42] = 18; spec_g[ 42] = 61; spec_b[ 42] = 151;
-    spec_r[ 41] = 17; spec_g[ 41] = 59; spec_b[ 41] = 149;
-    spec_r[ 40] = 16; spec_g[ 40] = 57; spec_b[ 40] = 147;
-    spec_r[ 39] = 15; spec_g[ 39] = 55; spec_b[ 39] = 145;
-    spec_r[ 38] = 14; spec_g[ 38] = 53; spec_b[ 38] = 144;
-    spec_r[ 37] = 13; spec_g[ 37] = 51; spec_b[ 37] = 142;
-    spec_r[ 36] = 12; spec_g[ 36] = 49; spec_b[ 36] = 140;
-    spec_r[ 35] = 11; spec_g[ 35] = 47; spec_b[ 35] = 138;
-    spec_r[ 34] = 10; spec_g[ 34] = 46; spec_b[ 34] = 136;
-    spec_r[ 33] = 10; spec_g[ 33] = 44; spec_b[ 33] = 134;
-    spec_r[ 32] = 9; spec_g[ 32] = 42; spec_b[ 32] = 132;
-    spec_r[ 31] = 8; spec_g[ 31] = 40; spec_b[ 31] = 130;
-    spec_r[ 30] = 7; spec_g[ 30] = 38; spec_b[ 30] = 127;
-    spec_r[ 29] = 7; spec_g[ 29] = 37; spec_b[ 29] = 125;
-    spec_r[ 28] = 6; spec_g[ 28] = 35; spec_b[ 28] = 123;
-    spec_r[ 27] = 6; spec_g[ 27] = 33; spec_b[ 27] = 121;
-    spec_r[ 26] = 5; spec_g[ 26] = 31; spec_b[ 26] = 119;
-    spec_r[ 25] = 5; spec_g[ 25] = 30; spec_b[ 25] = 116;
-    spec_r[ 24] = 4; spec_g[ 24] = 28; spec_b[ 24] = 114;
-    spec_r[ 23] = 4; spec_g[ 23] = 27; spec_b[ 23] = 112;
-    spec_r[ 22] = 3; spec_g[ 22] = 25; spec_b[ 22] = 109;
-    spec_r[ 21] = 3; spec_g[ 21] = 23; spec_b[ 21] = 107;
-    spec_r[ 20] = 2; spec_g[ 20] = 22; spec_b[ 20] = 104;
-    spec_r[ 19] = 2; spec_g[ 19] = 20; spec_b[ 19] = 101;
-    spec_r[ 18] = 2; spec_g[ 18] = 19; spec_b[ 18] = 99;
-    spec_r[ 17] = 1; spec_g[ 17] = 17; spec_b[ 17] = 96;
-    spec_r[ 16] = 1; spec_g[ 16] = 16; spec_b[ 16] = 93;
-    spec_r[ 15] = 1; spec_g[ 15] = 15; spec_b[ 15] = 90;
-    spec_r[ 14] = 1; spec_g[ 14] = 13; spec_b[ 14] = 87;
-    spec_r[ 13] = 0; spec_g[ 13] = 12; spec_b[ 13] = 84;
-    spec_r[ 12] = 0; spec_g[ 12] = 11; spec_b[ 12] = 80;
-    spec_r[ 11] = 0; spec_g[ 11] = 9; spec_b[ 11] = 77;
-    spec_r[ 10] = 0; spec_g[ 10] = 8; spec_b[ 10] = 73;
-    spec_r[  9] = 0; spec_g[  9] = 7; spec_b[  9] = 70;
-    spec_r[  8] = 0; spec_g[  8] = 6; spec_b[  8] = 66;
-    spec_r[  7] = 0; spec_g[  7] = 5; spec_b[  7] = 61;
-    spec_r[  6] = 0; spec_g[  6] = 4; spec_b[  6] = 57;
-    spec_r[  5] = 0; spec_g[  5] = 3; spec_b[  5] = 52;
-    spec_r[  4] = 0; spec_g[  4] = 2; spec_b[  4] = 46;
-    spec_r[  3] = 0; spec_g[  3] = 1; spec_b[  3] = 40;
-    spec_r[  2] = 0; spec_g[  2] = 0; spec_b[  2] = 33;
-    spec_r[  1] = 0; spec_g[  1] = 0; spec_b[  1] = 23;
-    spec_r[  0] = 0; spec_g[  0] = 0; spec_b[  0] = 0;    
-}
-
-void Main_Widget::setTheme( int t )
-{
-  theme = t;
-  switch( theme ) {
-  case 1:
-    setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-    break;
-  case 2:
-    setPaletteBackgroundColor( QColor( 0, 0, 0 ) );
-    break;
-  default:
-    break;
-  }   
-}
-
-void Main_Widget::paintEvent( QPaintEvent * )
-{
-	updateLayout();	
-	plotSpectrum( spectrum_head );
-	drawPassBandScale();
+
+    settings = new QSettings("freesoftware", QString(path));
 }
 
-void Main_Widget::updateLayout()
+void Main_Widget::set_rxCMDPort(int port){
+    rxCMDPort = port;
+}
+
+void Main_Widget::set_txCMDPort(int port){
+    txCMDPort = port;
+}
+
+void Main_Widget::set_USBPort( int port)
 {
-	ctlFrame->setGeometry( 
-		1, 
-		1, 
-		width() - 2, 
-		33 );		
-	logoFrame->setGeometry( 
-		557, 
-		1, 
-		ctlFrame->width() - 558, 
-		31 );
-	logoLabel->setGeometry( 
-		logoFrame->width() - 89, 
-		0, 
-		88, 
-		31 );		
-	spectrogramFrame->setGeometry( 
-		1, 
-		35, 
-		width() - 2, 
-		height() - 18 - 36 );
-	spectrogram->setGeometry( 
-		2, 
-		2, 
-		spectrogramFrame->width() - 4, 
-		spectrogramFrame->height() - 4 - 120 - 15 );
-	pbscale->setGeometry( 
-		2, 
-		spectrogram->height() + 2, 
-		spectrogramFrame->width() - 4, 
-		15 );
-	spectrumFrame->setGeometry( 
-		2, 
-		spectrogramFrame->height() - 120 - 2, 
-		spectrogramFrame->width() - 4, 
-		120 );
-	ctlFrame2->setGeometry( 
-		1, 
-		height() - 17 - 1, 
-		width() - 2, 
-		17 );
-    CPU_label->setGeometry( 
-		ctlFrame2->width() - font1Metrics->maxWidth() * 11 - 1, 
-		1, 
-		font1Metrics->maxWidth() * 11, 
-		15 );
-    CFG_label->setGeometry( 
-		ctlFrame2->width() - CPU_label->width() - 
-		font1Metrics->maxWidth() * 4 - 2, 
-		1, 
-		font1Metrics->maxWidth() * 4, 
-		15 );
-    Spacer_label->setGeometry( 
-		AGC_label->x() + AGC_label->width() + 1, 
-		1, 
-		CFG_label->x() - (AGC_label->x() + AGC_label->width()) - 2, 
-		15 );
+    usbPort = port;
+}
 
+void Main_Widget::set_SpectrumPort( int port )
+{
+    spectrumPort = port;
 }
 
-void Main_Widget::loadSettings()
+void Main_Widget::set_MeterPort( int port )
 {
-    QSettings settings;
+    meterPort = port;
+}
 
-	// SDR-Core Environment
-	char *ep;
-	if ((ep = getenv("SDR_DEFRATE"))) {
-		sample_rate = atoi(ep);
-		printf( "sample_rate = %d\n", sample_rate );
-	} else {
-		printf( "Unable to get SDR_DEFRATE environment variable.\n"
-				"You can set SDR_DEFRATE as follows:\n"
-				"bash$ export SDR_DEFRATE=48000\n");
-		exit( 1 );
-	}
+void Main_Widget::set_SampleRate( int rate)
+{
+    sample_rate = rate;
+    //if(verbose) fprintf(stderr, "Set the sample rate to %d",sample_rate);
+}
 
+void Main_Widget::set_Host( char *ip )
+{
+    host = ip;
+}
 
-    // Open the command FIFO
-	if ((ep = getenv("SDR_PARMPATH"))) {
-		cmdFile = fopen( ep, "r+" );
-		if ( cmdFile == NULL ) {
-			perror( ep );
-			cmdFile = stdout;
-		}
-	} else {
-		printf( "::: Unable to get SDR_PARMPATH environment variable.\n"
-				"Using default: %s\n", CMD_FILE );
-		cmdFile = fopen( CMD_FILE, "r+" );
-		if ( cmdFile == NULL ) {
-			perror( CMD_FILE );
-			cmdFile = stdout;
-		}
+void Main_Widget::set_Verbose( bool flag )
+{
+    verbose = flag;
+}
+
+
+void Main_Widget::initConstants()
+{
+	// Modes
+	modeName[LSB] = new QString ( "LSB" );
+	modeName[USB] = new QString ( "USB" );
+	modeName[DSB] = new QString ( "DSB" );
+	modeName[CWL] = new QString ( "CWL" );
+	modeName[CWU] = new QString ( "CWU" );
+	modeName[FMN] = new QString ( "FMN" );
+	modeName[AM] = new QString ( "AM" );
+	modeName[DIGU] = new QString ( "DIGU" );
+	modeName[SPEC] = new QString ( "SPEC" );
+	modeName[DIGL] = new QString ( "DIGL" );
+	modeName[SAM] = new QString ( "SAM" );
+	modeName[DRM] = new QString ( "DRM" );
+
+	// S meter colors
+	s_dbm[0] = -127; signalColor[0]  = new QColor ( 40, 255, 40 );
+	s_dbm[1] = -124; signalColor[1]  = new QColor ( 40, 255, 40 );
+	s_dbm[2] = -121; signalColor[2]  = new QColor ( 40, 255, 40 ); // S1
+	s_dbm[3] = -118; signalColor[3]  = new QColor ( 40, 255, 40 );
+	s_dbm[4] = -115; signalColor[4]  = new QColor ( 40, 255, 40 ); // S2
+	s_dbm[5] = -112; signalColor[5]  = new QColor ( 40, 255, 40 );
+	s_dbm[6] = -109; signalColor[6]  = new QColor ( 40, 255, 40 ); // S3
+	s_dbm[7] = -106; signalColor[7]  = new QColor ( 40, 255, 40 );
+	s_dbm[8] = -103; signalColor[8]  = new QColor ( 40, 255, 40 ); // S4
+	s_dbm[9] = -100; signalColor[9]  = new QColor ( 40, 255, 40 );
+	s_dbm[10] = -97; signalColor[10] = new QColor ( 40, 255, 40 ); // S5
+	s_dbm[11] = -94; signalColor[11] = new QColor ( 40, 255, 40 );
+	s_dbm[12] = -91; signalColor[12] = new QColor ( 40, 255, 40 ); // S6
+	s_dbm[13] = -88; signalColor[13] = new QColor ( 40, 255, 40 );
+	s_dbm[14] = -85; signalColor[14] = new QColor ( 40, 255, 40 ); // S7
+	s_dbm[15] = -82; signalColor[15] = new QColor ( 40, 255, 40 );
+	s_dbm[16] = -79; signalColor[16] = new QColor ( 40, 255, 40 ); // S8
+	s_dbm[17] = -76; signalColor[17] = new QColor ( 40, 255, 40 );
+	s_dbm[18] = -73; signalColor[18] = new QColor ( 40, 255, 40 ); // S9
+	s_dbm[19] = -69; signalColor[19] = new QColor ( 255, 255, 40 );
+	s_dbm[20] = -65; signalColor[20] = new QColor ( 255, 255, 40 );
+	s_dbm[21] = -61; signalColor[21] = new QColor ( 255, 255, 40 );
+	s_dbm[22] = -57; signalColor[22] = new QColor ( 255, 255, 40 );
+	s_dbm[23] = -53; signalColor[23] = new QColor ( 255, 255, 40 ); // S9+20dB
+	s_dbm[24] = -49; signalColor[24] = new QColor ( 255,  70, 40 );
+	s_dbm[25] = -45; signalColor[25] = new QColor ( 255,  70, 40 );
+	s_dbm[26] = -41; signalColor[26] = new QColor ( 255,  70, 40 );
+	s_dbm[27] = -37; signalColor[27] = new QColor ( 255,  70, 40 );
+	s_dbm[28] = -33; signalColor[28] = new QColor ( 255,  70, 40 ); // S9+40dB
+	s_dbm[29] = -29; signalColor[29] = new QColor ( 255,  40, 40 );
+	s_dbm[30] = -25; signalColor[30] = new QColor ( 255,  40, 40 );
+	s_dbm[31] = -21; signalColor[31] = new QColor ( 255,  40, 40 );
+	s_dbm[32] = -17; signalColor[32] = new QColor ( 255,  40, 40 );
+	s_dbm[33] = -13; signalColor[33] = new QColor ( 255,  40, 40 ); // S9+60dB
+
+	// Spectrogram colors
+
+	spec_b[0] =  0; spec_g[0] =  0; spec_r[0] =  0;
+	spec_b[1] =  9; spec_g[1] =  1; spec_r[1] =  1;
+	spec_b[2] =  15; spec_g[2] =  1; spec_r[2] =  1;
+	spec_b[3] =  21; spec_g[3] =  1; spec_r[3] =  1;
+	spec_b[4] =  28; spec_g[4] =  1; spec_r[4] =  1;
+	spec_b[5] =  34; spec_g[5] =  1; spec_r[5] =  1;
+	spec_b[6] =  40; spec_g[6] =  0; spec_r[6] =  0;
+	spec_b[7] =  46; spec_g[7] =  0; spec_r[7] =  0;
+	spec_b[8] =  56; spec_g[8] =  0; spec_r[8] =  0;
+	spec_b[9] =  62; spec_g[9] =  1; spec_r[9] =  1;
+	spec_b[10] =  68; spec_g[10] =  1; spec_r[10] =  1;
+	spec_b[11] =  75; spec_g[11] =  0; spec_r[11] =  0;
+	spec_b[12] =  79; spec_g[12] =  0; spec_r[12] =  0;
+	spec_b[13] =  84; spec_g[13] =  0; spec_r[13] =  0;
+	spec_b[14] =  88; spec_g[14] =  0; spec_r[14] =  0;
+	spec_b[15] =  95; spec_g[15] =  0; spec_r[15] =  0;
+	spec_b[16] =  100; spec_g[16] =  3; spec_r[16] =  0;
+	spec_b[17] =  104; spec_g[17] =  8; spec_r[17] =  0;
+	spec_b[18] =  108; spec_g[18] =  13; spec_r[18] =  0;
+	spec_b[19] =  110; spec_g[19] =  18; spec_r[19] =  0;
+	spec_b[20] =  113; spec_g[20] =  23; spec_r[20] =  0;
+	spec_b[21] =  115; spec_g[21] =  28; spec_r[21] =  0;
+	spec_b[22] =  119; spec_g[22] =  35; spec_r[22] =  0;
+	spec_b[23] =  121; spec_g[23] =  40; spec_r[23] =  0;
+	spec_b[24] =  124; spec_g[24] =  45; spec_r[24] =  0;
+	spec_b[25] =  124; spec_g[25] =  50; spec_r[25] =  0;
+	spec_b[26] =  124; spec_g[26] =  55; spec_r[26] =  0;
+	spec_b[27] =  124; spec_g[27] =  60; spec_r[27] =  0;
+	spec_b[28] =  124; spec_g[28] =  65; spec_r[28] =  1;
+	spec_b[29] =  124; spec_g[29] =  72; spec_r[29] =  1;
+	spec_b[30] =  125; spec_g[30] =  77; spec_r[30] =  1;
+	spec_b[31] =  123; spec_g[31] =  82; spec_r[31] =  1;
+	spec_b[32] =  121; spec_g[32] =  87; spec_r[32] =  0;
+	spec_b[33] =  119; spec_g[33] =  92; spec_r[33] =  0;
+	spec_b[34] =  116; spec_g[34] =  97; spec_r[34] =  1;
+	spec_b[35] =  112; spec_g[35] =  102; spec_r[35] =  1;
+	spec_b[36] =  106; spec_g[36] =  110; spec_r[36] =  1;
+	spec_b[37] =  101; spec_g[37] =  112; spec_r[37] =  1;
+	spec_b[38] =  97; spec_g[38] =  115; spec_r[38] =  1;
+	spec_b[39] =  92; spec_g[39] =  118; spec_r[39] =  1;
+	spec_b[40] =  88; spec_g[40] =  121; spec_r[40] =  1;
+	spec_b[41] =  80; spec_g[41] =  124; spec_r[41] =  0;
+	spec_b[42] =  78; spec_g[42] =  127; spec_r[42] =  0;
+	spec_b[43] =  69; spec_g[43] =  131; spec_r[43] =  0;
+	spec_b[44] =  63; spec_g[44] =  134; spec_r[44] =  0;
+	spec_b[45] =  57; spec_g[45] =  137; spec_r[45] =  0;
+	spec_b[46] =  51; spec_g[46] =  140; spec_r[46] =  0;
+	spec_b[47] =  45; spec_g[47] =  143; spec_r[47] =  1;
+	spec_b[48] =  39; spec_g[48] =  146; spec_r[48] =  0;
+	spec_b[49] =  33; spec_g[49] =  149; spec_r[49] =  1;
+	spec_b[50] =  24; spec_g[50] =  152; spec_r[50] =  0;
+	spec_b[51] =  18; spec_g[51] =  154; spec_r[51] =  7;
+	spec_b[52] =  12; spec_g[52] =  156; spec_r[52] =  19;
+	spec_b[53] =  6; spec_g[53] =  158; spec_r[53] =  31;
+	spec_b[54] =  0; spec_g[54] =  160; spec_r[54] =  43;
+	spec_b[55] =  0; spec_g[55] =  160; spec_r[55] =  55;
+	spec_b[56] =  1; spec_g[56] =  160; spec_r[56] =  67;
+	spec_b[57] =  1; spec_g[57] =  160; spec_r[57] =  79;
+	spec_b[58] =  0; spec_g[58] =  160; spec_r[58] =  97;
+	spec_b[59] =  0; spec_g[59] =  160; spec_r[59] =  109;
+	spec_b[60] =  0; spec_g[60] =  159; spec_r[60] =  121;
+	spec_b[61] =  0; spec_g[61] =  157; spec_r[61] =  128;
+	spec_b[62] =  1; spec_g[62] =  155; spec_r[62] =  135;
+	spec_b[63] =  1; spec_g[63] =  154; spec_r[63] =  142;
+	spec_b[64] =  1; spec_g[64] =  152; spec_r[64] =  149;
+	spec_b[65] =  1; spec_g[65] =  148; spec_r[65] =  160;
+	spec_b[66] =  1; spec_g[66] =  145; spec_r[66] =  167;
+	spec_b[67] =  1; spec_g[67] =  142; spec_r[67] =  174;
+	spec_b[68] =  1; spec_g[68] =  139; spec_r[68] =  178;
+	spec_b[69] =  1; spec_g[69] =  136; spec_r[69] =  182;
+	spec_b[70] =  1; spec_g[70] =  133; spec_r[70] =  185;
+	spec_b[71] =  0; spec_g[71] =  131; spec_r[71] =  188;
+	spec_b[72] =  1; spec_g[72] =  126; spec_r[72] =  192;
+	spec_b[73] =  1; spec_g[73] =  123; spec_r[73] =  194;
+	spec_b[74] =  1; spec_g[74] =  120; spec_r[74] =  196;
+	spec_b[75] =  1; spec_g[75] =  117; spec_r[75] =  198;
+	spec_b[76] =  1; spec_g[76] =  112; spec_r[76] =  200;
+	spec_b[77] =  1; spec_g[77] =  107; spec_r[77] =  202;
+	spec_b[78] =  1; spec_g[78] =  102; spec_r[78] =  204;
+	spec_b[79] =  1; spec_g[79] =  94; spec_r[79] =  206;
+	spec_b[80] =  1; spec_g[80] =  89; spec_r[80] =  207;
+	spec_b[81] =  0; spec_g[81] =  84; spec_r[81] =  208;
+	spec_b[82] =  0; spec_g[82] =  79; spec_r[82] =  210;
+	spec_b[83] =  0; spec_g[83] =  74; spec_r[83] =  212;
+	spec_b[84] =  0; spec_g[84] =  69; spec_r[84] =  214;
+	spec_b[85] =  1; spec_g[85] =  64; spec_r[85] =  217;
+	spec_b[86] =  1; spec_g[86] =  56; spec_r[86] =  220;
+	spec_b[87] =  1; spec_g[87] =  51; spec_r[87] =  222;
+	spec_b[88] =  0; spec_g[88] =  46; spec_r[88] =  224;
+	spec_b[89] =  2; spec_g[89] =  41; spec_r[89] =  227;
+	spec_b[90] =  2; spec_g[90] =  35; spec_r[90] =  229;
+	spec_b[91] =  2; spec_g[91] =  32; spec_r[91] =  231;
+	spec_b[92] =  2; spec_g[92] =  29; spec_r[92] =  233;
+	spec_b[93] =  10; spec_g[93] =  25; spec_r[93] =  237;
+	spec_b[94] =  19; spec_g[94] =  21; spec_r[94] =  239;
+	spec_b[95] =  28; spec_g[95] =  28; spec_r[95] =  241;
+	spec_b[96] =  37; spec_g[96] =  37; spec_r[96] =  243;
+	spec_b[97] =  46; spec_g[97] =  46; spec_r[97] =  246;
+	spec_b[98] =  55; spec_g[98] =  55; spec_r[98] =  248;
+	spec_b[99] =  64; spec_g[99] =  64; spec_r[99] =  250;
+	spec_b[100] =  77; spec_g[100] =  77; spec_r[100] =  253;
+	spec_b[101] =  86; spec_g[101] =  86; spec_r[101] =  255;
+	spec_b[102] =  95; spec_g[102] =  95; spec_r[102] =  255;
+	spec_b[103] =  104; spec_g[103] =  104; spec_r[103] =  255;
+	spec_b[104] =  112; spec_g[104] =  112; spec_r[104] =  255;
+	spec_b[105] =  121; spec_g[105] =  121; spec_r[105] =  255;
+	spec_b[106] =  130; spec_g[106] =  130; spec_r[106] =  255;
+	spec_b[107] =  139; spec_g[107] =  139; spec_r[107] =  255;
+	spec_b[108] =  152; spec_g[108] =  152; spec_r[108] =  255;
+	spec_b[109] =  161; spec_g[109] =  161; spec_r[109] =  255;
+	spec_b[110] =  170; spec_g[110] =  170; spec_r[110] =  255;
+	spec_b[111] =  179; spec_g[111] =  179; spec_r[111] =  255;
+	spec_b[112] =  188; spec_g[112] =  188; spec_r[112] =  255;
+	spec_b[113] =  197; spec_g[113] =  197; spec_r[113] =  255;
+	spec_b[114] =  206; spec_g[114] =  206; spec_r[114] =  255;
+	spec_b[115] =  219; spec_g[115] =  219; spec_r[115] =  255;
+	spec_b[116] =  228; spec_g[116] =  228; spec_r[116] =  255;
+	spec_b[117] =  237; spec_g[117] =  237; spec_r[117] =  255;
+	spec_b[118] =  246; spec_g[118] =  246; spec_r[118] =  255;
+	spec_b[119] =  255; spec_g[119] =  255; spec_r[119] =  255;
+}
+
+void Main_Widget::setTheme ( int t )
+{
+	theme = t;
+	switch ( theme )
+	{
+		case 1:
+    setPalette( QColor( 0, 0, 0 ) );
+    this->setAutoFillBackground(true);    
+			break;
+		case 2:
+    setPalette( QColor( 0, 0, 0 ) );
+    this->setAutoFillBackground(true);    
+			break;
+		default:
+			break;
 	}
+}
 
-    // Open the meter FIFO
-	if ((ep = getenv("SDR_METERPATH"))) {
-		mtrFile = fopen( ep, "r+" );
-		if ( mtrFile == NULL ) {
-			perror( ep );
+void Main_Widget::paintEvent ( QPaintEvent * )
+{
+	if (updated) {
+        //if(verbose) fprintf( stderr, "+");
+		updateLayout();
+		if ( SPEC_state ) {
+			drawSpectrogram();			// update the spectrogram (middle) display
+			plotSpectrum( spectrum_head );	// plots the spectrum display
 		}
+		drawPassBandScale();
 	} else {
-		printf( "::: Unable to get SDR_METERPATH environment variable.\n"
-				"Using default: %s\n", MTR_FILE );
-		mtrFile = fopen( MTR_FILE, "r+" );
-		if ( mtrFile == NULL ) {
-			perror( MTR_FILE );
-		}
+        //if(verbose) fprintf( stderr, "-");
 	}
+	updated = 0;
+}
 
-    // Open the spectrum FIFO
-	if ((ep = getenv("SDR_SPECPATH"))) {
-		fftFile = fopen( ep, "r+" );
-		if ( fftFile == NULL ) {
-			perror( ep );
-		}
-	} else {
-		printf( "::: Unable to get SDR_SPECPATH environment variable.\n"
-				"Using default: %s\n", FFT_FILE );
-		fftFile = fopen( FFT_FILE, "r+" );
-		if ( fftFile == NULL ) {
-			perror( FFT_FILE );
+void Main_Widget::updateLayout()
+{
+	ctlFrame->setGeometry (
+	    1,
+	    1,
+	    width() - 2,
+	    33 );
+	logoFrame->setGeometry (
+	    755,
+	    1,
+	    ctlFrame->width() - 755,
+	    31 );
+	logoLabel->setGeometry (
+	    logoFrame->width() - 89,
+	    0,
+	    88,
+	    31 );
+	spectrogramFrame->setGeometry (
+	    1,
+	    35,
+	    width() - 2,
+	    height() - 18 - 36 );
+	spectrogram->setGeometry (
+	    2,
+	    2,
+	    spectrogramFrame->width() - 4,
+	    spectrogramFrame->height() - 4 - 120 - 15 );
+	pbscale->setGeometry (
+	    2,
+	    spectrogram->height() + 2,
+	    spectrogramFrame->width() - 4,
+	    15 );
+	spectrumFrame->setGeometry (
+	    2,
+	    spectrogramFrame->height() - 120 - 2,
+	    spectrogramFrame->width() - 4,
+	    120 );
+	ctlFrame2->setGeometry (
+	    1,
+	    height() - 17 - 1,
+	    width() - 2,
+	    17 );
+	CPU_label->setGeometry (
+	    ctlFrame2->width() - font1Metrics->maxWidth() * 11 - 1,
+	    1,
+	    font1Metrics->maxWidth() * 11,
+	    15 );
+	CFG_label->setGeometry (
+	    ctlFrame2->width() - CPU_label->width() - font1Metrics->maxWidth() * 4 - 2,
+	    1,
+	    font1Metrics->maxWidth() * 4,
+	    15 );
+	HELP_label->setGeometry (
+	    ctlFrame2->width() - CPU_label->width() - CFG_label->width() - font1Metrics->maxWidth() * 5 - 2,
+	    1,
+	    font1Metrics->maxWidth() * 5,
+	    15 );
+	Spacer_label->setGeometry (
+	    //AGC_label->x() + AGC_label->width() + 1,
+	    //Zoom_label->x() + Zoom_label->width() + 1,
+	    c_cell[(NUM_CMD-1)]->x() + c_cell[(NUM_CMD-1)]->width() + 1,
+	    1,
+	    HELP_label->x() - ( AGC_label->x() + AGC_label->width() ) - 2,
+	    15 );
+
+	spectrum_width = int(spectrumFrame->width() * hScale);
+}
+
+
+void Main_Widget::setupSDR()
+{
+    // SDR-Core Environment and Classes
+
+    char *ep;
+    if ( ( ep = getenv ( "SDR_HOST" ) )||(host != NULL) ) {
+        if (host != NULL) ep=host;
+		if (pCmd == NULL) pCmd = new DttSPcmd (verbose, rxCMDPort, ep );
+		if ( pMeter == NULL ) pMeter = new DttSPmeter (verbose, meterPort, ep );
+        pSpectrum = new DttSPspectrum (verbose, spectrumPort, ep );
+        if ( !rock_bound)
+        {
+			if ( pUSBCmd == NULL ) pUSBCmd = new USBSoftrockCmd (usbPort, ep);
+            // USB-Synth turns PTT on when it powers up.  Turn it off.
+            pUSBCmd->sendCommand ("set ptt off\n");
+        }
+		if ( enableTransmit ) pTXCmd = new DttSPTXcmd (verbose, txCMDPort, ep);
+    } else {
+		if (pCmd == NULL) pCmd = new DttSPcmd (verbose, rxCMDPort);
+		if (pMeter == NULL) pMeter = new DttSPmeter (verbose, meterPort);
+		if (pSpectrum ==NULL) pSpectrum = new DttSPspectrum (verbose, spectrumPort);
+        if ( !rock_bound )
+        {
+			if(pUSBCmd == NULL) pUSBCmd = new USBSoftrockCmd (verbose, usbPort);
+            // USB-Synth turns PTT on when it powers up.  Turn it off.
+            pUSBCmd->sendCommand("set ptt off\n");
+        }
+		if ( (enableTransmit) && (pTXCmd == NULL))
+		{
+			pTXCmd = new DttSPTXcmd (verbose, txCMDPort);
+			if (verbose) fprintf(stderr, "pTXCmd created.  Port = %d", txCMDPort);
 		}
-	}
-        
+    }
+
+    sdr_mode = NULL;
+    if ( ( ep = getenv ( "SDR_MODE" ) ) )
+    {
+        sdr_mode = ep;
+    }
+    sdr_band = NULL;
+    if ( ( ep = getenv ( "SDR_BAND" ) ) )
+    {
+        sdr_band = ep;
+    }
+    sdr_rxtx = NULL;
+    if ( ( ep = getenv ( "SDR_RXTX" ) ) )
+    {
+        sdr_rxtx = ep;
+    }
+
+    // spectrum scaling
+    spec_width = DEFSPEC;
+}
+
+void Main_Widget::loadSettings()
+{
+
+    //QSettings settings(QString( path ),"sdr-shell");
+        //settings->sync();
+        // settings->setValue("editor/wrapMargin", 68);
+        //  int margin = settings->value("editor/wrapMargin").toInt();
+        //     settings->beginGroup("MainWindow");
+        //     resize(settings->value("size", QSize(400, 400)).toSize());
+        //     move(settings->value("pos", QPoint(200, 200)).toPoint());
+        //     settings->endGroup();
+
+
+//QSettings settings("freesoftware","sdr-shell");
+
 	// Read config
-    //sample_rate = settings.readEntry( 
+        //sample_rate = settings->readEntry(
 	//	"/sdr-shell/sample_rate", "48000" ).toInt();
-    rx_f = settings.readEntry( 
-		"/sdr-shell/rx_f", "14060000" ).toLongLong();
-    rx_f_string = settings.readEntry( 
-		"/sdr-shell/rx_f", "14060000" );    
-    rx_delta_f = settings.readEntry( 
-		"/sdr-shell/rx_delta_f", "11025" ).toInt();
-    specApertureLow = settings.readEntry( 
-		"/sdr-shell/specApertureLow", "16" ).toInt();
-    specApertureHigh = settings.readEntry( 
-		"/sdr-shell/specApertureHigh", "41" ).toInt();
-    tuneStep = settings.readEntry( 
-		"/sdr-shell/tuneStep", "1" ).toInt();
-    stationCallsign = settings.readEntry( 
-		"/sdr-shell/stationCallsign", "nocall" );
-    stationQTH = settings.readEntry( 
-		"/sdr-shell/stationQTH", "AA00aa" );
-    iqGain = settings.readEntry( 
-		"/sdr-shell/iqGain", "0" ).toInt();
-    iqPhase = settings.readEntry( 
-		"/sdr-shell/iqPhase", "0" ).toInt();
-    mode = settings.readEntry( 
-		"/sdr-shell/mode", "1" ).toInt();
-    NR_state = settings.readEntry( 
-		"/sdr-shell/NR_state", "0" ).toInt();
-    ANF_state = settings.readEntry( 
-		"/sdr-shell/ANF_state", "0" ).toInt();
-    NB_state = settings.readEntry( 
-		"/sdr-shell/NB_state", "0" ).toInt();
-    BIN_state = settings.readEntry( 
-		"/sdr-shell/BIN_state", "0" ).toInt();
-    SPEC_state = settings.readEntry( 
-		"/sdr-shell/SPEC_state", "0" ).toInt();
-    filterLine = settings.readEntry( 
-		"/sdr-shell/filterLine", "0" ).toInt();
-    my_lat = settings.readEntry( 
-		"/sdr-shell/my_lat", "0" ).toDouble();
-    my_lon = settings.readEntry( 
-		"/sdr-shell/my_lon", "0" ).toDouble();
-    font1PointSize = settings.readEntry( 
-		"/sdr-shell/font1PointSize", "8" ).toInt();
-    polyphaseFFT = settings.readEntry( 
-		"/sdr-shell/polyphaseFFT", "1" ).toInt();
-    fftWindow = settings.readEntry( 
-		"/sdr-shell/fftWindow", "11" ).toInt();
-    spectrumType = settings.readEntry( 
-		"/sdr-shell/spectrumType", "0" ).toInt();
-    agcType = settings.readEntry( 
-		"/sdr-shell/agcType", "3" ).toInt();
-    specCal = settings.readEntry( 
-		"/sdr-shell/specCal", "70" ).toFloat();
-    metrCal = settings.readEntry( 
-		"/sdr-shell/metrCal", "40" ).toFloat();
-    
+    rx_f = settings->value(
+		"/sdr-shell/rx_f", 7055000 ).toLongLong();
+    rx_f_string = settings->value(
+		"/sdr-shell/rx_f", 7055000 ).toString();
+        useIF = settings->value (
+	    "/sdr-shell/useIF", "0" ).toInt();
+        useSlopeTune = settings->value (
+		"/sdr-shell/useSlopeTune", "0" ).toInt();
+        muteXmit = ( bool ) settings->value (
+		"/sdr-shell/muteXmit", "0" ).toInt();
+        rx_if = settings->value (
+	    "/sdr-shell/rx_if", "455000" ).toLongLong();
+        rx_if_string = settings->value (
+	    "/sdr-shell/rx_if", "455000" ).toString();
+    rx_delta_f = settings->value(
+		"/sdr-shell/rx_delta_f", 0 ).toInt();
+        cwPitch = settings->value (
+		"/sdr-shell/cwPitch", "600" ).toInt();
+    specApertureLow = settings->value(
+		"/sdr-shell/specApertureLow", 16 ).toInt();
+    specApertureHigh = settings->value(
+		"/sdr-shell/specApertureHigh", 41 ).toInt(); 
+    tuneStep = settings->value(
+		"/sdr-shell/tuneStep", 1 ).toInt();
+    stationCallsign = settings->value(
+		"/sdr-shell/stationCallsign", "nocall" ).toString();
+        stationQTH = settings->value (
+	    "/sdr-shell/stationQTH", "AA00aa" ).toString();
+    iqGain = settings->value(
+		"/sdr-shell/iqGain", 0 ).toInt();
+    iqPhase = settings->value(
+		"/sdr-shell/iqPhase", 0 ).toInt();
+    txIQGain = settings->value(
+		"/sdr-shell/txIQGain", 0 ).toInt();
+    txIQPhase = settings->value(
+		"/sdr-shell/txIQPhase", 0 ).toInt();
+        txGain = settings->value (
+        "/sdr-shell/txGain", "0" ).toInt();
+        micGain = settings->value (
+	    "/sdr-shell/micGain", "0" ).toInt();
+        enableTransmit = settings->value (
+	    "/sdr-shell/enableTransmit", "0" ).toInt();
+        dualConversion = settings->value (
+	    "/sdr-shell/dualConversion", "0" ).toInt();
+    mode = (rmode_t) settings->value(
+		"/sdr-shell/mode", 1 ).toInt();
+        usbOffset = settings->value (
+	    "/sdr-shell/usbOffset", "1500" ).toInt();
+        lsbOffset = settings->value (
+	    "/sdr-shell/lsbOffset", "1500" ).toInt();
+        slopeLowOffset = settings->value (
+	    "/sdr-shell/slopeLowOffset", "3500" ).toInt();
+        slopeHighOffset = settings->value (
+	    "/sdr-shell/slopeHighOffset", "3500" ).toInt();
+    NR_state = settings->value(
+		"/sdr-shell/NR_state", 0 ).toInt();
+    // NR_val settings defaults: 128, 75, 1.0, 1.0
+    NR_Taps = settings->value( 
+		"/sdr-shell/NR_Taps", 128 ).toInt();  
+    NR_Delay = settings->value( 
+		"/sdr-shell/NR_Delay", 75 ).toInt();
+    NR_Gain = settings->value( 
+		"/sdr-shell/NR_Gain", 1.0 ).toDouble();
+    NR_Leakage = settings->value( 
+		"/sdr-shell/NR_Leakage", 1.0 ).toDouble();
+    ANF_state = settings->value(
+		"/sdr-shell/ANF_state", 0 ).toInt();
+    ANF_Taps = settings->value( 
+		"/sdr-shell/ANF_Taps", 45 ).toInt();  
+    ANF_Delay = settings->value( 
+		"/sdr-shell/ANF_Delay", 64 ).toInt();
+    ANF_Gain = settings->value( 
+		"/sdr-shell/ANF_Gain", 0.01 ).toDouble();
+    ANF_Leakage = settings->value( 
+		"/sdr-shell/ANF_Leakage", 0.000010 ).toDouble();
+    NB_state = settings->value(
+		"/sdr-shell/NB_state", 0 ).toInt();
+    NB_Threshold = settings->value( 
+		"/sdr-shell/NB_Threshold", 3.3 ).toDouble();
+    BIN_state = settings->value(
+		"/sdr-shell/BIN_state", 0 ).toInt();
+    SPEC_state = settings->value(
+		"/sdr-shell/SPEC_state", 1 ).toInt();
+    filterLine = settings->value(
+		"/sdr-shell/filterLine", 0 ).toInt();
+    my_lat = settings->value (
+	    "/sdr-shell/my_lat", "0" ).toDouble();
+    my_lon = settings->value (
+	    "/sdr-shell/my_lon", "0" ).toDouble();
+    font1PointSize = settings->value(
+		"/sdr-shell/font1PointSize", 8 ).toInt();		
+    polyphaseFFT = settings->value(
+		"/sdr-shell/polyphaseFFT", 1 ).toInt();
+    fftWindow = settings->value(
+		"/sdr-shell/fftWindow", 11 ).toInt();
+    spectrumType = settings->value(
+		"/sdr-shell/spectrumType", 1 ).toInt();
+    agcType = settings->value(
+		"/sdr-shell/agcType", 3 ).toInt();
+    specCal = settings->value(
+		"/sdr-shell/specCal", 70 ).toInt();
+    metrCal = settings->value(
+		"/sdr-shell/metrCal", 40 ).toInt();
+//    hscaleIndex = settings->value(
+//		"/sdr-shell/hScale", 3 ).toInt();
+   specLineFill = settings->value(
+		"/sdr-shell/specfill", false ).toBool();
+
     // Restore window geometry
     setGeometry (
-        settings.readEntry( "/sdr-shell/g_left", "172" ).toInt(),
-        settings.readEntry( "/sdr-shell/g_top", "172" ).toInt(),
-        settings.readEntry( "/sdr-shell/g_width", "650" ).toInt(),
-        settings.readEntry( "/sdr-shell/g_height", "424" ).toInt()
-    );
-
+        settings->value( "/sdr-shell/g_left", 172 ).toInt(),
+        settings->value( "/sdr-shell/g_top", 172 ).toInt(),
+        settings->value( "/sdr-shell/g_width", 650 ).toInt(),
+        settings->value( "/sdr-shell/g_height", 424 ).toInt()
+        );
     // Restore filter values
-    USB_filter_l = settings.readEntry( 
-		"/sdr-shell/USB_filter_l", "20" ).toInt();
-    USB_filter_h = settings.readEntry( 
-		"/sdr-shell/USB_filter_h", "2400" ).toInt();
-    LSB_filter_l = settings.readEntry( 
-		"/sdr-shell/LSB_filter_l", "-2400" ).toInt();    
-	LSB_filter_h = settings.readEntry( 
-		"/sdr-shell/LSB_filter_h", "-20" ).toInt();
-    DSB_filter_l = settings.readEntry( 
-		"/sdr-shell/DSB_filter_l", "-2400" ).toInt();
-    DSB_filter_h = settings.readEntry( 
-		"/sdr-shell/DSB_filter_h", "2400" ).toInt();
-    CWL_filter_l = settings.readEntry( 
-		"/sdr-shell/CWL_filter_l", "-500" ).toInt();
-    CWL_filter_h = settings.readEntry( 
-		"/sdr-shell/CWL_filter_h", "-200" ).toInt();
-    CWU_filter_l = settings.readEntry( 
-		"/sdr-shell/CWU_filter_l", "200" ).toInt();
-    CWU_filter_h = settings.readEntry( 
-		"/sdr-shell/CWU_filter_h", "500" ).toInt();
-    SAM_filter_l = settings.readEntry( 
-		"/sdr-shell/SAM_filter_l", "-4000" ).toInt();
-    SAM_filter_h = settings.readEntry( 
+    USB_filter_l = settings->value(
+		"/sdr-shell/USB_filter_l", 20 ).toInt();
+    USB_filter_h = settings->value(
+		"/sdr-shell/USB_filter_h", 2400 ).toInt();
+    LSB_filter_l = settings->value(
+		"/sdr-shell/LSB_filter_l", -2400 ).toInt();    
+    LSB_filter_h = settings->value(
+		"/sdr-shell/LSB_filter_h", -20 ).toInt();
+    DSB_filter_l = settings->value(
+		"/sdr-shell/DSB_filter_l", -2400 ).toInt();
+    DSB_filter_h = settings->value(
+		"/sdr-shell/DSB_filter_h", 2400 ).toInt();
+    CWL_filter_l = settings->value(
+		"/sdr-shell/CWL_filter_l", -500 ).toInt();
+    CWL_filter_h = settings->value(
+		"/sdr-shell/CWL_filter_h", -200 ).toInt();
+    CWU_filter_l = settings->value(
+		"/sdr-shell/CWU_filter_l", 200 ).toInt();
+    CWU_filter_h = settings->value(
+		"/sdr-shell/CWU_filter_h", 500 ).toInt();
+    SAM_filter_l = settings->value(
+		"/sdr-shell/SAM_filter_l", -4000 ).toInt();
+    SAM_filter_h = settings->value(
 		"/sdr-shell/SAM_filter_h", "4000" ).toInt();
-    FMN_filter_l = settings.readEntry( 
-		"/sdr-shell/FMN_filter_l", "-4000" ).toInt();
-    FMN_filter_h = settings.readEntry( 
-		"/sdr-shell/FMN_filter_h", "4000" ).toInt();
-    AM_filter_l = settings.readEntry( 
-		"/sdr-shell/AM_filter_l", "-2400" ).toInt();
-    AM_filter_h = settings.readEntry( 
-		"/sdr-shell/AM_filter_h", "2400" ).toInt();
+    FMN_filter_l = settings->value(
+		"/sdr-shell/FMN_filter_l", -4000 ).toInt();
+    FMN_filter_h = settings->value(
+		"/sdr-shell/FMN_filter_h", 4000 ).toInt();
+    AM_filter_l = settings->value(
+		"/sdr-shell/AM_filter_l", -2400 ).toInt();
+    AM_filter_h = settings->value(
+		"/sdr-shell/AM_filter_h", 2400 ).toInt();
+    useHamlib = settings->value (
+	    "/sdr-shell/useHamlib", "0" ).toInt();
+    rigString = settings->value (
+	    "/sdr-shell/hamlib_rig", "1901" ).toString();
+	rig = rigString.toInt();
+        portString =  settings->value (
+	    "/sdr-shell/hamlib_port", "localhost" ).toString();
+    //   hl_port =  qPrintable(settings->value (
+          //  "/sdr-shell/hamlib_port", "localhost" ).toString());
+        speedString = settings->value (
+	    "/sdr-shell/hamlib_speed", "4800" ).toString();
+	speed = speedString.toInt();
+    rock_bound = ( bool ) settings->value (
+			  "/sdr-shell/rock_bound", "false" ).toInt();
 
 	map_flag = 1;
 
-	printf( "::: Configuration loading completed\n" );
+    if(verbose) fprintf (stderr, "::: Configuration loading completed\n" );
 }
 
 void Main_Widget::loadMemoryCells()
 {
-    QSettings settings;
+        //QSettings settings("freesoftware", "sdr-shell");
 
 	// Restore memory cells
-	f1_cell->setFrequency( 
-		settings.readEntry( "/sdr-shell/f1_frequency", "0" ).toInt() );
-	f1_cell->setMode( 
-		settings.readEntry( "/sdr-shell/f1_mode", "1" ).toInt() );
-	f1_cell->setFilter( 
-		settings.readEntry( "/sdr-shell/f1_filter_l", "20" ).toInt(),
-		settings.readEntry( "/sdr-shell/f1_filter_h", "2400" ).toInt() );
-							   
-	f2_cell->setFrequency( 
-		settings.readEntry( "/sdr-shell/f2_frequency", "0" ).toInt() );
-	f2_cell->setMode( 
-		settings.readEntry( "/sdr-shell/f2_mode", "1" ).toInt() );
-	f2_cell->setFilter( 
-		settings.readEntry( "/sdr-shell/f2_filter_l", "20" ).toInt(),
-		settings.readEntry( "/sdr-shell/f2_filter_h", "2400" ).toInt() );
-							   
-	f3_cell->setFrequency( 
-		settings.readEntry( "/sdr-shell/f3_frequency", "0" ).toInt() );
-	f3_cell->setMode( 
-		settings.readEntry( "/sdr-shell/f3_mode", "1" ).toInt() );
-	f3_cell->setFilter( 
-		settings.readEntry( "/sdr-shell/f3_filter_l", "20" ).toInt(),
-		settings.readEntry( "/sdr-shell/f3_filter_h", "2400" ).toInt() );
-							   
-	f4_cell->setFrequency( 
-		settings.readEntry( "/sdr-shell/f4_frequency", "0" ).toInt() );
-	f4_cell->setMode( 
-		settings.readEntry( "/sdr-shell/f4_mode", "1" ).toInt() );
-	f4_cell->setFilter( 
-		settings.readEntry( "/sdr-shell/f4_filter_l", "20" ).toInt(),
-		settings.readEntry( "/sdr-shell/f4_filter_h", "2400" ).toInt() );
-							   
-	f5_cell->setFrequency( 
-		settings.readEntry( "/sdr-shell/f5_frequency", "0" ).toInt() );
-	f5_cell->setMode( 
-		settings.readEntry( "/sdr-shell/f5_mode", "1" ).toInt() );
-	f5_cell->setFilter( 
-		settings.readEntry( "/sdr-shell/f5_filter_l", "20" ).toInt(),
-		settings.readEntry( "/sdr-shell/f5_filter_h", "2400" ).toInt() );
-							   
-	f6_cell->setFrequency( 
-		settings.readEntry( "/sdr-shell/f6_frequency", "0" ).toInt() );
-	f6_cell->setMode( 
-		settings.readEntry( "/sdr-shell/f6_mode", "1" ).toInt() );
-	f6_cell->setFilter( 
-		settings.readEntry( "/sdr-shell/f6_filter_l", "20" ).toInt(),
-		settings.readEntry( "/sdr-shell/f6_filter_h", "2400" ).toInt() );
-							   
-	f7_cell->setFrequency( 
-		settings.readEntry( "/sdr-shell/f7_frequency", "0" ).toInt() );
-	f7_cell->setMode( 
-		settings.readEntry( "/sdr-shell/f7_mode", "1" ).toInt() );
-	f7_cell->setFilter( 
-		settings.readEntry( "/sdr-shell/f7_filter_l", "20" ).toInt(),
-		settings.readEntry( "/sdr-shell/f7_filter_h", "2400" ).toInt() );
-							   
-	f8_cell->setFrequency( 
-		settings.readEntry( "/sdr-shell/f8_frequency", "0" ).toInt() );
-	f8_cell->setMode( 
-		settings.readEntry( "/sdr-shell/f8_mode", "1" ).toInt() );
-	f8_cell->setFilter( 
-		settings.readEntry( "/sdr-shell/f8_filter_l", "20" ).toInt(),
-		settings.readEntry( "/sdr-shell/f8_filter_h", "2400" ).toInt() );
+	for(int i=0; i<NUM_MEMS; i++) {
+	  char buffer[256], buffer2[256];
+	  snprintf(buffer, 256, "/sdr-shell/f%d_frequency", i+1);
+          f_cell[i]->setFrequency(settings->value(buffer, "10000000").toInt());
+	  snprintf(buffer, 256, "/sdr-shell/f%d_txfrequency", i+1);
+          f_cell[i]->setTxFrequency(settings->value(buffer, "0").toInt());
+	  snprintf(buffer, 256, "/sdr-shell/f%d_mode", i+1);
+          f_cell[i]->setMode((rmode_t)settings->value(buffer, "1").toInt());
+	  snprintf(buffer, 256, "/sdr-shell/f%d_filter_l", i+1);
+	  snprintf(buffer2, 256, "/sdr-shell/f%d_filter_h", i+1);
+          f_cell[i]->setFilter(settings->value(buffer, "20").toInt(),
+                               settings->value(buffer2, "2400").toInt());
+	}
+
+	for (int i=0; i<NUM_BANDMEMS; i++) {
+	  char buffer[256], buffer2[256];
+	  snprintf(buffer, 256, "/sdr-shell/b%d_frequency", i+1);
+          band_cell[i]->setFrequency(settings->value(buffer, "10000000").toInt());
+	  snprintf(buffer, 256, "/sdr-shell/b%d_txfrequency", i+1);
+          band_cell[i]->setTxFrequency(settings->value(buffer, "0").toInt());
+	  snprintf(buffer, 256, "/sdr-shell/b%d_mode", i+1);
+          band_cell[i]->setMode((rmode_t)settings->value(buffer, "1").toInt());
+	  snprintf(buffer, 256, "/sdr-shell/b%d_filter_l", i+1);
+	  snprintf(buffer2, 256, "/sdr-shell/b%d_filter_h", i+1);
+          band_cell[i]->setFilter(settings->value(buffer, "20" ).toInt(),
+                              settings->value(buffer2, "2400" ).toInt() );
+	}
 
-	printf( "::: Memory Cells loading completed\n" );
+        //printf ( "::: Memory Cells loading completed\n" );
+}
+
+void Main_Widget::loadCommandCells()
+{
+	for (int i=0; i<NUM_CMD; i++) {
+		char buffer[256];
+		snprintf(buffer, 256, "/sdr-shell/c%d_name", i);
+                c_cell[i]->setName(settings->value(buffer, "Cx").toString());
+		snprintf(buffer, 256, "/sdr-shell/c%d_On", i);
+                c_cell[i]->setOnCommand(settings->value(buffer, "no-op").toString());
+		snprintf(buffer, 256, "/sdr-shell/c%d_Off", i);
+                c_cell[i]->setOffCommand(settings->value(buffer, "no-op").toString());
+		snprintf(buffer, 256, "/sdr-shell/c%d_Targets", i);
+                c_cell[i]->setTargets(settings->value(buffer, "0").toString());
+		c_cell[i]->setText ( c_cell[i]->getName() );
+	}
 }
 
 
-void Main_Widget::closeEvent( QCloseEvent * )
+void Main_Widget::closeEvent ( QCloseEvent * )
 {
-    finish();
+	finish();
 }
 
 void Main_Widget::saveSettings()
 {
-    QSettings settings;
 
-    printf( "Saving settings...\n" );
-    
-    settings.setPath( "n1vtn.org", ".qt", QSettings::User );
-    //settings.writeEntry( "/sdr-shell/sample_rate", sample_rate );
-    settings.writeEntry( "/sdr-shell/rx_f", rx_f_string );
-    settings.writeEntry( "/sdr-shell/rx_delta_f", rx_delta_f );
-    settings.writeEntry( "/sdr-shell/specApertureLow", specApertureLow );
-    settings.writeEntry( "/sdr-shell/specApertureHigh", specApertureHigh );
-    settings.writeEntry( "/sdr-shell/tuneStep", tuneStep );
-    settings.writeEntry( "/sdr-shell/stationCallsign", stationCallsign );
-    settings.writeEntry( "/sdr-shell/stationQTH", stationQTH );
-    settings.writeEntry( "/sdr-shell/iqGain", iqGain );
-    settings.writeEntry( "/sdr-shell/iqPhase", iqPhase );
-    settings.writeEntry( "/sdr-shell/mode", mode );
-    settings.writeEntry( "/sdr-shell/NR_state", NR_state );
-    settings.writeEntry( "/sdr-shell/ANF_state", ANF_state );
-    settings.writeEntry( "/sdr-shell/NB_state", NB_state );
-    settings.writeEntry( "/sdr-shell/BIN_state", BIN_state );
-    settings.writeEntry( "/sdr-shell/SPEC_state", SPEC_state );
-    settings.writeEntry( "/sdr-shell/filterLine", filterLine );
-    settings.writeEntry( "/sdr-shell/my_lat", my_lat );
-    settings.writeEntry( "/sdr-shell/my_lon", my_lon );
-    settings.writeEntry( "/sdr-shell/font1PointSize", font1PointSize );
-    settings.writeEntry( "/sdr-shell/polyphaseFFT", polyphaseFFT );
-    settings.writeEntry( "/sdr-shell/fftWindow", fftWindow );
-    settings.writeEntry( "/sdr-shell/spectrumType", spectrumType );
-    settings.writeEntry( "/sdr-shell/agcType", agcType );
-    settings.writeEntry( "/sdr-shell/specCal", specCal );
-    settings.writeEntry( "/sdr-shell/metrCal", metrCal );
-    
-    // Save window geometry
-    settings.writeEntry( "/sdr-shell/g_left", geometry().left() );
-    settings.writeEntry( "/sdr-shell/g_top", geometry().top() );
-    settings.writeEntry( "/sdr-shell/g_width", geometry().width() );
-    settings.writeEntry( "/sdr-shell/g_height", geometry().height() );
-
-    // Save filter values
-    settings.writeEntry( "/sdr-shell/USB_filter_l", USB_filter_l );
-    settings.writeEntry( "/sdr-shell/USB_filter_h", USB_filter_h );
-    settings.writeEntry( "/sdr-shell/LSB_filter_l", LSB_filter_l );
-    settings.writeEntry( "/sdr-shell/LSB_filter_h", LSB_filter_h );
-    settings.writeEntry( "/sdr-shell/DSB_filter_l", DSB_filter_l );
-    settings.writeEntry( "/sdr-shell/DSB_filter_h", DSB_filter_h );
-    settings.writeEntry( "/sdr-shell/CWL_filter_l", CWL_filter_l );
-    settings.writeEntry( "/sdr-shell/CWL_filter_h", CWL_filter_h );
-    settings.writeEntry( "/sdr-shell/CWU_filter_l", CWU_filter_l );
-    settings.writeEntry( "/sdr-shell/CWU_filter_h", CWU_filter_h );
-    settings.writeEntry( "/sdr-shell/SAM_filter_l", SAM_filter_l );
-    settings.writeEntry( "/sdr-shell/SAM_filter_h", SAM_filter_h );
-    settings.writeEntry( "/sdr-shell/FMN_filter_l", FMN_filter_l );
-    settings.writeEntry( "/sdr-shell/FMN_filter_h", FMN_filter_h );
-    settings.writeEntry( "/sdr-shell/AM_filter_l", AM_filter_l );
-    settings.writeEntry( "/sdr-shell/AM_filter_h", AM_filter_h );
+        if(verbose) fprintf (stderr, "Saving settings->..\n" );
+
+        //settings->setPath ( "n1vtn.org", ".qt", QSettings::User );
+        //settings->setValue( "/sdr-shell/sample_rate", sample_rate );
+	rx_f_string.setNum(rx_f);
+        settings->setValue ( "/sdr-shell/rx_f", rx_f_string );
+	rx_if_string.setNum(rx_if);
+        settings->setValue ( "/sdr-shell/rx_if", rx_if_string );
+	int intUseIF = ( int ) useIF;
+        settings->setValue ( "/sdr-shell/useIF", intUseIF );
+	int intUseSlopeTune = ( int ) useSlopeTune;
+        settings->setValue ( "/sdr-shell/useSlopeTune", intUseSlopeTune );
+	int intMuteXmit = ( int ) muteXmit;
+        settings->setValue ( "/sdr-shell/useSlopeTune", intMuteXmit );
+        settings->setValue ( "/sdr-shell/cwPitch", cwPitch );
+        settings->setValue ( "/sdr-shell/rx_delta_f", rx_delta_f );
+        settings->setValue ( "/sdr-shell/specApertureLow", specApertureLow );
+        settings->setValue ( "/sdr-shell/specApertureHigh", specApertureHigh );
+        settings->setValue ( "/sdr-shell/tuneStep", tuneStep );
+        settings->setValue ( "/sdr-shell/stationCallsign", stationCallsign );
+        settings->setValue ( "/sdr-shell/stationQTH", stationQTH );
+        settings->setValue ( "/sdr-shell/iqGain", iqGain );
+        settings->setValue ( "/sdr-shell/iqPhase", iqPhase );
+        settings->setValue ( "/sdr-shell/txIQGain", txIQGain );
+        settings->setValue ( "/sdr-shell/txIQPhase", txIQPhase );
+        settings->setValue ( "/sdr-shell/txGain", txGain );
+        settings->setValue ( "/sdr-shell/micGain", micGain );
+	int intEnableTransmit = ( int ) enableTransmit;
+        settings->setValue ( "/sdr-shell/enableTransmit", intEnableTransmit );
+        settings->setValue ( "/sdr-shell/dualConversion", dualConversion );
+        settings->setValue ( "/sdr-shell/mode", ( int ) mode );
+        settings->setValue ( "/sdr-shell/NR_state", NR_state );
+        settings->setValue ( "/sdr-shell/ANF_state", ANF_state );
+        settings->setValue ( "/sdr-shell/NB_state", NB_state );
+        settings->setValue ( "/sdr-shell/BIN_state", BIN_state );
+        settings->setValue ( "/sdr-shell/SPEC_state", SPEC_state );
+        settings->setValue ( "/sdr-shell/filterLine", filterLine );
+        settings->setValue ( "/sdr-shell/my_lat", my_lat );
+        settings->setValue ( "/sdr-shell/my_lon", my_lon );
+        settings->setValue ( "/sdr-shell/font1PointSize", font1PointSize );
+        settings->setValue ( "/sdr-shell/polyphaseFFT", polyphaseFFT );
+        settings->setValue ( "/sdr-shell/fftWindow", fftWindow );
+        settings->setValue ( "/sdr-shell/spectrumType", spectrumType );
+        settings->setValue ( "/sdr-shell/agcType", agcType );
+        settings->setValue ( "/sdr-shell/specCal", specCal );
+        settings->setValue ( "/sdr-shell/metrCal", metrCal );
+
+	// Save window geometry
+        settings->setValue ( "/sdr-shell/g_left", geometry().left() );
+        settings->setValue ( "/sdr-shell/g_top", geometry().top() );
+        settings->setValue ( "/sdr-shell/g_width", geometry().width() );
+        settings->setValue ( "/sdr-shell/g_height", geometry().height() );
+
+	// Save filter values
+        settings->setValue ( "/sdr-shell/USB_filter_l", USB_filter_l );
+        settings->setValue ( "/sdr-shell/USB_filter_h", USB_filter_h );
+        settings->setValue ( "/sdr-shell/LSB_filter_l", LSB_filter_l );
+        settings->setValue ( "/sdr-shell/LSB_filter_h", LSB_filter_h );
+        settings->setValue ( "/sdr-shell/DSB_filter_l", DSB_filter_l );
+        settings->setValue ( "/sdr-shell/DSB_filter_h", DSB_filter_h );
+        settings->setValue ( "/sdr-shell/CWL_filter_l", CWL_filter_l );
+        settings->setValue ( "/sdr-shell/CWL_filter_h", CWL_filter_h );
+        settings->setValue ( "/sdr-shell/CWU_filter_l", CWU_filter_l );
+        settings->setValue ( "/sdr-shell/CWU_filter_h", CWU_filter_h );
+        settings->setValue ( "/sdr-shell/SAM_filter_l", SAM_filter_l );
+        settings->setValue ( "/sdr-shell/SAM_filter_h", SAM_filter_h );
+        settings->setValue ( "/sdr-shell/FMN_filter_l", FMN_filter_l );
+        settings->setValue ( "/sdr-shell/FMN_filter_h", FMN_filter_h );
+        settings->setValue ( "/sdr-shell/AM_filter_l", AM_filter_l );
+        settings->setValue ( "/sdr-shell/AM_filter_h", AM_filter_h );
 
 	// Save memory cells
 	QString f_string;
 
-	f_string.sprintf( "%lld", f1_cell->getFrequency() ); 
-    settings.writeEntry( "/sdr-shell/f1_frequency", f_string );
-    settings.writeEntry( "/sdr-shell/f1_mode", f1_cell->getMode() );
-    settings.writeEntry( "/sdr-shell/f1_filter_l", f1_cell->getFilter_l() );
-    settings.writeEntry( "/sdr-shell/f1_filter_h", f1_cell->getFilter_h() );
-
-	f_string.sprintf( "%lld", f2_cell->getFrequency() ); 
-    settings.writeEntry( "/sdr-shell/f2_frequency", f_string );
-    settings.writeEntry( "/sdr-shell/f2_mode", f2_cell->getMode() );
-    settings.writeEntry( "/sdr-shell/f2_filter_l", f2_cell->getFilter_l() );
-    settings.writeEntry( "/sdr-shell/f2_filter_h", f2_cell->getFilter_h() );
-
-	f_string.sprintf( "%lld", f3_cell->getFrequency() ); 
-    settings.writeEntry( "/sdr-shell/f3_frequency", f_string );
-    settings.writeEntry( "/sdr-shell/f3_mode", f3_cell->getMode() );
-    settings.writeEntry( "/sdr-shell/f3_filter_l", f3_cell->getFilter_l() );
-    settings.writeEntry( "/sdr-shell/f3_filter_h", f3_cell->getFilter_h() );
-
-	f_string.sprintf( "%lld", f4_cell->getFrequency() ); 
-    settings.writeEntry( "/sdr-shell/f4_frequency", f_string );
-    settings.writeEntry( "/sdr-shell/f4_mode", f4_cell->getMode() );
-    settings.writeEntry( "/sdr-shell/f4_filter_l", f4_cell->getFilter_l() );
-    settings.writeEntry( "/sdr-shell/f4_filter_h", f4_cell->getFilter_h() );
-
-	f_string.sprintf( "%lld", f5_cell->getFrequency() ); 
-    settings.writeEntry( "/sdr-shell/f5_frequency", f_string );
-    settings.writeEntry( "/sdr-shell/f5_mode", f5_cell->getMode() );
-    settings.writeEntry( "/sdr-shell/f5_filter_l", f5_cell->getFilter_l() );
-    settings.writeEntry( "/sdr-shell/f5_filter_h", f5_cell->getFilter_h() );
-
-	f_string.sprintf( "%lld", f6_cell->getFrequency() ); 
-    settings.writeEntry( "/sdr-shell/f6_frequency", f_string );
-    settings.writeEntry( "/sdr-shell/f6_mode", f6_cell->getMode() );
-    settings.writeEntry( "/sdr-shell/f6_filter_l", f6_cell->getFilter_l() );
-    settings.writeEntry( "/sdr-shell/f6_filter_h", f6_cell->getFilter_h() );
-
-	f_string.sprintf( "%lld", f7_cell->getFrequency() ); 
-    settings.writeEntry( "/sdr-shell/f7_frequency", f_string );
-    settings.writeEntry( "/sdr-shell/f7_mode", f7_cell->getMode() );
-    settings.writeEntry( "/sdr-shell/f7_filter_l", f7_cell->getFilter_l() );
-    settings.writeEntry( "/sdr-shell/f7_filter_h", f7_cell->getFilter_h() );
-
-	f_string.sprintf( "%lld", f8_cell->getFrequency() ); 
-    settings.writeEntry( "/sdr-shell/f8_frequency", f_string );
-    settings.writeEntry( "/sdr-shell/f8_mode", f8_cell->getMode() );
-    settings.writeEntry( "/sdr-shell/f8_filter_l", f8_cell->getFilter_l() );
-    settings.writeEntry( "/sdr-shell/f8_filter_h", f8_cell->getFilter_h() );
+	for (int i=0; i<NUM_MEMS; i++) {
+	  char buffer[256];
+
+	  snprintf(buffer, 256, "/sdr-shell/f%d_frequency", i+1);
+	  f_string.sprintf("%lld", f_cell[i]->getFrequency());
+          settings->setValue (buffer, f_string);
+
+	  snprintf(buffer, 256, "/sdr-shell/f%d_mode", i+1);
+          settings->setValue(buffer, f_cell[i]->getMode());
+
+	  snprintf(buffer, 256, "/sdr-shell/f%d_filter_l", i+1);
+          settings->setValue(buffer, f_cell[i]->getFilter_l());
+
+	  snprintf(buffer, 256, "/sdr-shell/f%d_filter_h", i+1);
+          settings->setValue(buffer, f_cell[i]->getFilter_h());
+	}
+
+	for (int i=0; i<NUM_BANDMEMS; i++) {
+	  char buffer[256];
+
+	  snprintf(buffer, 256, "/sdr-shell/b%d_frequency", i+1);
+	  f_string.sprintf("%lld", band_cell[i]->getFrequency());
+          settings->setValue (buffer, f_string );
+
+	  if (band_cell[i]->getTxFrequency() != 0) {
+	    snprintf(buffer, 256, "/sdr-shell/b%d_txfrequency", i+1);
+	    f_string.sprintf("%lld", band_cell[i]->getTxFrequency());
+            settings->setValue(buffer, f_string );
+	  }
+
+	  snprintf(buffer, 256, "/sdr-shell/b%d_mode", i+1);
+          settings->setValue (buffer, band_cell[i]->getMode() );
+
+
+	  snprintf(buffer, 256, "/sdr-shell/b%d_filter_l", i+1);
+          settings->setValue(buffer, band_cell[i]->getFilter_l() );
+
+	  snprintf(buffer, 256, "/sdr-shell/b%d_filter_h", i+1);
+          settings->setValue(buffer, band_cell[i]->getFilter_h() );
+	}
+
+        settings->setValue ( "/sdr-shell/hamlib_rig", rigString );
+        settings->setValue ( "/sdr-shell/useHamlib", (int) useHamlib );
+        settings->setValue ( "/sdr-shell/hamlib_port", portString );
+        settings->setValue ( "/sdr-shell/hamlib_speed", speedString );
+        settings->setValue ( "/sdr-shell/usbOffset", usbOffset );
+        settings->setValue ( "/sdr-shell/lsbOffset", lsbOffset );
+        settings->setValue ( "/sdr-shell/slopeLowOffset", slopeLowOffset );
+        settings->setValue ( "/sdr-shell/slopeHighOffset", slopeHighOffset );
+        settings->setValue ( "/sdr-shell/rock_bound", (int) rock_bound );
+        settings->sync();
+
+	for (int i=0; i<NUM_CMD; i++) {
+	  char buffer[256];
+
+	  snprintf(buffer, 256, "/sdr-shell/c%d_name", i);
+          settings->setValue (buffer, c_cell[i]->getName() );
+	  snprintf(buffer, 256, "/sdr-shell/c%d_On", i);
+          settings->setValue (buffer, c_cell[i]->getOnCommand() );
+	  snprintf(buffer, 256, "/sdr-shell/c%d_Off", i);
+          settings->setValue (buffer, c_cell[i]->getOffCommand() );
+	  snprintf(buffer, 256, "/sdr-shell/c%d_Targets", i);
+          settings->setValue (buffer, c_cell[i]->getTo() );
+	}
+
 }
 
 void Main_Widget::finish()
 {
-    saveSettings();
-    exit( 0 );
+	saveSettings();
+	 //
+    // terminate the sdr-core
+    //
+    delete pSpectrum;
+    delete pMeter;
+    delete pCmd;
+    if(pUSBCmd != NULL) delete pUSBCmd;
+    if(pTXCmd != NULL) delete pTXCmd;
+    if(verbose) fprintf (stderr, "sdr-shell exiting.\n");
+	exit ( 0 );
+}
+
+void Main_Widget::keyPressEvent ( QKeyEvent * e )
+{
+	static int state = 0;
+
+	//printf("k %d\n", e->key());
+
+	switch ( e->key() )
+	{
+		 case Qt::Key_Shift:
+			switch ( e->key() )
+			{
+				case 82: state = RX_F; break;
+				case 84: state = TX_F; break;
+					//case 72: state = FILTER_H; break;
+					//case 76: state = FILTER_L; break;
+				default: break;
+			}
+			break;
+        case Qt::Key_Alt:
+			switch ( e->key() )
+			{
+				case 65: setMode ( RIG_MODE_AM , FALSE, FALSE ); break; // a
+				case 76: setMode ( RIG_MODE_LSB , FALSE, FALSE ); break; // l
+				case 85: setMode ( RIG_MODE_USB, FALSE, FALSE ); break; // u
+				default: break;
+			}
+			break;
+		default:
+			process_key ( e->key() );
+			break;
+	}
+
+	//printf("Key %d %d %d\n", e->key(), e->state(), Qt::AltButton );
+	switch ( state )
+	{
+		case RX_F: rx_cmd ( e->key() ); break;
+		default: break;
+	}
 }
 
-void Main_Widget::keyPressEvent( QKeyEvent * e )
+void Main_Widget::rx_cmd ( int key ) // Leave for IF shift now.
 {
-    static int state = 0;
-   
-    //printf("k %d\n", e->key());
+	switch ( key )
+	{
+        case Qt::Key_Down: // Down arrow
+		case 76: // l
+			setTuneStep ( tuneStep - 1 );
+			break;
+        case Qt::Key_Left: // Left arrow
+		case 74: // j
+            if(verbose) fprintf ( stderr, "Left arrow rx_delta_f is: %d.\n",rx_delta_f);
+			if ( rock_bound )
+			{
+				if ( rx_delta_f < sample_rate / 2 - 2000 )  //rx_delta_f > 0 when you tune down!
+					rx_delta_f = rx_delta_f + ( int ) pow ( 10, tuneStep );
+				else
+				  rx_delta_f =  ( sample_rate / 2 - 2000 );
+				setRxFrequency( 0 );
+			} else {
+				rx_f -= rx_delta_f;
+				rx_delta_f = tuneCenter;
+				rx_f = rx_f - (int) pow ( 10, tuneStep );
+				rx_f += rx_delta_f;
+
+				// Round to tuneStep
+				//rx_f = (rx_f-rx_delta_f) / (int) pow ( 10, tuneStep );
+				//rx_f = rx_f * (int) pow ( 10, tuneStep ) + rx_delta_f;
+
+				// disable RIT when tuning with the arrow keys.
+				if (enableRIT)
+					set_RIT( 0 );
+				setRxFrequency( 1 );
+			}
+			break;
+        case Qt::Key_Up: // Up arrow
+		case 72: // h
+			setTuneStep ( tuneStep + 1 );
+			break;
+        case Qt::Key_Right: // Right arrow
+		case 75:  // k
+            if(verbose) fprintf ( stderr, "Right arrow rx_delta_f is: %d.\n",rx_delta_f);
+			if ( rock_bound )
+			{
+				if ( rx_delta_f > -( sample_rate / 2 - 2000 ) )  //rx_delta_f < 0 when you tune up!
+					rx_delta_f = rx_delta_f - ( int ) pow ( 10, tuneStep );
+				else
+				  rx_delta_f = - ( sample_rate / 2 - 2000 );
+				setRxFrequency( 0 );
+			} else {
+				rx_f -= rx_delta_f;
+				rx_delta_f = tuneCenter;
+				rx_f = rx_f + (int) pow ( 10, tuneStep );
+				rx_f += rx_delta_f;
+
+				// Round to tuneStep
+				//rx_f = (rx_f-rx_delta_f) / (int) pow ( 10, tuneStep );
+				//rx_f = rx_f * (int) pow ( 10, tuneStep ) + rx_delta_f;
+
+				// reset RIT when tuning with the arrow keys
+				if (enableRIT)
+					set_RIT( 0 );
+				setRxFrequency( 1 );
+			}
+			break;
+		case 4118:	// Page Up
+			// ^F = 4129 (ctl) 70
+		case 4119:	// Page Down
+			// ^B = 4129 (ctl) 66
+			// spectrogram->width()
+            if(verbose) fprintf(stderr, "width = %d\n", width());
+			break;
+		case 71: //g
+			if (useIF)
+			{
+			  setDefaultRxFrequency();
+			}
+			break;
+		case '1':
+			hScale=1.0;
+			break;
+		case '2':
+			hScale=2.0;
+			break;
+		case '3':
+			hScale=3.0;
+			break;
+		case '4':
+			hScale = sample_rate / (bin_bw * (geometry().width()-20)); // spectrumFrame->width());
+			break;
+		case '0':
+			hScale = 0.25;
+			break;
+		case '9':
+			hScale = 0.5;
+			break;
+		case '8':
+			hScale = 0.75;
+			break;
+		case 4096:
+			finish();
+			break;
+		default:
+			//printf("k %d\n", key);
+			break;
+	}
+}
+
 
-    switch ( e->state() ) {
-        case Qt::ShiftButton:
-            switch ( e->key() ) {
-                case 82: state = RX_F; break;
-                case 84: state = TX_F; break;
-                //case 72: state = FILTER_H; break;
-                //case 76: state = FILTER_L; break;
-                default: break;
-            }
-            break;
-        case Qt::AltButton:
-            switch ( e->key() ) {
-                case 65: setMode( AM ); break; // a
-                case 76: setMode( LSB ); break; // l
-                case 85: setMode( USB ); break; // u
-                default: break;
-            }
-            break;
-        default:
-            process_key( e->key() );
-            break;
-    }
-   
-    //printf("Key %d %d %d\n", e->key(), e->state(), Qt::AltButton );
-    switch( state ) {
-        case RX_F: rx_cmd( e->key() ); break;
-        default: break;
-    }   
-   
 
+
+void Main_Widget::process_key ( int key )
+{
+	int step;
+
+	step = 10;
+
+	switch ( key )
+	{
+		case 85: // U
+			setFilter_l ( -1 );
+			break;
+		case 73: // I
+			setFilter_l ( +1 );
+			break;
+		case 79: // O
+			setFilter_h ( -1 );
+			break;
+		case 80: // P
+			setFilter_h ( +1 );
+			break;
+		case 91: // [
+			*filter_h -= step;
+			*filter_l -= step;
+			setFilter();
+			break;
+		case 93: // [
+			*filter_h += step;
+			*filter_l += step;
+			setFilter();
+			break;
+		case 81: // q
+			if ( iqGain > -5000 ) iqGain--;
+			cfgIQGainInput->setValue ( iqGain );
+			setIQGain();
+			break;
+		case 87: // w
+			if ( iqGain < 5000 ) iqGain++;
+			cfgIQGainInput->setValue ( iqGain );
+			setIQGain();
+			break;
+		case 69: // e
+			if ( iqPhase > -5000 ) iqPhase--;
+			cfgIQPhaseInput->setValue ( iqPhase );
+			setIQPhase();
+			break;
+		case 82: // r
+			if ( iqPhase < 5000 ) iqPhase++;
+			cfgIQPhaseInput->setValue ( iqPhase );
+			setIQPhase();
+			break;
+		case 90: // z
+			if ( specApertureLow > 0 )
+				specApertureLow = specApertureLow - 1;
+			setCA_label();
+			break;
+		case 88: // x
+			if ( specApertureLow < 120 &&
+			        specApertureLow < specApertureHigh - 10 )
+				specApertureLow = specApertureLow + 1;
+			setCA_label();
+			break;
+		case 67: // c
+			if ( specApertureHigh > 0 &&
+			        specApertureHigh > specApertureLow + 10 )
+				specApertureHigh = specApertureHigh - 1;
+			setCA_label();
+			break;
+		case 86: // v
+			if ( specApertureHigh < 120 )
+				specApertureHigh = specApertureHigh + 1;
+			setCA_label();
+			break;
+		case 84: //t  toggle transmit
+			if (enableTransmit)
+			{
+				toggle_TX(0);
+			} else {
+                if(verbose) fprintf( stderr, "Transmit is not enabled\n");
+			}
+			break;
+		case 32: // space turn transmit off
+			transmit = 0;
+			if (!rock_bound)
+			{
+				pUSBCmd->sendCommand("set ptt off\n" );
+				if(verbose) fprintf (stderr, "set ptt off\n");
+			}
+			break;
+		default:
+			break;
+	}
 }
 
-void Main_Widget::rx_cmd( int key )
-{  
-    switch( key ) {
-        case 4117: // Down arrow
-        case 72: // h
-            //if ( tuneStep > 0 ) tuneStep--;
-            setTuneStep(-1);
-            break;
-        case 4114: // Left arrow
-        case 74: // j
-            if ( rx_delta_f < sample_rate / 2 - 2000 )
-                rx_delta_f = rx_delta_f + (int)pow( 10, tuneStep );
-            else
-                rx_delta_f = sample_rate / 2 - 2000;
-            setRxFrequency();
-            break;
-        case 4115: // Up arrow
-        case 76: // l
-            //if ( tuneStep < 3 ) tuneStep++;
-            setTuneStep(+1);
-            break;
-        case 4116: // Right arrow
-        case 75:  // k
-            if ( rx_delta_f > -(sample_rate / 2 - 2000) )
-                rx_delta_f = rx_delta_f - (int)pow( 10, tuneStep );
-            else
-                rx_delta_f = -(sample_rate / 2 - 2000);
-            setRxFrequency();
-            break;
-        case 4096:
-            finish();
-            break;
-        default:
-            break;
-    }
+void Main_Widget::setOurRxFrequency ( double frequency )
+{
+	char text[32];
+	snprintf ( text, 32, "%11.6lf", ( double ) ( frequency ) / 1000000.0 );
+	displayMutex.lock();
+	lcd->display ( text );	
+	displayMutex.unlock();
+}
+
+void Main_Widget::setDefaultRxFrequency ( )
+{
+	switch ( mode )
+	{
+		case RIG_MODE_USB:
+			rx_delta_f = rx_if - rx_f + usbOffset + slopeTuneOffset; //1358;
+			break;
+		case RIG_MODE_LSB:
+			rx_delta_f = rx_if -rx_f -lsbOffset + slopeTuneOffset;  //1585;  
+			break;
+		case RIG_MODE_CW:
+			rx_delta_f = rx_if -rx_f + cwPitch + slopeTuneOffset; // This seems to be only correct with narrow filters in.
+			break;
+		case RIG_MODE_CWR:
+			rx_delta_f = rx_if -rx_f - cwPitch + slopeTuneOffset; // This seems to be only correct with narrow filters in.
+			break;
+		case RIG_MODE_AM:
+		case RIG_MODE_SAM:
+		case RIG_MODE_DSB:
+		case RIG_MODE_FM:
+		default:
+			rx_delta_f = rx_if - rx_f + slopeTuneOffset;
+			break;
+	}
+	setRxFrequency( 1 );
 }
 
-void Main_Widget::process_key( int key )
+//
+// synth flag means set the external oscillator (via usbsoftrock), if
+// configured to do so (rock_bound == 0)
+//
+void Main_Widget::setRxFrequency( int synth )
 {
-    int step;
+#ifndef FREQ_POLL
+	char text[32];
+#endif
+	if ( !useIF )
+	{
+#ifndef FREQ_POLL
+		snprintf ( text, 32, "......%11.6lf",
+			( double ) ( rx_f - rx_delta_f ) / 1000000.0 );
+		fprintf ( stderr, "Set the frequency (!IF): %lld - %d = %11.6lf '%s'\n",
+			rx_f, rx_delta_f, 
+			( rx_f - rx_delta_f) / 1000000.0, text);
+		displayMutex.lock();
+		lcd->display ( text );
+                displayMutex.unlock();
+#endif
+
+		if (enableRIT) {
+			tx_f_string.sprintf ("%11.0lf", ( double ) ( tx_delta_f - rx_delta_f ) );
+			rit->setText( tx_f_string );
+            if(verbose) fprintf ( stderr, "RIT %s\n", qPrintable(tx_f_string));
+		}
+	}
+    if(verbose) fprintf ( stderr, "setOsc %d\n", rx_delta_f );
+	pCmd->sendCommand ("setOsc %d %d\n", rx_delta_f, 0 );
 
-    step = 10;
-    
-    switch( key ) {
-        case 85: 
-            setFilter_l( -1 );
-            break;
-        case 73:
-            setFilter_l( +1 );
-            break;
-        case 79: 
-            setFilter_h( -1 );
-            break;
-        case 80:
-            setFilter_h( +1 );
-            break;
-        case 91: 
-            if ( *filter_h <= 6000 && *filter_l > step ) {
-                *filter_h -= step;
-                *filter_l -= step;
-            }
-            setFilter();
-            break;
-        case 93:
-            if ( *filter_h < 6000 && *filter_l >= step ) {
-                *filter_h += step;
-                *filter_l += step;
-            }
-            setFilter();
-            break;
-        case 81: // q
-            if ( iqGain > -5000 ) iqGain--;
-			cfgIQGainInput->setValue( iqGain );
-            setIQGain();            
-            break;
-        case 87: // w
-            if ( iqGain < 5000 ) iqGain++;
-			cfgIQGainInput->setValue( iqGain );
-            setIQGain();
-            break;
-        case 69: // e
-            if ( iqPhase > -5000 ) iqPhase--;
-			cfgIQPhaseInput->setValue( iqPhase );
-            setIQPhase();
-            break;
-        case 82: // r
-            if ( iqPhase < 5000 ) iqPhase++;
-			cfgIQPhaseInput->setValue( iqPhase );
-            setIQPhase();
-            break;
-        case 90: // z
-            if ( specApertureLow > 0 )
-                specApertureLow = specApertureLow - 1;
-            setCA_label();
-            break;
-        case 88: // x
-            if ( specApertureLow < 120 && 
-				 specApertureLow < specApertureHigh - 10 )
-                specApertureLow = specApertureLow + 1;
-            setCA_label();
-            break;
-        case 67: // c
-             if ( specApertureHigh > 0 && 
-				  specApertureHigh > specApertureLow + 10 )
-				 specApertureHigh = specApertureHigh - 1;
-            setCA_label();
-            break;
-        case 86: // v
-            if ( specApertureHigh < 120 )
-                specApertureHigh = specApertureHigh + 1;
-            setCA_label();
-            break;
-        default:
-            break;
-    }
+        if (!rock_bound && !enableRIT && !enableSPLIT) {
+		if (enableTransmit) pTXCmd->sendCommand ("setOsc %d %d\n", -rx_delta_f, 1 );
+		if ( synth ) {
+			if (dualConversion)
+			{
+				if(verbose) fprintf (stderr, "set freq dual conversion %f %f %f\n",
+					(rx_f)*1e-6, 
+					((rx_f)*1e-6)/1.25,
+					((rx_f)*1e-6)/1.25/4); 
+				if (!rock_bound) pUSBCmd->sendCommand("set freq %f\n",
+					((rx_f)*1e-6)/1.25/4);
+			} else {
+                if(verbose) fprintf (stderr, "USBsoftrock: set freq %f\n", (rx_f)*1e-6);
+				if (!rock_bound) pUSBCmd->sendCommand("set freq %f\n", (rx_f)*1e-6);
+			}
+		}
+	}
 }
 
-void Main_Widget::setRxFrequency()
+void Main_Widget::setTxFrequency()
 {
-    char text[20];
-    
-    sprintf( text, "%11.6lf", (double)( rx_f - rx_delta_f ) / 1000000.0 );
-    lcd->display( text );
-    fprintf( cmdFile, "setOsc %d\n", rx_delta_f );
-    fflush( cmdFile );
+    if(verbose) fprintf ( stderr, "setOsc %d\n", rx_delta_f );
+    if (enableTransmit) pTXCmd->sendCommand ("setOsc %d %d\n", -rx_delta_f, 1 );
 }
 
-void Main_Widget::setFilter_l( int n )
+void Main_Widget::setFilter_l ( int n )
 {
-    int step;
+	int step;
 
-    step = 10;
-    
-    if ( *filter_l > -6000 && n == -1 )
-        *filter_l -= step;
+	step = 10;
+
+	if ( *filter_l > -6000 && n <= -1 )
+		*filter_l += step * n;
 
-    if ( *filter_l < *filter_h - step && n == 1 )
-        *filter_l += step;
+	if ( *filter_l < *filter_h - step && n >= 1 )
+		*filter_l += step * n;
 
-    setFilter();
+	setFilter();
 }
 
-void Main_Widget::setFilter_h( int n )
+void Main_Widget::setFilter_h ( int n )
 {
-    int step;
+	int step;
 
-    step = 10;
-    
-    if ( *filter_h < 6000  && n >= 1 )
-        *filter_h += step * n;
+	step = 10;
+
+	if ( *filter_h < 6000  && n >= 1 )
+		*filter_h += step * n;
 
-    if ( *filter_h > *filter_l + step && n <= -1 )
-        *filter_h += step * n;
+	if ( *filter_h > *filter_l + step && n <= -1 )
+		*filter_h += step * n;
 
-    setFilter();        
+	setFilter();
 }
 
 void Main_Widget::setFilter()
 {
-	fprintf( cmdFile, "setFilter %d %d\n", *filter_l, *filter_h );
-	fflush( cmdFile );
-	drawPassBandScale();
+	pCmd->sendCommand ("setFilter %d %d\n", *filter_l, *filter_h );
+    if(enableTransmit) pTXCmd->sendCommand ("setFilter %d %d 1\n", *filter_l, *filter_h );
+    if(verbose) fprintf ( stderr, "setFilter %d %d\n", *filter_l, *filter_h );
 }
 
-void Main_Widget::setLowerFilterScale( int x )
+void Main_Widget::setLowerFilterScale ( int x )
 {
-	static float bin_bw = sample_rate/4096.0;
+	float bin_bw = sample_rate/(float)spec_width;
 	int stop_band;
 
-	stop_band = (int)(((x - (spectrogram->width() / 2)) * bin_bw)) /10*10;
+	//stop_band = ( int ) ( ( ( x - ( spectrogram->width() / 2 ) ) * bin_bw ) ) /10*10;
+	stop_band = (int)(((x - (spectrogram->width() / 2)) * bin_bw) * hScale) / 10*10;
 
 	if ( stop_band < *filter_h ) {
 		*filter_l = stop_band;
@@ -1625,12 +2798,13 @@ void Main_Widget::setLowerFilterScale( i
 	}
 }
 
-void Main_Widget::setUpperFilterScale( int x )
+void Main_Widget::setUpperFilterScale ( int x )
 {
-	static float bin_bw = sample_rate/4096.0;
+	float bin_bw = sample_rate/(float)spec_width;
 	int stop_band;
 
-	stop_band = (int)(((x - (spectrogram->width() / 2)) * bin_bw))/10*10;
+	//stop_band = ( int ) ( ( ( x - ( spectrogram->width() / 2 ) ) * bin_bw ) ) /10*10;
+	stop_band = (int)(((x - (spectrogram->width() / 2)) * bin_bw) * hScale) / 10*10;
 
 	if ( stop_band > *filter_l ) {
 		*filter_h = stop_band;
@@ -1640,739 +2814,1969 @@ void Main_Widget::setUpperFilterScale( i
 
 void Main_Widget::setCA_label()
 {
-    char text[20];
-    sprintf( text, "CA: %4d : %4d", 
-			 (int)specApertureLow - 140,
-			 (int)specApertureHigh - 140);
-    CA_label->setText( text );
+	char text[20];
+	snprintf ( text, 20, "CA: %4d : %4d",
+	          ( int ) specApertureLow - 140,
+	          ( int ) specApertureHigh - 140 );
+	CA_label->setText ( text );
 }
 
-void Main_Widget::setTuneStep( int step )
+void Main_Widget::setTuneStep ( int step )
 {
-    if ( tuneStep < 3 && step > 0 ) tuneStep++;
-    else if ( tuneStep > 0 && step < 0 ) tuneStep--;
-    
-	switch( tuneStep ) {
-	case 0:
-		step_1Hz_frame->setPaletteBackgroundColor( QColor( 200, 200, 255 ) );
-		step_10Hz_frame->setPaletteBackgroundColor( QColor( 50, 50, 100 ) );
-		step_100Hz_frame->setPaletteBackgroundColor( QColor( 50, 50, 100 ) );
-		step_1000Hz_frame->setPaletteBackgroundColor( QColor( 50, 50, 100 ) );
-		break;
-	case 1:
-		step_1Hz_frame->setPaletteBackgroundColor( QColor( 50, 50, 100 ) );
-		step_10Hz_frame->setPaletteBackgroundColor( QColor( 200, 200, 255 ) );
-		step_100Hz_frame->setPaletteBackgroundColor( QColor( 50, 50, 100 ) );
-		step_1000Hz_frame->setPaletteBackgroundColor( QColor( 50, 50, 100 ) );
-		break;
-	case 2:
-		step_1Hz_frame->setPaletteBackgroundColor( QColor( 50, 50, 100 ) );
-		step_10Hz_frame->setPaletteBackgroundColor( QColor( 50, 50, 100 ) );
-		step_100Hz_frame->setPaletteBackgroundColor( QColor( 200, 200, 255 ) );
-		step_1000Hz_frame->setPaletteBackgroundColor( QColor( 50, 50, 100 ) );
-		break;
-	case 3:
-		step_1Hz_frame->setPaletteBackgroundColor( QColor( 50, 50, 100 ) );
-		step_10Hz_frame->setPaletteBackgroundColor( QColor( 50, 50, 100 ) );
-		step_100Hz_frame->setPaletteBackgroundColor( QColor( 50, 50, 100 ) );
-		step_1000Hz_frame->setPaletteBackgroundColor( QColor( 200, 200, 255 ) );
-		break;
-	default:
-		step_1Hz_frame->setPaletteBackgroundColor( QColor( 50, 50, 100 ) );
-		step_10Hz_frame->setPaletteBackgroundColor( QColor( 50, 50, 100 ) );
-		step_100Hz_frame->setPaletteBackgroundColor( QColor( 50, 50, 100 ) );
-		step_1000Hz_frame->setPaletteBackgroundColor( QColor( 50, 50, 100 ) );
-		break;
+    if ( rock_bound ) {
+	  if ( step <= 3 && step >= 0 ) tuneStep = step;
+	} else {
+	  if ( step <= 8 && step >= 0 ) tuneStep = step;
+	}
+
+	if (tuneStep != 0) {
+		step_1Hz_frame->setPalette( QColor( 50, 50, 100 ) );
+		step_1Hz_frame->setAutoFillBackground(true);
+	}
+	if (tuneStep != 1) {
+		step_10Hz_frame->setPalette( QColor( 50, 50, 100 ) );
+		step_10Hz_frame->setAutoFillBackground(true);
+	}
+	if (tuneStep != 2) {
+		step_100Hz_frame->setPalette( QColor( 50, 50, 100 ) );
+		step_100Hz_frame->setAutoFillBackground(true);
+	}
+	if (tuneStep != 3) {
+		step_1KHz_frame->setPalette( QColor( 50, 50, 100 ) );
+		step_1KHz_frame->setAutoFillBackground(true);
+	}
+	if (tuneStep != 4) {
+		step_10KHz_frame->setPalette( QColor( 50, 50, 100 ) );
+		step_10KHz_frame->setAutoFillBackground(true);
+	}
+	if (tuneStep != 5) {
+		step_100KHz_frame->setPalette( QColor( 50, 50, 100 ) );
+		step_100KHz_frame->setAutoFillBackground(true);
+	}
+	if (tuneStep != 6) {
+		step_1MHz_frame->setPalette( QColor( 50, 50, 100 ) );
+		step_1MHz_frame->setAutoFillBackground(true);
+	}
+	if (tuneStep != 7) {
+		step_10MHz_frame->setPalette( QColor( 50, 50, 100 ) );
+		step_10MHz_frame->setAutoFillBackground(true);
+	}
+	if (tuneStep != 8) {
+		step_100MHz_frame->setPalette( QColor( 50, 50, 100 ) );
+		step_100MHz_frame->setAutoFillBackground(true);
+	}
+
+	switch ( tuneStep )
+	{
+		case 0:
+			step_1Hz_frame->setPalette( QColor( 200, 200, 255 ) );
+			step_1Hz_frame->setAutoFillBackground(true);
+			break;
+		case 1:
+			step_10Hz_frame->setPalette( QColor( 200, 200, 255 ) );
+			step_10Hz_frame->setAutoFillBackground(true);
+			break;
+		case 2:
+			step_100Hz_frame->setPalette( QColor( 200, 200, 255 ) );
+			step_100Hz_frame->setAutoFillBackground(true);
+			break;
+		case 3:
+			step_1KHz_frame->setPalette( QColor( 200, 200, 255 ) );
+			step_1KHz_frame->setAutoFillBackground(true);
+			break;
+		case 4: 
+			step_10KHz_frame->setPalette( QColor( 200, 200, 255 ) );
+			step_10KHz_frame->setAutoFillBackground(true);
+			break;
+		case 5: 
+			step_100KHz_frame->setPalette( QColor( 200, 200, 255 ) );
+			step_100KHz_frame->setAutoFillBackground(true);
+			break;
+		case 6: 
+			step_1MHz_frame->setPalette( QColor( 200, 200, 255 ) );
+			step_1MHz_frame->setAutoFillBackground(true);
+			break;
+		case 7: 
+			step_10MHz_frame->setPalette( QColor( 200, 200, 255 ) );
+			step_10MHz_frame->setAutoFillBackground(true);
+			break;
+		case 8: 
+			step_100MHz_frame->setPalette( QColor( 200, 200, 255 ) );
+			step_100MHz_frame->setAutoFillBackground(true);
+			break;
+		default:
+			break;
 	}
 }
 
-void Main_Widget::setMode( int m )
+void Main_Widget::setMode ( rmode_t m, bool displayOnly, bool force )
 {
-    mode = m;
+	QString	modeStr;
 
-    QColor c_off( 0, 0, 0 );
-    QColor c_on( 200, 0, 0 );
+	if (mode == m && ! force) {
+        if(verbose) fprintf(stderr, "set mode: no mode change\n");
+		return;
+	}
+	
+	mode = m;
 
-    LSB_label->setBackgroundColor( c_off );
-    USB_label->setBackgroundColor( c_off );
-    DSB_label->setBackgroundColor( c_off );
-    AM_label->setBackgroundColor( c_off );
-    CWL_label->setBackgroundColor( c_off );
-    CWU_label->setBackgroundColor( c_off );
-    SAM_label->setBackgroundColor( c_off );
-	FMN_label->setBackgroundColor(  c_off );
-
-    switch ( mode ) {
-        case USB:
-            fprintf( cmdFile, "setMode %d\n", USB );
-            fflush( cmdFile );
-            filter_l = &USB_filter_l; //20;
-            filter_h = &USB_filter_h; //2400;
-			USB_label->setBackgroundColor( c_on );
-            break;
-        case LSB:
-            fprintf( cmdFile, "setMode %d\n", LSB );
-            fflush( cmdFile );
-            filter_l = &LSB_filter_l; //-2400;
-            filter_h = &LSB_filter_h; //-20;
-			LSB_label->setBackgroundColor( c_on );
-            break;
-        case DSB:
-            fprintf( cmdFile, "setMode %d\n", DSB );
-            fflush( cmdFile );
-            filter_l = &DSB_filter_l; //-2400;
-            filter_h = &DSB_filter_h; //2400;
-			DSB_label->setBackgroundColor( c_on );
-            break;
-        case AM:
-            fprintf( cmdFile, "setMode %d\n", AM );
-            fflush( cmdFile );
-            filter_l = &AM_filter_l; //-2400;
-            filter_h = &AM_filter_h; //2400;
-			AM_label->setBackgroundColor( c_on );
-            break;
-        case CWL:
-            fprintf( cmdFile, "setMode %d\n", CWL );
-            fflush( cmdFile );
-            filter_l = &CWL_filter_l; //-500;
-            filter_h = &CWL_filter_h; //-200;
-			CWL_label->setBackgroundColor( c_on );
-            break;
-        case CWU:
-            fprintf( cmdFile, "setMode %d\n", CWU );
-            fflush( cmdFile );
-            filter_l = &CWU_filter_l; //200;
-            filter_h = &CWU_filter_h; //500;
-			CWU_label->setBackgroundColor( c_on );
-            break;
-        case SAM:
-            fprintf( cmdFile, "setMode %d\n", SAM );
-            fflush( cmdFile );
-            filter_l = &SAM_filter_l; //-2400;
-            filter_h = &SAM_filter_h; //2400;
-			SAM_label->setBackgroundColor( c_on );
-            break;
-        case FMN:
-            fprintf( cmdFile, "setMode %d\n", FMN );
-            fflush( cmdFile );
-            filter_l = &FMN_filter_l; //-4000;
-            filter_h = &FMN_filter_h; //4000;
-			FMN_label->setBackgroundColor( c_on );
-            break;
-        default: break;
-    }
-    setFilter();
+	QColor c_off ( 0, 0, 0 );
+	QColor c_on ( 200, 0, 0 );
+
+    LSB_label->setPalette( c_off );
+    LSB_label->setAutoFillBackground(true);
+    USB_label->setPalette( c_off );
+    USB_label->setAutoFillBackground(true);
+    DSB_label->setPalette( c_off );
+    DSB_label->setAutoFillBackground(true);
+    AM_label->setPalette( c_off );
+    AM_label->setAutoFillBackground(true);
+    CWL_label->setPalette( c_off );
+    CWL_label->setAutoFillBackground(true);
+    CWU_label->setPalette( c_off );
+    CWU_label->setAutoFillBackground(true);
+    SAM_label->setPalette( c_off );
+    SAM_label->setAutoFillBackground(true);
+    FMN_label->setPalette( c_off );
+	FMN_label->setAutoFillBackground(true);
+
+	switch ( mode )
+	{
+		case RIG_MODE_USB:
+			modeStr = "USB";
+			pCmd->sendCommand ("setMode %d %d\n", USB, 0 );
+            if(enableTransmit) pTXCmd->sendCommand ("setMode %d %d\n", USB, 1 );
+            if(verbose) fprintf ( stderr, "setMode %d\n", USB );
+			filter_l = &USB_filter_l; //20;
+			filter_h = &USB_filter_h; //2400;
+			USB_label->setPalette( c_on );
+			USB_label->setAutoFillBackground(true);
+			if ( !displayOnly && useHamlib )
+            //if(verbose) fprintf ( stderr, "emitted changeRigMode at USB. \n" );
+				emit changeRigMode ( RIG_MODE_USB, 2700 );
+			break;
+		case RIG_MODE_LSB:
+			modeStr = "LSB";
+			pCmd->sendCommand ("setMode %d %d\n", LSB, 0 );
+            if(enableTransmit) pTXCmd->sendCommand ("setMode %d %d\n", LSB, 1 );
+            if(verbose) fprintf ( stderr, "setMode %d\n", LSB );
+			filter_l = &LSB_filter_l; //-2400;
+			filter_h = &LSB_filter_h; //-20;
+            LSB_label->setPalette( c_on );
+            LSB_label->setAutoFillBackground(true);
+			if ( !displayOnly && useHamlib )
+				emit changeRigMode ( RIG_MODE_LSB, 2700 );
+			break;
+		case RIG_MODE_DSB:
+			modeStr = "DSB";
+			pCmd->sendCommand ("setMode %d %d\n", DSB, 0 );
+            if(enableTransmit) pTXCmd->sendCommand ("setMode %d %d\n", DSB, 1 );
+            if(verbose) fprintf ( stderr, "setMode %d\n", DSB );
+			filter_l = &DSB_filter_l; //-2400;
+			filter_h = &DSB_filter_h; //2400;
+            DSB_label->setPalette( c_on );
+            DSB_label->setAutoFillBackground(true);            
+			if ( !displayOnly && useHamlib)
+				emit changeRigMode ( RIG_MODE_USB, 6000 );
+			break;
+		case RIG_MODE_AM:
+			modeStr = "AM";
+			pCmd->sendCommand ("setMode %d %d\n", AM, 0 );
+            if(enableTransmit) pTXCmd->sendCommand ("setMode %d %d\n", AM, 1 );
+            if(verbose) fprintf ( stderr, "setMode %d\n", AM );
+			filter_l = &AM_filter_l; //-2400;
+			filter_h = &AM_filter_h; //2400;
+            AM_label->setPalette( c_on );
+            AM_label->setAutoFillBackground(true);            
+			if ( !displayOnly && useHamlib )
+				emit changeRigMode ( RIG_MODE_AM, 6000 );
+			break;
+		case RIG_MODE_CWR:
+			modeStr = "CWR";
+			pCmd->sendCommand ("setMode %d %d\n", CWL, 0 );
+            if(enableTransmit) pTXCmd->sendCommand ("setMode %d %d\n", CWL, 1 );
+            if(verbose) fprintf ( stderr, "setMode %d\n", CWL );
+			filter_l = &CWL_filter_l; //-500;
+			filter_h = &CWL_filter_h; //-200;
+            CWL_label->setPalette( c_on );
+            CWL_label->setAutoFillBackground(true);            
+			if ( !displayOnly && useHamlib )
+				emit changeRigMode ( RIG_MODE_CWR, 500 );
+			break;
+		case RIG_MODE_CW:
+			modeStr = "CW";
+			pCmd->sendCommand ("setMode %d %d\n", CWU, 0 );
+            if(enableTransmit) pTXCmd->sendCommand ("setMode %d %d\n", CWU, 1 );
+            if(verbose) fprintf ( stderr, "setMode %d\n", CWU );
+			filter_l = &CWU_filter_l; //200;
+			filter_h = &CWU_filter_h; //500;
+            CWU_label->setPalette( c_on );
+            CWU_label->setAutoFillBackground(true);            
+			if ( !displayOnly && useHamlib )
+				emit changeRigMode ( RIG_MODE_CW, 500 );
+			break;
+		case RIG_MODE_SAM:
+			modeStr = "SAM";
+			pCmd->sendCommand ("setMode %d %d\n", SAM, 0 );
+            if(enableTransmit) pTXCmd->sendCommand ("setMode %d %d\n", SAM, 1 );
+            if(verbose) fprintf ( stderr, "setMode %d\n", SAM );
+			filter_l = &SAM_filter_l; //-2400;
+			filter_h = &SAM_filter_h; //2400;
+            SAM_label->setPalette( c_on );
+            SAM_label->setAutoFillBackground(true);            
+			/*if (!displayOnly) 
+			emit changeRigMode ( RIG_MODE_AM, 12000 ); */ //Some rigs can do syncronous AM, but not mine.  KL7NA  uncomment this for them.*/
+			break;
+		case RIG_MODE_FM:
+			modeStr = "FM";
+			pCmd->sendCommand ("setMode %d %d\n", FMN );
+            if(enableTransmit) pTXCmd->sendCommand ("setMode %d %d\n", FMN );
+            if(verbose) fprintf ( stderr, "setMode %d\n", FMN );
+			filter_l = &FMN_filter_l; //-4000;
+			filter_h = &FMN_filter_h; //4000;
+            FMN_label->setPalette( c_on );
+            FMN_label->setAutoFillBackground(true);            
+			if ( !displayOnly && useHamlib )
+				emit changeRigMode ( RIG_MODE_FM, 12000 );
+			break;
+		default:
+			modeStr = "Unknown";
+			filter_l = &USB_filter_l; //20;
+			filter_h = &USB_filter_h; //2400;
+	}
+    if(verbose) fprintf( stderr, "Set mode: %s\n", qPrintable(modeStr));
+
+	// call external mode setting hook.
+	if (sdr_mode != NULL) {
+		QString cmd = sdr_mode;
+		cmd += " ";
+		cmd += modeStr;
+        if(verbose) fprintf( stderr, "Set mode: %s\n", qPrintable(cmd));
+		system(qPrintable(cmd));
+	}
+	setFilter();
+	if ( useIF ) setDefaultRxFrequency();
+	else setRxFrequency( 1 );
 }
 
+
 void Main_Widget::setIQGain()
 {
-    fprintf( cmdFile, "setcorrectIQgain %d\n", iqGain );
-    fflush( cmdFile );
+	pCmd->sendCommand ("setcorrectIQgain %d\n", iqGain );
+    if ( verbose) fprintf ( stderr, "setcorrectIQgain %d\n", iqGain );
+	// The following sets the output gain.
+	pCmd->sendCommand ("setGain %d %d\n", 0,1,0 );
+    if(verbose) fprintf ( stderr, "setGain %d %d %d\n",0,1,0 );
 }
 
 void Main_Widget::setIQPhase()
 {
-    fprintf( cmdFile, "setcorrectIQphase %d\n", iqPhase );
-    fflush( cmdFile );
+	pCmd->sendCommand ("setcorrectIQphase %d\n", iqPhase );
+    if ( verbose) fprintf ( stderr, "(RX)setcorrectIQphase %d\n", iqPhase );
 }
 
-void Main_Widget::readMeter()
+void Main_Widget::setTxIQGain()
 {
-    int j, k = 0, label;
-    float rxm[MAXRX][RXMETERPTS];
-    char text[10];
-    static double meter_peak = 0;
-    static int peak_count = 0;
-    
-    if ( mtrFile == NULL ) return;
-    
-    fprintf(cmdFile, "reqRXMeter %d\n", getpid() );
-    fflush(cmdFile);
-    
-    if ( fread((char *) &label, sizeof(int), 1, mtrFile) != 1) {
-		perror("fread meter label");
+    if(enableTransmit)
+    {
+        pTXCmd->sendCommand ("setcorrectTXIQgain %d\n", txIQGain );
+        if ( verbose) fprintf ( stderr, "(TX)setcorrectTXIQgain %d\n", txIQGain );
     }
-	
-    if ( fread((char *) rxm, sizeof(float), MAXRX * RXMETERPTS, mtrFile)
-         != MAXRX * RXMETERPTS ) {
-		perror("fread meter");
+}
+
+void Main_Widget::setTxIQPhase()
+{
+	if(enableTransmit)
+    {
+        pTXCmd->sendCommand ("setcorrectTXIQphase %d %d\n", txIQPhase );
+        if ( verbose) fprintf ( stderr, "(TX)setcorrectTXIQphase %d\n", txIQPhase );
     }
-    
-    if ( rxm[0][0] >= meter_peak ) {
+}
+
+void Main_Widget::setTxGain( int inout )
+{
+    int gain = inout ? txGain : micGain;
+    if(enableTransmit)
+    {
+        pTXCmd->sendCommand ("setGain %d %d %d\n", 1, inout, gain );
+        if (verbose) fprintf ( stderr, "(TX)set%sGain %d %d %d\n",
+		inout ? "Output" : "Mic",
+		1, inout, gain );
+    }
+}
+
+
+void Main_Widget::readMeter()
+{
+	int j, k = 0, label;
+	float rxm[MAXRX * RXMETERPTS];
+	char text[10];
+	static double meter_peak = 0;
+	static int peak_count = 0;
+
+	pCmd->sendCommand ("reqRXMeter %d\n", getpid() );
+	pMeter->fetch (&label, rxm, MAXRX * RXMETERPTS);
+
+	if ( rxm[0] >= meter_peak )
+	{
 		peak_count = 0;
-		meter_peak = rxm[0][0];
-		sprintf( text, "%4d", (int)(rxm[0][0] - metrCal)  );
-		signal_dBm->setText( text );
-    } else {
-		if( peak_count++ >= 15 ) {
+		meter_peak = rxm[0];
+		snprintf ( text, 10, "%4d", ( int ) ( rxm[0] - metrCal ) );
+		signal_dBm->setText ( text );
+	}
+	else
+	{
+		if ( peak_count++ >= 15 )
+		{
 			peak_count = 0;
-			meter_peak = rxm[0][0];
-		} else {
-			for ( j = 0; j < 34; j++ ) {
-				if ( meter_peak - metrCal < s_dbm[j] ) {
+			meter_peak = rxm[0];
+		}
+		else
+		{
+			for ( j = 0; j < 34; j++ )
+			{
+				if ( meter_peak - metrCal < s_dbm[j] )
+				{
 					k = j;
 					break;
 				}
 			}
 		}
-    }
-    
-    for ( j = 0; j < 34; j++ ) {
-		if ( rxm[0][0] - metrCal > s_dbm[j] )
-			//signalBargraph[j]->setPaletteBackgroundColor( *signalColor[j] );
-			signalBargraph[j]->setPaletteBackgroundColor( QColor( 0,180,255 ));
+	}
+
+	for ( j = 0; j < 34; j++ )
+	{
+		if ( rxm[0] - metrCal > s_dbm[j] )
+			signalBargraph[j]->setPalette( QColor( 0,180,255 ));
 		else if ( j != k )
-			signalBargraph[j]->setPaletteBackgroundColor( QColor( 50,50,50 ) );
+			signalBargraph[j]->setPalette( QColor( 50,50,50 ) );
 		else if ( k != 0 )
-			signalBargraph[j]->setPaletteBackgroundColor( *signalColor[j] );
-    }
+			signalBargraph[j]->setPalette( *signalColor[j] );
+
+		signalBargraph[j]->setAutoFillBackground(true);
+	}
 }
 
-//----------------------------------------------------------------------------
 // Fetch the spectrum data from sdr-core
 //
 void Main_Widget::readSpectrum()
 {
-    int j, k;
-    int label, stamp;
-    
-    if ( fftFile == NULL ) return;
-    
-    fprintf(cmdFile, "reqSpectrum %d\n", getpid() );
-    fflush(cmdFile);
+	int j, k, l, m, n;
+	int label, stamp;
+	float raw_spectrum[DEFSPEC];
+	float a;
+
+	//fprintf( stderr, ".");
+	updated++;
+	pCmd->sendCommand ("reqSpectrum %d\n", getpid() ); 
 
-    if (fread((char *) &label, sizeof(int), 1, fftFile) != 1) {
-        perror( "fread spectrum label" );
-    }
-    
-    if (fread((char *) &stamp, sizeof(int), 1, fftFile) != 1) {
-         perror( "fread spectrum stamp" );
-    }
-    
-    if (fread((char *) spectrum, sizeof(float), DEFSPEC, fftFile) != DEFSPEC) {
-        perror( "fread spec" );
-    }
+	if (spec_width == DEFSPEC) {
+		pSpectrum->fetch (&stamp, &label, spectrum, DEFSPEC);
+	} else {
+		pSpectrum->fetch (&stamp, &label, raw_spectrum, DEFSPEC);
 
-    //if (fread((char *) oscope, sizeof(float), DEFSPEC, fftFile) != DEFSPEC) {
-    //    perror( "fread spec" );
-    // }
-    
-    //printf("<%d>", label);
+		// spectrum from dttsp is centered at Osc.
+		// if Osc != 0, then some bins on one end are wrapped data.  Zero them.
+		// this is only a visible problem when scaling the data...
+#if 0
+		if (rx_delta_f < 0) {
+			float bin_bw = sample_rate/(float)DEFSPEC;
+			a = abs(rx_delta_f) / bin_bw;
+			j = DEFSPEC - (int)a;
+			if (once)
+				printf("Osc=%d bins=%.1f j=%d\n",
+					rx_delta_f, a, j);
+			for(; j < DEFSPEC; j++) {
+				raw_spectrum[j] = 0;
+			}
+		}
+#endif
 
-    j = 0;
-    for (k = 1; k < DEFSPEC; k++) {
-        if (spectrum[k] > spectrum[j]) j = k;
-            //printf(" [%d %g] %g\n", j, oscope[k], oscope[k] * 50000);
-    }
-    
-    //printf(" [%d %g]\n", j, spectrum[j] + specCal );
+		// resample spectrum to be smaller
+		// use the max value of N samples
+		// j = raw sample index
+		// k = downsampled index
+		n = DEFSPEC / spec_width;
+		for (j = k = 0; j < DEFSPEC; j += n, k++) {
+			a = raw_spectrum[j];
+
+			for (l = j+1, m=1; m < n; l++, m++) {
+				if (raw_spectrum[l] > a) {
+					a = raw_spectrum[l];
+				}
+			}
 
-    drawSpectrogram();
-    if ( SPEC_state ) plotSpectrum( spectrum_head );    
+			spectrum[k] = a;
+		}
+		for ( ; k < DEFSPEC; k++) {
+			spectrum[k] = 0;
+		}
+		// if the dttsp Osc frequency is not zero, one end or the other has
+		// wrapped data.
+	}
+
+	//drawSpectrogram();
+	//if ( SPEC_state ) plotSpectrum ( spectrum_head );
+	repaint();
 }
 
 void Main_Widget::drawSpectrogram()
 {
     int x, x1, x2;
     static int y = 0;
-    int pwr;
+    int pwr, specval;
     float pwr_range;
+    bool spec_debug = false;
 
     pwr_range = specApertureHigh - specApertureLow;
+    if(spec_debug)
+	printf("drawSpectrogram() \n");
 
-    QImage spectrogramLine( spectrogram->width(), 1 , 32 );
-
-    x1 = DEFSPEC/2 - spectrogram->width()/2;
-    x2 = x1 + spectrogram->width();
-    
-    for ( x = 0; x < DEFSPEC; x++) {
-        // Compute the power (magnified)
+//tf    QImage spectrogramLine( spectrogram->width() , 1, QImage::Format_RGB32 );
+    QImage spectrogramLine( spectrum_width , 1, QImage::Format_RGB32 );
+   
+//tf    x1 = DEFSPEC/2 - spectrogram->width()/2;
+//tf    x2 = x1 + spectrogram->width();
+    x1 = DEFSPEC/2 - spectrum_width/2;
+    x2 = x1 + spectrum_width;
+    if(spec_debug)
+	{
+	printf("drawSpectrogram::x1 = %d\n", x1);
+	printf("drawSpectrogram::x2 = %d\n", x2);
+	printf("drawSpectrugram::y = %d\n", y);
+	}    
+    for ( x = 0; x < DEFSPEC; x++)		// for number of fft samples per line.. 
+	{
+        						// Compute the power (magnified)
         pwr = (int)((spectrum[ x ] + specCal - specApertureLow) * 
-					(120 / pwr_range));
-        
-        // Sanitize
-        if ( pwr > 119 ) pwr = 119;
+					(SPECFRM_V / pwr_range));
+        if ( pwr > 119 ) pwr = 119;			// Sanitize the value
         else if ( pwr < 0 ) pwr = 0;
-
-        // Save power for spectrum display
-        spectrum_history[y][x] = (int)(spectrum[ x ] + specCal);
-    
-        // If bin is in visible range, plot it.
-        if ( x >= x1 && x < x2 ) {
-            // Set the pixel color
-            uint *p = (uint *)spectrogramLine.scanLine(0) + (x - x1);
+        						
+	specval = (int)(spectrum[ x ] + specCal);	//Save power for spectrum display
+	if(specval > 119) specval = 119;
+	if(specval < 0) specval = 0;
+	spectrum_history[y][x] = specval;
+//tf        spectrum_history[y][x] = (int)(spectrum[ x ] + specCal);
+
+        if ( x >= x1 && x < x2 )	// If bin is in visible range, plot it.
+	    {
+            uint *p = (uint *)spectrogramLine.scanLine(0) + (x - x1); // Set pixel color
             *p = qRgb( spec_r[pwr], spec_g[pwr], spec_b[pwr] );
 
-            // Turn on vertical filter line
+            // Turn on vertical filter line: Note that filterLine is set to 0 by default, so 
+            // no filter boundary lines will be drawn in the spectrogram.  The following two
+            // if statements will fail.  (MS)
             if ( filterLine &&
                  (x - x1) == spectrogram->width() / 2 +
-                 (int)(*filter_l / (sample_rate/4096.0)) ) {
+                 (int)(*filter_l / bin_bw) ) {
                 *p = qRgb( 100, 255, 100 );
             }
 
             if ( filterLine &&
                  (x - x1) == spectrogram->width() / 2 +
-                 (int)(*filter_h / (sample_rate/4096.0)) ) {
+                 (int)(*filter_h / bin_bw) ) {
                 *p = qRgb( 100, 255, 100 );
             }        
-        
-            // Set the center mark
-            if ( (x - x1) == spectrogram->width() / 2 )
+                    					// Set the center mark (red)
+//tf            if ( (x - x1) == spectrogram->width() / 2 )
+//tf                *p = qRgb( 255,0,0 );
+            if ( (x - x1) == spectrum_width / 2 )
                 *p = qRgb( 255,0,0 );
         }
     }
-
     spectrum_head = y;
-    
-    // Draw the spectrum line
+   	//////////////////////////////////////////////// Now, draw this spectrum line
     QPainter p;
-    p.begin( spectrogram );
-    p.drawImage( 0, y = (y+1) % spectrogram->height(), spectrogramLine );
+    p.begin( this );
+    //p.begin( spectrogramFrame );
+    p.scale((1.0 / hScale), 1.0);
+	y = (y+1) % spectrogram->height();
+    p.drawImage( 2, y + TOPFRM_V, spectrogramLine );
+
 
+    //Temporarily disable the bandpass width yellow indicator line in the waterfall display
     p.setPen( Qt::yellow );
-    p.drawLine( spectrogram->width() / 2 + 
-				(int)(*filter_l / (sample_rate/4096.0)), y+1,
-                spectrogram->width() / 2 + 
-				(int)(*filter_h / (sample_rate/4096.0)), y+1 );
-    p.drawLine( spectrogram->width() / 2 + 
-				(int)(*filter_l / (sample_rate/4096.0)), y+2,
-                spectrogram->width() / 2 + 
-				(int)(*filter_h / (sample_rate/4096.0)), y+2 );
-    
+    p.drawLine( spectrum_width / 2 + 
+				((int)(*filter_l / bin_bw) + 2), y+1 + TOPFRM_V,
+                spectrum_width / 2 + 
+				((int)(*filter_h / bin_bw) + 2), y+1 + TOPFRM_V );
+    p.drawLine( spectrum_width / 2 + 
+				((int)(*filter_l / bin_bw) + 2), y+2 + TOPFRM_V,
+               spectrum_width / 2 + 
+				((int)(*filter_h / bin_bw) + 2), y+2 + TOPFRM_V );
     p.end();
 }    
 
+/****************************************************************************************
+*	drawPassBandScale()	draws the pass-band scale on screen			*
+****************************************************************************************/
 void Main_Widget::drawPassBandScale()
 {
-  static float bin_bw = sample_rate/4096.0;
+//printf("drawPassBandScale() \n");
   char temp[20];
   int x1, x2;
 
-  x1 = spectrogram->width() / 2 + (int)(*filter_l / bin_bw);
-  x2 = spectrogram->width() / 2 + (int)(*filter_h / bin_bw);
-
+		// x1 is the lower-BP filter location
+		// x2 is the upper-BP filter location  
+  x1 = spectrogram->width() / 2 + ((int)((*filter_l / bin_bw)+2) / hScale);
+  x2 = spectrogram->width() / 2 + ((int)((*filter_h / bin_bw)+2) / hScale);
+  //printf("dPBS filter_l=%d, filter_h=%d, bin_bw=%f, hScale=%f \n",*filter_l, *filter_h, bin_bw,hScale);
+  //printf("dPBS x1 = %d, x2 = %d\n", x1, x2);
   QPainter p;
-  p.begin( pbscale );
-  p.setFont( *font1 );
+  p.begin( this );
 
-  p.eraseRect( 0, 0, pbscale->width(), pbscale->height() );
+  p.setFont( *font1 );
 
+  p.eraseRect( 2, spectrogram->height() + TOPFRM_V, pbscale->width()+1, 
+		pbscale->height()+1 );
+  p.fillRect(2, spectrogram->height() + TOPFRM_V,pbscale->width()+1,
+		pbscale->height()+1,QColor(100, 0, 0));  
   sprintf( temp, "%5d", *filter_l );
   p.setPen( Qt::cyan );
-  p.drawText( x1 - 11 - font1Metrics->maxWidth() * 5, 
-			  font1Metrics->ascent() + 1, temp );
-
-  // Draw pb_l arrow
+  p.drawText( x1 - 11 -1 - font1Metrics->maxWidth() * 5, 
+			  font1Metrics->ascent() + 1 + TOPFRM_V + spectrogram->height(), temp );
+  //////////////////////////////////////////////////// Draw low-side passband arrow
   p.setPen( Qt::yellow );
-  p.drawLine( x1 - 10, 7, x1, 7 );
-  p.drawLine( x1 - 4, 4, x1 - 1, 7 );
-  p.drawLine( x1 - 4, 10, x1 - 1, 7 );
-  p.drawLine( x1, 0, x1, 15 );
+  p.drawLine( x1 - 10 -1, 7 + TOPFRM_V + spectrogram->height(), 
+		x1, 7 + TOPFRM_V + spectrogram->height()); //horizontal part of arrow
+  p.drawLine( x1 - 4 -1, 4 + TOPFRM_V + spectrogram->height(), 
+		x1 -1, 7 + TOPFRM_V + spectrogram->height() );
+  p.drawLine( x1 - 4 -1, 10 + TOPFRM_V + spectrogram->height(), 
+		x1 -1, 7 + TOPFRM_V + spectrogram->height()  );
+  p.drawLine( x1, 0 + TOPFRM_V + spectrogram->height(), 
+		x1, PBSFRM_V + TOPFRM_V + spectrogram->height() ); //vertical line 
 
   sprintf( temp, "%-5d", *filter_h );
   p.setPen( Qt::cyan );
-  p.drawText( x2 + 12, font1Metrics->ascent() + 1, temp );
+  p.drawText( x2 + 12, font1Metrics->ascent() + 1 + TOPFRM_V + spectrogram->height(), temp );
 
-  // Draw pb_h arrow
+  /////////////////////////////////////////////////// Draw high-side passband arrow
   p.setPen( Qt::yellow );
-  p.drawLine( x2 + 10, 7, x2, 7 );
-  p.drawLine( x2 + 4, 4, x2 + 1, 7 );
-  p.drawLine( x2 + 4, 10, x2 + 1, 7 );
-  p.drawLine( x2, 0, x2, 15 );
-  
+ p.drawLine( x2 + 10, 7 + TOPFRM_V +  spectrogram->height(), 
+		x2 + 1, 7 + TOPFRM_V + spectrogram->height()); //horizontal part of arrow
+  p.drawLine( x2 + 4, 4 + TOPFRM_V +  spectrogram->height(), 
+		x2 + 1, 7 + TOPFRM_V + spectrogram->height() );
+  p.drawLine( x2 + 4, 10 + TOPFRM_V +  spectrogram->height(), 
+		x2 + 1, 7 + TOPFRM_V + spectrogram->height() );
+  p.drawLine( x2, 0 + TOPFRM_V +  spectrogram->height(), 
+		x2, PBSFRM_V + TOPFRM_V + spectrogram->height() ); //vertical line
   p.end();
 }
 
+/****************************************************************************************
+*	plotSpectrum()		Plots the spectrum DATA on the screen			*
+****************************************************************************************/
 void Main_Widget::plotSpectrum( int y )
 {
-	static float bin_bw = sample_rate/4096.0;
-    int x, x1, x2;
+//printf("plotSpectrum( int y ) \n");
+    int x, y1, x1, x2, n, spectrumFrame_width_less1;
     double kHz_step;
     int f;
+    int f1, f2;
     char f_text[10];
+    bool debug = false;
+	int spectrum_data[DEFSPEC];
+
+    spectrumFrame_width_less1 = spectrum_width - 1;
 
-	int f1, f2;
+	//  Set up the dark-green BP filter swath start/stop in spectrum display
+    f1 = spectrum_width / 2 + (int)(*filter_l / bin_bw) + 2;	// f1 is low filter
+    f2 = spectrum_width / 2 + (int)(*filter_h / bin_bw) + 2;	// f2 is high filter
+
+	// 4096/2 - width/2
+    x1 = (DEFSPEC/2 - spectrum_width / 2) -3;
+    x2 = x1 + spectrum_width;
+
+    if(hScale > 2.0)
+    	kHz_step = 5000 / bin_bw;
+    else
+    	kHz_step = 1000 / bin_bw;
 	
-	f1 = spectrogram->width() / 2 + (int)(*filter_l / bin_bw);
-	f2 = spectrogram->width() / 2 + (int)(*filter_h / bin_bw);
+    if(debug)
+	{
+	printf("\nStart drawspectrum debug: y = %d \n", y);
+	printf("f1 = %d, f2 = %d\n",f1, f2);
+	printf("%s %d, ", "spectrumFrame->width() = ", spectrumFrame->width());
+	printf("%s %d \n", "spectrumFrame->height() = ", spectrumFrame->height());
+	printf("%s %d, ", "spectrogram->width() = ", spectrogram->width());
+	printf("%s %d \n", "spectrogram->height() = ", spectrogram->height());
+	printf("%s %d \n", "spectrum_width = ", spectrum_width);
+	printf("x1 = %d, x2 = %d\n", x1, x2);
+	printf("sample_rate = %d \n", sample_rate);
+	printf("kHz_step = %.2f Hz, ", kHz_step);     
+	printf("bin_bw = %.2f Hz\n", bin_bw);
+	}
 
-    QPixmap pix( spectrumFrame->width(), spectrumFrame->height() );
-    pix.fill( QColor( 0,0,0 ) );
-         
-    x1 = DEFSPEC/2 - spectrogram->width()/2;
-    x2 = x1 + spectrogram->width();
-    kHz_step = 1000 / ( sample_rate / 4096.0 );
-    
     QPainter p;
-    p.begin( &pix );
-    p.setFont ( *font1 );
-
-	p.fillRect( f1, 0, f2-f1+1, 120, QColor( 0, 50, 0 ) );
-
-	// Draw Spectrum
-    for ( x = 0; x < spectrumFrame->width(); x++ ) {
-        p.setPen( QColor( 0, 200, 0 ) );
-        p.drawLine( x, spectrumFrame->height() - 
-					spectrum_history[y][x + x1],
-                    x + 1, spectrumFrame->height() - 
-					spectrum_history[y][x + x1 + 1]  );
-    }
-
-    // Draw the 1 kHz positive marks
+    p.begin( this ); 
+    p.scale( (1.0 / hScale), 1.0);  	// set the horizontal scaling value 
+    if(hScale > 2.0)
+		p.setFont ( *font2 );
+    else
+    	p.setFont ( *font1 );
+
+	//////////////////////////////////  erase last spectrogram frame & redraw filter
+    p.eraseRect( 2, spectrogram->height() + PBSFRM_V + TOPFRM_V, spectrum_width,
+				spectrumFrame->height() + 6  ); // erase last spectrogram
+	//////////////// next line puts in dark green area showing audio bandpass filter   
+    p.fillRect( f1 , 0 + spectrogram->height() + PBSFRM_V + TOPFRM_V, f2 - f1,
+				spectrumFrame->height() + 4 , QColor( 0, 50, 0 ) );
+    //////////////////// Draw the 1 kHz positive marks and the vertical lines below them.
     f = 0;
-    for ( double dx = spectrumFrame->width()/2; 
-		  dx <= spectrumFrame->width(); 
+    for ( double dx = spectrum_width / 2; 
+		  dx <= spectrum_width; 
 		  dx = dx + kHz_step ) {
         p.setPen( QColor( 100, 100, 100 ) );
-        p.drawLine( (int)rint(dx), 
-					font1Metrics->ascent(), 
-					(int)rint(dx), 
-					spectrumFrame->height() );
+        p.drawLine( (int)rint(dx) + 2, 
+			font1Metrics->ascent() + spectrogram->height() + PBSFRM_V + TOPFRM_V, 
+			(int)rint(dx) + 2, 
+			spectrumFrame->height() + spectrogram->height() + PBSFRM_V + TOPFRM_V );
         //sprintf( f_text, "%lf", (double)((rx_f + f) / 1000000.0) );
 		sprintf( f_text, "%d", f );
         p.setPen( QColor( 255, 255, 255 ) );
-        p.drawText( (int)rint(dx) - (font1Metrics->maxWidth() * 
-									 strlen( f_text )) / 2, 
-					10, 
-					f_text );
-        f = f + 1000;
+        if(hScale > 2.0) {
+	    f = f + 5000;
+            p.drawText( ((int)rint(dx) + 1) - (font2Metrics->maxWidth() * 
+				 strlen( f_text )) / 2, 
+			20 + spectrogram->height() + PBSFRM_V + TOPFRM_V, 
+			f_text );
+	    } else {
+	    f = f + 1000;
+            p.drawText( ((int)rint(dx) + 1) - (font1Metrics->maxWidth() * 
+				 strlen( f_text )) / 2, 
+			10 + spectrogram->height() + PBSFRM_V + TOPFRM_V, 
+			f_text );
+	    }
     }
-
-    // Draw the 1 kHz negative marks
-    f = -1000;
-    for ( double dx = spectrumFrame->width()/2 - kHz_step; 
+    //////////////////// Draw the 1 kHz negative marks and the vertical lines below them.
+    if(hScale > 2.0)
+		f = -5000;
+    else
+		f = -1000;
+    for ( double dx = spectrum_width / 2 - kHz_step; 
 		  dx >= 0; 
 		  dx = dx - kHz_step ) {
         p.setPen( QColor( 100, 100, 100 ) );
-        p.drawLine( (int)rint(dx), 
-					font1Metrics->ascent(), 
-					(int)rint(dx), 
-					spectrumFrame->height() );
+        p.drawLine( (int)rint(dx) + 2, 
+			font1Metrics->ascent() + spectrogram->height() + PBSFRM_V + TOPFRM_V, 
+			(int)rint(dx) + 2, 
+			spectrumFrame->height() + spectrogram->height() + PBSFRM_V + TOPFRM_V );
+					
         //sprintf( f_text, "%lf", (double)((rx_f + f) / 1000000.0) );
         sprintf( f_text, "%d", f );
         p.setPen( QColor( 255, 255, 255 ) );
-        //p.drawText( (int)rint(dx) + 2, 10, f_text );
-        p.drawText( (int)rint(dx) - (font1Metrics->maxWidth() * 
-									 (strlen( f_text ) + 1)) / 2, 
-					10, 
-					f_text );
-        f = f - 1000;
+        if(hScale > 2.0)
+	    {
+            p.drawText( ((int)rint(dx) + 1) - (font2Metrics->maxWidth() * 
+					(strlen( f_text ) + 1)) / 2, 
+			20 + spectrogram->height() + PBSFRM_V + TOPFRM_V, 
+			f_text );		
+	    f = f - 5000;
+	    } else {
+            p.drawText( ((int)rint(dx) + 1) - (font1Metrics->maxWidth() * 
+					(strlen( f_text ) + 1)) / 2, 
+			10 + spectrogram->height() + PBSFRM_V + TOPFRM_V, 
+			f_text );		
+	    f = f - 1000;
+	    }
     }
-
-    // Draw the dB marks
-    for ( int i = 20; i < 120; i += 20 ) {
+    ///////////////////////////////////////////////////////////// Now, Draw the dB marks
+    for ( int i = 20; i < SPECFRM_V; i += 20 ) {
         p.setPen( QColor( 100, 100, 100 ) );
-        p.drawLine( 1, i, spectrumFrame->width() - 2, i );
-    }    
-
-	// Draw the color aperture lines
+        p.drawLine( 1, i + spectrogram->height() + PBSFRM_V + TOPFRM_V, spectrum_width - 2,
+						 i + spectrogram->height() + PBSFRM_V + TOPFRM_V );
+    }
+	////////////////////////////////////////////////// Draw the color aperture lines
 	QPen pen( Qt::DotLine );
 	pen.setColor( QColor( 255, 50, 0 ) );
 	p.setPen( pen );
-	p.drawLine( 0, (int)(specApertureLow - 120) * -1, 
-				spectrumFrame->width(), (int)(specApertureLow - 120) * -1 );
-	p.drawLine( 0, (int)(specApertureHigh - 120) * -1,
-				spectrumFrame->width(), (int)(specApertureHigh - 120) * -1);
-
-    // Draw the dB labels
-    for ( int i = 0; i < 120; i += 20 ) {
+	p.drawLine( 2, (int)(specApertureLow - SPECFRM_V) * -1 + spectrogram->height() + PBSFRM_V+TOPFRM_V, 
+				spectrum_width, (int)(specApertureLow - SPECFRM_V) * 
+					-1 + spectrogram->height() + PBSFRM_V + TOPFRM_V );
+	p.drawLine( 2, (int)(specApertureHigh - SPECFRM_V) * -1 + spectrogram->height() +PBSFRM_V+TOPFRM_V,
+				spectrum_width, (int)(specApertureHigh - SPECFRM_V) *
+					 -1  + spectrogram->height() + PBSFRM_V + TOPFRM_V);
+    //////////////////////////////////////////////////////////////// Draw the dB labels
+    for ( int i = 0; i < SPECFRM_V; i += 20 )
+	{
         p.setPen( QColor( 255, 255, 255 ) );
         sprintf( f_text, "%d", -i - 40 );
-        p.drawText( 2, i + 19, f_text );
+        p.drawText( 4, i + 19 + spectrogram->height() + PBSFRM_V + TOPFRM_V, f_text );        
         sprintf( f_text, "%4d", -i - 40 );
-        p.drawText( spectrumFrame->width() - 
-					font1Metrics->maxWidth() * 4 - 2, i + 19, f_text );
+		if(hScale > 2) {
+            p.drawText( spectrum_width - 
+			font2Metrics->maxWidth() * 4 - 2,
+				i + 19 + spectrogram->height() + PBSFRM_V + TOPFRM_V, f_text );
+
+	    } else {
+            p.drawText( spectrum_width - 
+			font1Metrics->maxWidth() * 4 - 2,
+				i + 19 + spectrogram->height() + PBSFRM_V + TOPFRM_V, f_text );
+	    }
     }    
 
-    p.end();
+	////////////////////////////////////////// Finally, Draw the actual Spectrum data
+	// Average the last N samples of spectrum data
+	if (specAveraging > 1) {
+		memset(spectrum_data, 0, sizeof(int) * DEFSPEC);
+		for (y1 = y, n=0; n < specAveraging; n++) {
+    		for ( x = 1; x < DEFSPEC; x++ ) {
+				spectrum_data[x] += spectrum_history[y1][x];
+			}
+			y1--;
+			if (y1 < 0)
+				y1 = spectrogram->height() - 1;
+			}
+    	for ( x = 1; x < DEFSPEC; x++ ) {
+			spectrum_data[x] = spectrum_data[x] / specAveraging;
+		}
+	}
 
-    bitBlt( spectrumFrame, 0, 0, &pix, 
-			0, 0, pix.width(), pix.height(), Qt::CopyROP, true ); 
+    y1 =  spectrogram->height() + PBSFRM_V + TOPFRM_V + spectrumFrame->height();
+    p.setPen( Qt::green );
+
+	// Draw Spectrum                     + 2
+    for ( x = 1; x < spectrumFrame_width_less1 ; x++ )
+	{
+    	if(specLineFill) {
+			if (specAveraging <= 1)
+        		p.drawLine( x, spectrogram->height() + PBSFRM_V + TOPFRM_V + SPECFRM_V,
+           	   	      x, spectrogram->height() + PBSFRM_V + TOPFRM_V + SPECFRM_V - 
+						spectrum_history[y][x + x1 + 1] * vsScale );
+			else
+        		p.drawLine( x, spectrogram->height() + PBSFRM_V + TOPFRM_V + SPECFRM_V,
+           	   	      x, spectrogram->height() + PBSFRM_V + TOPFRM_V + SPECFRM_V - 
+						spectrum_data[x + x1 + 1] *vsScale );
+		} else {
+			if (specAveraging <= 1)
+        		p.drawLine( x - 1, spectrogram->height() + PBSFRM_V + TOPFRM_V + SPECFRM_V - 
+						spectrum_history[y][x + x1]*vsScale ,
+           	         	x, spectrogram->height() + PBSFRM_V + TOPFRM_V + SPECFRM_V - 
+						spectrum_history[y][x + x1 + 1] *vsScale );
+			else
+        		p.drawLine( x - 1, spectrogram->height() + PBSFRM_V + TOPFRM_V + SPECFRM_V - 
+						spectrum_data[x + x1]*vsScale ,
+                    	x, spectrogram->height() + PBSFRM_V + TOPFRM_V + SPECFRM_V - 
+						spectrum_data[x + x1 + 1] *vsScale );
+		}
+    }
+	p.end();   		 
 }
 
-void Main_Widget::spectrogramClicked( int x )
+
+void Main_Widget::spectrogramClicked ( int x )
 {
-    int f;
+	int f;
+
+	int f_limit = sample_rate/2 - 2000;
+	if ( !useIF )  // Disable changing frequency for IF mode.  Use arrows for IF shift.
+	{
+		//f = ( int ) ( ( sample_rate/(float)spec_width ) * ( spectrogram->width() /2 - x ) );
+		f = (int)(bin_bw * (spectrogram->width() / 2 - x) * hScale);
+		
+        if(verbose) fprintf(stderr, "spectrogramClicked: x = %d f = %d rx_f = %lld freq = %.6lf\n", x, f, rx_f,
+			(double)( (rx_f - rx_delta_f) - f ) / 1000000.0);
+
+		if ( rock_bound )
+		{
+			rx_delta_f = rx_delta_f + f + *filter_l + ( *filter_h - *filter_l ) / 2 ;	
+			if ( rx_delta_f >  f_limit ) {
+				rx_delta_f =  f_limit;
+			} else if ( rx_delta_f < -f_limit ) {
+				rx_delta_f = -f_limit;
+			}
+		    setRxFrequency( 0 );
+		} else {
+			// Clicking re-tunes the synth and osc.  Set osc to center.
+			rx_f -= rx_delta_f;
+			rx_delta_f =  tuneCenter;	//Make it not tuned to the center
+			rx_f += rx_delta_f;
 
-    int f_limit = sample_rate/2 - 2000;
+			rx_f = rx_f - f - *filter_l - ( *filter_h - *filter_l ) / 2;
+			setRxFrequency( 1 );
+		}
+	}
+}
 
-    f = (int)((sample_rate/4096.0)*(spectrogram->width()/2 - x));
+void Main_Widget::f_at_mousepointer ( int x )
+{
+	int f;
+	char temp[32];
+
+	//f = ( int ) ( ( sample_rate/(float)spec_width ) * ( spectrogram->width() /2 - x ) );
+	f = (int)((bin_bw) * (spectrogram->width()/2 - x) * hScale);
+	//f = (int)((bin_bw) * (spectrum_width / 2 - x));
 
-    rx_delta_f = rx_delta_f + f + *filter_l + ( *filter_h - *filter_l ) / 2 ;
-    if ( rx_delta_f >  f_limit ) rx_delta_f =  f_limit;
-    if ( rx_delta_f < -f_limit ) rx_delta_f = -f_limit;
-    setRxFrequency();
+	snprintf ( temp, 32, "%.6lf", ( double ) ( (rx_f - rx_delta_f) - f ) / 1000000.0 );
+	M_label->setText ( temp );
 }
 
-void Main_Widget::f_at_mousepointer( int x )
+void Main_Widget::tune ( int x )
 {
-    int f;
-    char temp[20];
+	int f_limit = sample_rate/2 - 2000;
 
-    f = (int)((sample_rate/4096.0)*(spectrogram->width()/2 - x));
-    
-    sprintf( temp, "%.6lf", (double)( rx_f - f ) / 1000000.0 );
-	M_label->setText( temp );}
+	// if (spectrogram->width() < spec_width)
+	// f_limit = sample_rate / 2 - spectrogram->width() / 2
+
+	// use usbsoftrock if the tuning step is large enough
+//	if (!rock_bound && ( x > 10000 || x < -10000 )) {
+
+	if (!rock_bound && ( x > 500 || x < -500 )) {
+		rx_delta_f = tuneCenter;
+		rx_f = rx_f + x;
+		setRxFrequency( 1 );
+	} else {
+		rx_delta_f += x;
+		if ( rx_delta_f >  f_limit ) rx_delta_f =  f_limit;
+		if ( rx_delta_f < -f_limit ) rx_delta_f = -f_limit;
+		setRxFrequency( 0 );
+	}
+}
 
-void Main_Widget::tune( int x )
+void Main_Widget::tunef ( int x )
 {
-    int f_limit = sample_rate/2 - 2000;
-    
-    rx_delta_f += x;
-    if ( rx_delta_f >  f_limit ) rx_delta_f =  f_limit;
-    if ( rx_delta_f < -f_limit ) rx_delta_f = -f_limit;
-    setRxFrequency();
+	int f_limit = sample_rate/2 - 2000;
+
+	// use usbsoftrock if the tuning step is large enough
+	if (!rock_bound ) {
+		if ( x > 500 || x < -500 ) {
+			rx_f -= rx_delta_f;
+			rx_delta_f = tuneCenter;
+			rx_f = rx_f + x;
+			rx_f += rx_delta_f;
+			setRxFrequency( 1 );
+		} else {
+			rx_delta_f += x;
+			// Re-tune when hit the edges
+			if ( rx_delta_f >  f_limit || rx_delta_f < -f_limit ) {
+				rx_f -= rx_delta_f;
+				rx_delta_f = tuneCenter;
+				rx_f += rx_delta_f;
+				setRxFrequency( 1 );
+			} else {
+				setRxFrequency( 0 );
+			}
+		}
+	} else {
+		rx_delta_f += x;
+		if ( rx_delta_f >  f_limit ) rx_delta_f =  f_limit;
+		if ( rx_delta_f < -f_limit ) rx_delta_f = -f_limit;
+		setRxFrequency( 0 );
+	}
 }
+void Main_Widget::tunewheel ( int steps )
+{
+	int x = pow ( 10, tuneStep ) * steps;
 
-void Main_Widget::focusInEvent( QFocusEvent * )
+	tunef( x );
+}
+
+void Main_Widget::focusInEvent ( QFocusEvent * )
 {
-    ctlFrame->setPaletteBackgroundColor( QColor( 255, 200, 0 ) );
+    //ctlFrame->setPalette( QColor( 255, 200, 0 ) );
+    ctlFrame->setPalette( QColor( 0, 0, 0 ) );
+    ctlFrame->setAutoFillBackground(true);
 }
 
-void Main_Widget::focusOutEvent( QFocusEvent * )
+void Main_Widget::focusOutEvent ( QFocusEvent * )
 {
-    ctlFrame->setPaletteBackgroundColor( QColor( 50, 50, 50 ) );
+    //ctlFrame->setPalette( QColor( 255, 200, 0 ) );
+    ctlFrame->setPalette( QColor( 0, 0, 0 ) );
+    ctlFrame->setAutoFillBackground(true);
 }
 
 void Main_Widget::processorLoad()
 {
-    char tmp[20];
+	char tmp[20];
 	double loadavg[3];
 
-    getloadavg(loadavg, sizeof(loadavg) / sizeof(loadavg[0]));
-    sprintf( tmp, "CPU: %5.2f\n", loadavg[0] );
-    CPU_label->setText( tmp );
+	getloadavg ( loadavg, sizeof ( loadavg ) / sizeof ( loadavg[0] ) );
+	snprintf ( tmp, 20, "CPU: %5.2f\n", loadavg[0] );
+	CPU_label->setText ( tmp );
 }
 
-void Main_Widget::toggle_NR( int )
+void Main_Widget::toggle_NR ( int )
 {
-    set_NR( !NR_state );
+	set_NR ( !NR_state );
 }
 
-void Main_Widget::set_NR( int state )
+void Main_Widget::set_NR ( int state )
 {
-    NR_state = state;    
-    if ( NR_state ) NR_label->setBackgroundColor( QColor( 0, 100, 200 ) );
-    else NR_label->setBackgroundColor( QColor( 0, 0, 0 ) );
+	NR_state = state;
+    if ( NR_state ) NR_label->setPalette( QColor( 0, 100, 200 ) );
+    else NR_label->setPalette( QColor( 0, 0, 0 ) );
+    NR_label->setAutoFillBackground( true );
+    set_NRvals();
+	pCmd->sendCommand ("setNR %d\n", state );
+    if(verbose) fprintf ( stderr, "setNR %d\n", state );
 
-    fprintf( cmdFile, "setNR %d\n", state );
-    fflush( cmdFile );
 }
 
-void Main_Widget::toggle_ANF( int )
+void Main_Widget::set_NRvals (  )
 {
-    set_ANF( !ANF_state );
+      pCmd->sendCommand ("setNRvals %d %d %f %f\n", NR_Taps, NR_Delay, NR_Gain, NR_Leakage);
+      if(verbose) fprintf ( stderr, "setNRvals %d, %d, %f, %f\n", NR_Taps, NR_Delay, NR_Gain, NR_Leakage );
+}
+void Main_Widget::set_ANFvals (  )
+{
+      pCmd->sendCommand ("setANFvals %d %d %f %f\n", ANF_Taps, ANF_Delay, ANF_Gain, ANF_Leakage);
+      if(verbose) fprintf ( stderr, "setANFNRvals %d, %d, %f, %f\n", ANF_Taps, ANF_Delay, ANF_Gain, ANF_Leakage );
+}
+void Main_Widget::set_NBvals (  )
+{
+      pCmd->sendCommand ("setNBvals %f\n", NB_Threshold );
+      if(verbose) fprintf ( stderr, "setNBvals %f\n", NB_Threshold );
+}
+
+void Main_Widget::toggle_ANF ( int )
+{
+	set_ANF ( !ANF_state );
+}
+
+void Main_Widget::set_ANF ( int state )
+{
+	ANF_state = state;
+    if ( ANF_state ) ANF_label->setPalette( QColor( 0, 100, 200 ) );
+    else ANF_label->setPalette( QColor( 0, 0, 0 ) );
+    ANF_label->setAutoFillBackground( true );
+
+	pCmd->sendCommand ("setANF %d\n", ANF_state );
+    if(verbose) fprintf ( stderr, "setANF %d\n", ANF_state );
+}
+
+void Main_Widget::toggle_NB ( int )
+{
+	set_NB ( !NB_state );
 }
 
-void Main_Widget::set_ANF( int state )
+void Main_Widget::set_NB ( int state )
 {
-    ANF_state = state;
-    if ( ANF_state ) ANF_label->setBackgroundColor( QColor( 0, 100, 200 ) );
-    else ANF_label->setBackgroundColor( QColor( 0, 0, 0 ) );
+	NB_state = state;
+    if ( NB_state ) NB_label->setPalette( QColor( 0, 100, 200 ) );
+    else NB_label->setPalette( QColor( 0, 0, 0 ) );
+    NB_label->setAutoFillBackground( true );
 
-    fprintf( cmdFile, "setANF %d\n", ANF_state );
-    fflush( cmdFile );
+	pCmd->sendCommand ("setNB %d\n", NB_state );
+    if(verbose) fprintf ( stderr, "setNB %d\n", NB_state );
 }
 
-void Main_Widget::toggle_NB( int )
+void Main_Widget::toggle_BIN ( int )
 {
-    set_NB( !NB_state );
+	set_BIN ( !BIN_state );
 }
 
-void Main_Widget::set_NB( int state )
+void Main_Widget::set_BIN ( int state )
 {
-    NB_state = state;
-    if ( NB_state ) NB_label->setBackgroundColor( QColor( 0, 100, 200 ) );
-    else NB_label->setBackgroundColor( QColor( 0, 0, 0 ) );
+	BIN_state = state;
+    if ( BIN_state ) BIN_label->setPalette( QColor( 200, 0, 0 ) );
+    else BIN_label->setPalette( QColor( 0, 0, 0 ) );
+    BIN_label->setAutoFillBackground( true );
 
-    fprintf( cmdFile, "setNB %d\n", NB_state );
-    fflush( cmdFile );
+	pCmd->sendCommand ("setBIN %d\n", BIN_state );
+    if(verbose) fprintf ( stderr, "setBIN %d\n", BIN_state );
 }
 
-void Main_Widget::toggle_BIN( int )
+void Main_Widget::toggle_MUTE ( int )
 {
-    set_BIN( !BIN_state );
+	set_MUTE ( !MUTE_state );
 }
 
-void Main_Widget::set_BIN( int state )
+void Main_Widget::set_MUTE ( int state )
 {
-    BIN_state = state;
-    if ( BIN_state ) BIN_label->setBackgroundColor( QColor( 200, 0, 0 ) );
-    else BIN_label->setBackgroundColor( QColor( 0, 0, 0 ) );
+	MUTE_state = state;
+    if ( MUTE_state ) MUTE_label->setPalette( QColor( 200, 0, 0 ) );
+    else MUTE_label->setPalette( QColor( 0, 0, 0 ) );
+    MUTE_label->setAutoFillBackground( true );
 
-    fprintf( cmdFile, "setBIN %d\n", BIN_state );
-    fflush( cmdFile );
+	pCmd->sendCommand ("setRunState %d\n", MUTE_state ? 0: 2 );
+    if(verbose) fprintf ( stderr, "setRunState %d\n", MUTE_state ? 0 : 2 );
 }
 
-void Main_Widget::toggle_MUTE( int )
+void Main_Widget::toggle_SPEC ( int )
 {
-    set_MUTE( !MUTE_state );
+	set_SPEC ( !SPEC_state );
 }
 
-void Main_Widget::set_MUTE( int state )
+void Main_Widget::set_SPEC ( int state )
 {
-    MUTE_state = state;
-    if ( MUTE_state ) MUTE_label->setBackgroundColor( QColor( 200, 0, 0 ) );
-    else MUTE_label->setBackgroundColor( QColor( 0, 0, 0 ) );
+	SPEC_state = state;
+    if ( SPEC_state ) SPEC_label->setPalette( QColor( 0, 150, 50 ) );
+    else SPEC_label->setPalette( QColor( 0, 0, 0 ) );
+    
+    SPEC_label->setAutoFillBackground( true );
+}
 
-    fprintf( cmdFile, "setRunState %d\n", MUTE_state ? 0 : 2 );
-    fflush( cmdFile );
+void Main_Widget::leave_band( int band )
+{
+    if(verbose) fprintf( stderr, "leave band %d\n", band );
+	writeMem( band_cell[band-1] );
 }
 
-void Main_Widget::toggle_SPEC( int )
+void Main_Widget::enter_band(int band)
 {
-    set_SPEC( !SPEC_state );
+    if(verbose) fprintf( stderr, "enter band %d\n", band );
+	readMem( band_cell[band-1] );
+
+	if (sdr_band != NULL) {
+		QString cmd = sdr_band;
+		QString b;
+		b.sprintf ("%d", band);
+		cmd += " ";
+		b += " ";
+		cmd += b;
+		b.sprintf ("%lld", rx_f - rx_delta_f);
+		cmd += " ";
+		cmd += b;
+        if(verbose) fprintf( stderr, "Set band: %s\n", qPrintable(cmd));
+		system(qPrintable(cmd));
+	}
 }
 
-void Main_Widget::set_SPEC( int state )
+void Main_Widget::band_UP ( int )
 {
-    SPEC_state = state;
-    if ( SPEC_state ) SPEC_label->setBackgroundColor( QColor( 0, 150, 50 ) );
-    else SPEC_label->setBackgroundColor( QColor( 0, 0, 0 ) );
+    if(verbose) fprintf( stderr, "Band UP\n");
+	leave_band( band );
+	band++;
+	if (band > 10)
+		band = 1;
+	enter_band( band );
 }
 
-void Main_Widget::setCfg( int )
+void Main_Widget::band_DOWN ( int )
+{
+    if(verbose) fprintf( stderr, "Band DOWN\n");
+	leave_band( band );
+	band--;
+	if (band < 1)
+		band = 10;
+	enter_band( band );
+}
+
+void Main_Widget::setCfg ( int )
 {
 	cfgFrame->show();
 }
 
-void Main_Widget::readMem( MemoryCell *m )
+void Main_Widget::setHelp ( int )
 {
-    setMode( m->getMode() );
-    rx_delta_f = m->getFrequency();
-    setRxFrequency();
+	helpFrame->show();
+}
+
+void Main_Widget::setDSP ( int )
+{
+	dspFrame->show();
+}
+
+void Main_Widget::TXoff ()
+{
+	transmit = 0;
+	if (enableTransmit)
+	{
+		pTXCmd->sendCommand ("setTRX 0\n");
+		pTXCmd->sendCommand ("setRunState 0\n");
+	}
+	if(!rock_bound) pUSBCmd->sendCommand("set ptt off\n" );
+	if(verbose) fprintf (stderr, "set ptt off\n");
+	TRX_label->setPixmap( QPixmap( rx_xpm ) );
+	TRX_label->setLabel( RX );
+	set_MUTE ( 0 );
+}
+
+void Main_Widget::TXon ()
+{
+	if (enableTransmit)
+	{
+		// if enableSPLIT   set USBSoftrock frequency
+		transmit = 1;
+		if (!rock_bound) pUSBCmd->sendCommand ("set ptt on\n" );
+
+		pTXCmd->sendCommand ("setRunState 2\n");
+		pTXCmd->sendCommand ("setTRX 1\n");
+
+		set_MUTE ( 1 );
+		if(verbose) fprintf (stderr, "set ptt on\n");
+		TRX_label->setPixmap( QPixmap( tx_xpm ) );
+		TRX_label->setLabel( TX );
+	}
+}
+
+void Main_Widget::toggle_TX ( int )
+{     
+	if (enableTransmit)
+	{
+		if(verbose) fprintf( stderr, "Toggle TX\n");
+		if (transmit) {
+			transmit = 0;
+			pTXCmd->sendCommand ("setTRX 0\n");
+			pTXCmd->sendCommand ("setRunState 0\n");
+			if (!rock_bound) pUSBCmd->sendCommand("set ptt off\n" );
+			if(verbose) fprintf (stderr, "set ptt off\n");
+			TRX_label->setPixmap( QPixmap( rx_xpm ) );
+			TRX_label->setLabel( RX );
+			set_MUTE ( 0 );
+			TXoff();
+		} else {
+			// if enableSPLIT   set USBSoftrock frequency
+			transmit = 1;
+			if (!rock_bound) pUSBCmd->sendCommand ("set ptt on\n" );
+			pTXCmd->sendCommand ("setRunState 2\n");
+			pTXCmd->sendCommand ("setTRX 1\n");
+			set_MUTE ( 1 );
+            if(verbose) fprintf (stderr, "set ptt on\n");
+			TRX_label->setPixmap( QPixmap( tx_xpm ) );
+			TRX_label->setLabel( TX );
+			TXon();
+		}
+	} else {
+		if(verbose) fprintf( stderr, "Transmit is not enabled\n");
+	}
+}
+
+void Main_Widget::set_RIT ( int state )
+{
+	enableRIT = state;
+	if ( enableRIT ) {
+    	RIT_label->setPalette(QColor(0, 0, 200) );
+		set_SPLIT( 0 );
+		tx_f = rx_f;
+		tx_delta_f = rx_delta_f;
+	} else {
+    	RIT_label->setPalette(QColor(0, 0, 0) );
+		rit->setText( "" );
+	}
+}
+
+void Main_Widget::toggle_RIT ( int )
+{
+	set_RIT(!enableRIT);
+}
+
+void Main_Widget::set_SPLIT ( int state )
+{
+	enableSPLIT = state;
+	if ( enableSPLIT ) {
+    	SPLIT_label->setPalette(QColor(0, 0, 200) );
+		set_RIT( 0 );
+		tx_f_string.sprintf ("%11.6lf", 
+			( double ) ( tx_f - tx_delta_f ) / 1000000.0 );
+        if(verbose) fprintf(stderr, "set_SPLIT %s\n", qPrintable(tx_f_string));
+		rit->setText( tx_f_string );
+	} else {
+    	SPLIT_label->setPalette(QColor(0, 0, 0) );
+		rit->setText( "" );
+	}
+}
+
+void Main_Widget::toggle_SPLIT ( int )
+{
+	tx_f = rx_f;
+	tx_delta_f = rx_delta_f;
+	set_SPLIT(!enableSPLIT);
+}
+
+
+void Main_Widget::readMem ( MemoryCell *m )
+{
+    if(verbose) printf("readMem %d = %lld %lld\n", m->getID(), m->getFrequency(), m->getTxFrequency());
+	setMode ( ( rmode_t ) m->getMode(), FALSE, FALSE );
+	if ( rock_bound ) {
+		rx_delta_f = m->getFrequency();
+		if ((rx_delta_f > spec_width) || (rx_delta_f < -spec_width)) {
+        if(verbose) fprintf(stderr, "Error: frequency outside spectrum (%d <-> %d).  Reset it to 0\n",
+				rx_delta_f, spec_width);
+			rx_delta_f = 0;
+		}
+		setRxFrequency( 0 );
+	} else {
+		rx_delta_f = tuneCenter;
+		rx_f = m->getFrequency();
+		rx_f += rx_delta_f;
+        if(verbose) fprintf (stderr, "set freq %f\n", (rx_f)*1e-6 );
+		pUSBCmd->sendCommand("set freq %f\n", (rx_f)*1e-6);
+		tx_f = m->getTxFrequency();
+		set_RIT( 0 );	// do this before set_SPLIT, as it clears the RIT text
+		if (tx_f != 0) {
+			tx_delta_f = tuneCenter;
+			tx_f += tx_delta_f;
+			set_SPLIT ( TRUE );
+		} else {
+			set_SPLIT ( FALSE );
+		}
+		setRxFrequency( 1 );
+	}
 	*filter_l = m->getFilter_l();
 	*filter_h = m->getFilter_h();
-    setFilter();        	
+	setFilter();
 }
 
-void Main_Widget::writeMem( MemoryCell *m )
+void Main_Widget::writeMem ( MemoryCell *m )
 {
-    m->setFrequency( rx_delta_f );
-    m->setMode( mode );
-	m->setFilter( *filter_l, *filter_h );
+    if(verbose) printf("writeMem %d = (%lld - %d) %lld\n", m->getID(), rx_f, rx_delta_f,
+		rx_f - rx_delta_f);
+	if (rock_bound) {
+		m->setFrequency ( rx_delta_f );
+	} else {
+		m->setFrequency ( rx_f - rx_delta_f );
+		if (enableSPLIT) {
+			m->setTxFrequency ( tx_f - tx_delta_f );
+		} else {
+			m->setTxFrequency ( 0 );
+		}
+	}
+	m->setMode ( mode );
+	m->setFilter ( *filter_l, *filter_h );
 }
 
-void Main_Widget::displayMem( MemoryCell *m )
+void Main_Widget::displayMem ( MemoryCell *m )
 {
-	char temp[20];
-	sprintf( temp, "%lf", (double)( rx_f - m->getFrequency() ) / 1000000.0 );
-	M_label->setText( temp );
+	char temp[32];
+	snprintf ( temp, 32, "%lf", ( double ) ( m->getFrequency() ) / 1000000.0 );
+	M_label->setText ( temp );
+    if(verbose) printf("displayMem %d, %lld\n", m->getID(), m->getFrequency());
 }
 
-void Main_Widget::displayNCO( int x )
+void Main_Widget::displayNCO ( int x )
 {
 	int pb_f;
-	char temp[20];
-	static float bin_bw = sample_rate/4096.0;
-    pb_f = (int)(((x - (spectrogram->width() / 2)) * bin_bw)) /10*10;
-	sprintf( temp, "%d", pb_f );
-	M_label->setText( temp );
+	char temp[32];
+	float bin_bw = sample_rate/(float)spec_width;
+	//pb_f = ( int ) ( ( ( x - ( spectrogram->width() / 2 ) ) * bin_bw ) ) /10*10;
+	pb_f = (int)(((x - (spectrogram->width() / 2)) * bin_bw) * hScale) / 10*10;  
+
+	snprintf ( temp, 32, "%d", pb_f );
+	M_label->setText ( temp );
 }
 
 void Main_Widget::updateCallsign()
 {
+	QString version;
+	version.sprintf("%5.2f", VERSION);
 	stationCallsign = cfgCallInput->text();
-	setCaption( "SDR-Shell v2b @ " + stationCallsign );
+	setWindowTitle("SDR-Shell " + version + " @ " + stationCallsign );
 }
 
 void Main_Widget::updateLOFreq()
 {
-    rx_f = cfgLOFreqInput->text().toLongLong();
+	rx_f = cfgLOFreqInput->text().toLongLong();
 	rx_f_string = cfgLOFreqInput->text();
-	setRxFrequency();
+	if ( useIF ) setDefaultRxFrequency();
+	else setRxFrequency( 1 );
+}
+
+void Main_Widget::updateTuneOffset()
+{
+    //if(verbose) fprintf(stderr, "updateTuneOffset = %s\n", qPrintable(cfgTuneOffsetInput->text()));
+	tuneCenter = cfgTuneOffsetInput->text().toInt();
+    if(verbose) fprintf(stderr, "updateTuneOffset = %d\n", tuneCenter);
+	rx_f -= rx_delta_f;
+	rx_delta_f =  tuneCenter;	//Make it not tuned to the center
+	rx_f += rx_delta_f;
+	setRxFrequency( 1 );
+}
+
+void Main_Widget::updateIFreq()
+{
+	rx_if = cfgIFreqInput->text().toLongLong();
+	rx_if_string = cfgIFreqInput->text();
+	setDefaultRxFrequency();
+}
+void Main_Widget::updateHamlib()
+{
+	portString = cfgHamlibPortInput->text();
+	speedString = cfgHamlibSpeedInput->text();
+	speed = speedString.toInt();
+	rigString = cfgHamlibRigInput->text();
+	rig = ( rig_model_t ) rigString.toInt();
 }
 
-void Main_Widget::updateIQGain( int gain )
+void Main_Widget::updateIQGain ( int gain )
 {
-    iqGain = gain;
+	iqGain = gain;
 	setIQGain();
 }
 
-void Main_Widget::updateIQPhase( int phase )
+void Main_Widget::updateIQPhase ( int phase )
 {
-    iqPhase = phase;
+	iqPhase = phase;
 	setIQPhase();
 }
 
-void Main_Widget::setPolyFFT( int state )
+void Main_Widget::updateTxIQGain ( int gain )
+{
+	txIQGain = gain;
+	setTxIQGain();
+}
+
+void Main_Widget::updateTxIQPhase ( int phase )
 {
-	polyphaseFFT = state;
-    fprintf( cmdFile, "setSpectrumPolyphase %d\n", state );
-    fflush( cmdFile );
+	txIQPhase = phase;
+	setTxIQPhase();
 }
 
-void Main_Widget::setFFTWindow( int window )
+void Main_Widget::updateTxMicGain ( int gain )
 {
-	fftWindow = window;
-    fprintf( cmdFile, "setSpectrumWindow %d\n", window );
-    fflush( cmdFile );
+	micGain = gain;
+	setTxGain( 0 );
 }
 
-void Main_Widget::setSpectrumType( int type )
+void Main_Widget::updateTxOutputGain ( int gain )
 {
-	spectrumType = type;
-    fprintf( cmdFile, "setSpectrumType %d\n", type + 1 );
-    fflush( cmdFile );
+	txGain = gain;
+	setTxGain( 1 );
 }
 
-void Main_Widget::setAGC( int type )
+void Main_Widget::setPolyFFT ( )
+{
+	if(polyFFT_button->isChecked())
+		polyphaseFFT = 1;
+	else
+		polyphaseFFT = 0;
+        //polyphaseFFT = ~polyphaseFFT;
+    pCmd->sendCommand ("setSpectrumPolyphase %d\n", polyphaseFFT );
+    if(verbose) fprintf ( stderr, "setSpectrumPolyphase %d\n", polyphaseFFT );
+}
+
+void Main_Widget::setFFTWindow ( )
+{
+    if ( fftWindow_0->isChecked() )
+       { fftWindow = 0; }
+    else 
+     if ( fftWindow_1->isChecked() )
+        {  fftWindow = 1; }
+     else
+      if ( fftWindow_2->isChecked() )
+         {  fftWindow = 2; }
+      else
+       if ( fftWindow_3->isChecked() )
+          {  fftWindow = 3; }
+       else
+        if ( fftWindow_4->isChecked() )
+           {  fftWindow = 4; }
+        else
+         if ( fftWindow_5->isChecked() )
+            {  fftWindow = 5; }
+         else
+          if ( fftWindow_6->isChecked() )
+             {  fftWindow = 6; }
+          else
+           if ( fftWindow_7->isChecked() )
+              {  fftWindow = 7; }
+           else
+            if ( fftWindow_8->isChecked() )
+               {  fftWindow = 8; }
+            else
+             if ( fftWindow_9->isChecked() )
+                {  fftWindow = 2; }
+             else
+              if ( fftWindow_10->isChecked() )
+                 {  fftWindow = 10; }
+              else
+               if ( fftWindow_11->isChecked() )
+                  {  fftWindow = 11; }
+               else
+                  {  fftWindow = 12; };
+           
+	pCmd->sendCommand ("setSpectrumWindow %d\n", fftWindow );
+    if(verbose) fprintf ( stderr, "setSpectrumWindow %d\n", fftWindow );
+}
+
+void Main_Widget::setSpectrumType()
+{
+	if ( preFilter_button->isChecked() )
+	   { spectrumType = 1; }		// SPEC_PRE_FILT
+	else
+	   { spectrumType = 2; };		// SPEC_POST_FILT
+	pCmd->sendCommand ("setSpectrumType %d\n", spectrumType );
+    if(verbose) fprintf ( stderr, "setSpectrumType %d\n", spectrumType );
+
+}
+
+void Main_Widget::setSpectrumDefaults()
+{
+    if(verbose) fprintf(stderr, "setSpectrumType %d\n", spectrumType );
+    if(verbose) fprintf(stderr, "setSpectrumWindow %d\n", fftWindow );
+    if(verbose) fprintf(stderr, "setSpectrumPolyphase %d\n", polyphaseFFT );
+	pCmd->sendCommand ("setSpectrumType %d\n", spectrumType );
+	pCmd->sendCommand ("setSpectrumWindow %d\n", fftWindow );
+	pCmd->sendCommand ("setSpectrumPolyphase %d\n", polyphaseFFT );
+}    
+
+void Main_Widget::updateSpecAvg ( int gain )
+{
+	specAveraging = gain;
+}
+
+void Main_Widget::setLineFill ( )
+{
+    if ( specLineFillButton->isChecked() )
+		specLineFill = 1;
+	else
+		specLineFill = 0;
+}
+
+void Main_Widget::updateSpecLow ( int value )
+{
+	specLow = value;
+	if (specLow >= specHigh)
+		specLow = specHigh - 1;
+	else
+	updateSpecHigh(specHigh);
+}
+
+void Main_Widget::updateSpecHigh ( int value )
+{
+	float a;
+	specHigh = value;
+	if (specHigh <= specLow)
+		specHigh = specLow + 1;
+	// vsScale is the vertical spectrum scale
+	// 1.0 = -40 to -140
+	a = (specLow - specHigh) * -1;
+	if (a > 100)
+		a = 100;
+	vsScale = 100 / a;
+    if(verbose) fprintf(stderr, "vsScale = (%d to %d) %f %f\n", specLow, specHigh, a, vsScale);
+}
+
+void Main_Widget::setAGC ( int type )
 {
 	agcType = type;
-    fprintf( cmdFile, "setRXAGC %d\n", type );
-    fflush( cmdFile );
+	pCmd->sendCommand ("setRXAGC %d\n", type );
+    if(verbose) fprintf ( stderr, "setRXAGC %d\n", type );
 
-	QColor on( 150, 50, 50 );
-	QColor off( 0, 0, 0 );
+	QColor on ( 150, 50, 50 );
+	QColor off ( 0, 0, 0 );
 
+    //AGC_O_label->setAutoFillBackground(true);
+    AGC_L_label->setAutoFillBackground(true);
+    AGC_S_label->setAutoFillBackground(true);
+    AGC_M_label->setAutoFillBackground(true);
+    AGC_F_label->setAutoFillBackground(true);
 	switch( type ) {
 	case 0:
-		//AGC_O_label->setBackgroundColor( on ); 
-		AGC_L_label->setBackgroundColor( off );
-		AGC_S_label->setBackgroundColor( off );
-		AGC_M_label->setBackgroundColor( off );
-		AGC_F_label->setBackgroundColor( off );
+		//AGC_O_label->setPalette( on ); 
+		AGC_L_label->setPalette( off );
+		AGC_S_label->setPalette( off );
+		AGC_M_label->setPalette( off );
+		AGC_F_label->setPalette( off );
+		//AGC_O_label->setAutoFillBackground(true);
 		break;
 	case 1:
-		//AGC_O_label->setBackgroundColor( off );
-		AGC_L_label->setBackgroundColor( on );  
-		AGC_S_label->setBackgroundColor( off );
-		AGC_M_label->setBackgroundColor( off );
-		AGC_F_label->setBackgroundColor( off );
+		//AGC_O_label->setPalette( off );
+		AGC_L_label->setPalette( on ); 		 
+		AGC_S_label->setPalette( off );		
+		AGC_M_label->setPalette( off );		
+		AGC_F_label->setPalette( off );
+		
 		break;
 	case 2:
-		//AGC_O_label->setBackgroundColor( off );
-		AGC_L_label->setBackgroundColor( off );
-		AGC_S_label->setBackgroundColor( on );  
-		AGC_M_label->setBackgroundColor( off );
-		AGC_F_label->setBackgroundColor( off );
+		//AGC_O_label->setPalette( off );
+		AGC_L_label->setPalette( off );
+		AGC_S_label->setPalette( on );  
+		AGC_M_label->setPalette( off );
+		AGC_F_label->setPalette( off );
 		break;
 	case 3:
-		//AGC_O_label->setBackgroundColor( off );
-		AGC_L_label->setBackgroundColor( off );
-		AGC_S_label->setBackgroundColor( off );
-		AGC_M_label->setBackgroundColor( on );  
-		AGC_F_label->setBackgroundColor( off );
+		//AGC_O_label->setPalette( off );
+		AGC_L_label->setPalette( off );
+		AGC_S_label->setPalette( off );
+		AGC_M_label->setPalette( on );  
+		AGC_F_label->setPalette( off );
 		break;
 	case 4:
-		//AGC_O_label->setBackgroundColor( off );
-		AGC_L_label->setBackgroundColor( off );
-		AGC_S_label->setBackgroundColor( off );
-		AGC_M_label->setBackgroundColor( off );
-		AGC_F_label->setBackgroundColor( on );  
+		//AGC_O_label->setPalette( off );
+		AGC_L_label->setPalette( off );
+		AGC_S_label->setPalette( off );
+		AGC_M_label->setPalette( off );
+		AGC_F_label->setPalette( on );  
 		break;
 	default:
 		break;
 	}
 }
 
-void Main_Widget::calibrateSpec( int value )
+void Main_Widget::zoomIN ( int )
+{
+	if (hScale >= 3.0)
+		hScale = 2.0;
+	else if (hScale == 2.0)
+		hScale = 1.0;
+	else if (hScale == 1.0)
+		hScale = 0.75;
+	else if (hScale == 0.75)
+		hScale = 0.5;
+	else if (hScale == 0.5)
+		hScale = 0.25;
+	else if (hScale == 0.25)
+        {
+            if(verbose) fprintf(stderr, "Zoom in furthest\n");
+        }
+	else
+        {
+            if(verbose) fprintf(stderr, "Zoom in from %f\n", hScale);
+        }
+}
+
+void Main_Widget::zoomOUT ( int )
+{
+	if (hScale >= 3.0)
+    {
+        if(verbose) fprintf(stderr, "Zoom out furthest\n");
+    }
+	else if (hScale == 3.0)
+			hScale = sample_rate / (bin_bw * (geometry().width()-20)); // spectrumFrame->width());
+	else if (hScale == 2.0)
+		hScale = 3.0;
+	else if (hScale == 1.0)
+		hScale = 2.0;
+	else if (hScale == 0.75)
+		hScale = 1.0;
+	else if (hScale == 0.5)
+		hScale = 0.75;
+	else if (hScale == 0.25)
+		hScale = 0.5;
+	else
+    if(verbose) fprintf(stderr, "Zoom out from %f\n", hScale);
+}
+
+void Main_Widget::calibrateSpec ( int value )
+{
+	specCal = value;
+}
+
+void Main_Widget::calibrateMetr ( int value )
+{
+	metrCal = value;
+}
+
+// NR_Settings Glenn VE9GJ
+void Main_Widget::setNR_Taps ( int value )
+{
+    if(verbose) fprintf ( stderr, "NR_Taps spinbox changed to %d\n",value );
+    NR_Taps = value;
+    set_NRvals();
+}
+
+void Main_Widget::setNR_Delay ( int value )
+{
+    if(verbose) fprintf ( stderr, "NR_Delay spinbox changed to %d\n",value );
+    NR_Delay = value;
+    set_NRvals();
+}
+
+void Main_Widget::setNR_Gain ( double value )
+{
+    if(verbose) fprintf ( stderr, "NR_Gain spinbox changed to %f\n",float(value) );
+    NR_Gain = float(value);
+    set_NRvals();
+}
+
+void Main_Widget::setNR_Leakage ( double value )
+{
+    if(verbose) fprintf ( stderr, "NR_Leakage spinbox changed to %f\n",float(value) );
+    NR_Leakage = float(value);
+    set_NRvals();
+}
+
+void Main_Widget::setANF_Taps ( int value )
+{
+    if(verbose) fprintf ( stderr, "ANF_Taps spinbox changed to %d\n",value );
+    ANF_Taps = value;
+    set_ANFvals();
+}
+
+void Main_Widget::setANF_Delay ( int value )
+{
+    if(verbose) fprintf ( stderr, "ANF_Delay spinbox changed to %d\n",value );
+    ANF_Delay = value;
+    set_ANFvals();
+}
+
+void Main_Widget::setANF_Gain ( double value )
+{
+    if(verbose) fprintf ( stderr, "ANF_Gain spinbox changed to %f\n",float(value) );
+    ANF_Gain = float(value);
+    set_ANFvals();
+}
+
+void Main_Widget::setANF_Leakage ( double value )
+{
+    if(verbose) fprintf ( stderr, "ANF_Leakage spinbox changed to %f\n",float(value) );
+    ANF_Leakage = float(value);
+    set_ANFvals();
+}
+
+void Main_Widget::setNB_Threshold ( double value )
+{
+    if(verbose) fprintf ( stderr, "NB_Threshold spinbox changed to %f\n",value );
+    NB_Threshold = value;
+    set_NBvals();
+}
+
+
+void Main_Widget::setIF ( bool value )
+{
+    if(verbose) fprintf(stderr, "setIF: %d\n", value);
+	useIF =  value;
+}
+
+void Main_Widget::updateUseUSBsoftrock ( bool value )
+{
+
+	rock_bound = !value;
+	if (value) {
+		rx_f -= rx_delta_f;
+		rx_delta_f = tuneCenter;
+		rx_f += rx_delta_f;
+
+        if(pUSBCmd == NULL) setupSDR();
+        if(verbose) fprintf ( stderr, "useUSBsoftrock: %s\n",
+		value ? "enabled" : "disabled");
+	}
+}
+
+void Main_Widget::updateDualConversion ( bool value )
+{
+	dualConversion =  value;
+    if(verbose) fprintf ( stderr, "DualConversion: %s\n",
+		value ? "enabled" : "disabled");
+}
+
+void Main_Widget::updateTransmit ( bool value )
+{
+	enableTransmit = value;
+	if ( enableTransmit ) {
+        if(pTXCmd == NULL) setupSDR();
+        for (int i=0; i < NUM_CMD; i++)
+            c_cell[i]->setCmd((DttSPcmd*)pCmd, (DttSPcmd*)pTXCmd);
+		pTXCmd->on();
+		setTxIQGain();
+		setTxIQPhase();
+		setTxGain( 0 );
+		setTxGain( 1 );
+		setTxFrequency();
+		} else {
+                pTXCmd->off();
+		}
+        if(verbose) fprintf ( stderr, "Transmit: %s\n",
+		enableTransmit ? "enabled" : "disabled");
+}
+
+void Main_Widget::setHamlib ( bool value )
+{
+        if ( value )
+        {
+            useHamlib = TRUE;
+        }
+        else
+        {
+            useHamlib = FALSE;
+            if (ourHamlibWrapper) ourHamlibWrapper->~hamlibWrapper();
+        }
+        emit toggleHamlibButton ( useHamlib );
+}
+
+void Main_Widget::setMuteXmit ( bool value )
+{
+	muteXmit =  value;
+	emit tellMuteXmit ( muteXmit );
+}
+
+void Main_Widget::updateFreq(void)
+{
+	char text[32];
+	double freq;
+        unsigned long corrected_f;
+
+	if (!update_freqMutex.tryLock()) return;	// cannot lock, give up till next tick
+
+	if (!rock_bound && !transmit){			// only update Freq duing Rx
+		if (pUSBCmd->sendCommand("get freq\n") != 0) return;
+		freq = pUSBCmd->getParam();		// freq in Mhz
+
+		if (freq != 0) {
+		    rx_f = freq * 1000000.0;
+			if ( !useIF ){
+                            switch (mode){
+                                case RIG_MODE_CW:
+                                    corrected_f = rx_f - rx_delta_f + CW_tone;
+                                    break;
+                                case RIG_MODE_CWR:
+                                    corrected_f = rx_f - rx_delta_f - CW_tone;
+                                    break;
+                                default:
+                                    corrected_f = rx_f - rx_delta_f;
+                                    break;
+                                }    
+				snprintf ( text, 32, "......%11.6lf",
+					( double ) ( corrected_f ) / 1000000.0 );
+				displayMutex.lock();
+				lcd->display ( text );
+
+				if (enableRIT) {
+					tx_f_string.sprintf ("%11.0lf", ( double ) ( tx_delta_f - rx_delta_f ) );
+					rit->setText( tx_f_string );
+					}
+
+				displayMutex.unlock();
+				};
+
+			pCmd->sendCommand ("setOsc %d %d\n", rx_delta_f, 0 );
+
+			if (!rock_bound && !enableRIT && !enableSPLIT && enableTransmit)
+				pTXCmd->sendCommand ("setOsc %d %d\n", -rx_delta_f, 1 );
+			}
+		};
+
+	update_freqMutex.unlock();
+
+}
+
+void Main_Widget::updatePTT(void)
+{
+	int PTT;
+
+	if (!rock_bound && enableTransmit)
+	{
+		if (pUSBCmd->sendCommand("get ptt\n") != 0) {
+			//pttTimer->stop();
+			return;
+		}
+
+		PTT = pUSBCmd->getParam();		// returned param is a double
+		
+		if (old_PTT == PTT) return;
+		if (PTT && transmit) return;
+
+		if(verbose) fprintf(stderr, "PTT changed to state (%d) \n", PTT);
+		if (PTT) {
+			if (pUSBCmd->sendCommand("get tone\n") == 0) CW_tone = pUSBCmd->getParam();
+			
+			update_freqMutex.lock();
+
+			// TODO: if enableSPLIT   set USBSoftrock frequency accordingly
+
+			if (mode == RIG_MODE_CW){
+				pCmd->sendCommand ("setMode %d %d\n", USB );
+				pTXCmd->sendCommand ("setMode %d %d\n", USB, 1 );
+				if(verbose) fprintf ( stderr, "setMode %d\n", USB );
+				filter_l = &USB_filter_l; //20;
+				filter_h = &USB_filter_h; //2400;
+				setFilter();
+			}
+			else if (mode == RIG_MODE_CWR){
+				pCmd->sendCommand ("setMode %d %d\n", LSB );
+				pTXCmd->sendCommand ("setMode %d %d\n", LSB, 1 );
+				if(verbose) fprintf ( stderr, "setMode %d\n", LSB );
+				filter_l = &LSB_filter_l; //-2400;
+				filter_h = &LSB_filter_h; //-20;
+				setFilter();
+			};
+
+			pTXCmd->sendCommand ("setRunState 2\n");
+			pTXCmd->sendCommand ("setTRX 1\n");
+			set_MUTE ( 1 );
+			TRX_label->setPixmap( QPixmap( tx_xpm ) );
+			TRX_label->setLabel( TX );
+		} else {
+			if (mode == RIG_MODE_CW){
+				pCmd->sendCommand ("setMode %d %d\n", CWU );
+				pTXCmd->sendCommand ("setMode %d %d\n", CWU, 1 );
+				if(verbose) fprintf ( stderr, "setMode %d\n", CWU );
+				filter_l = &CWU_filter_l; //200;
+				filter_h = &CWU_filter_h; //500;
+				setFilter();
+			}
+			else if (mode == RIG_MODE_CWR){
+				pCmd->sendCommand ("setMode %d %d\n", CWL );
+				pTXCmd->sendCommand ("setMode %d %d\n", CWL, 1 );
+				if(verbose) fprintf ( stderr, "setMode %d\n", CWL );
+				filter_l = &CWL_filter_l; //-500;
+				filter_h = &CWL_filter_h; //-200;
+				setFilter();
+			};
+
+			pUSBCmd->sendCommand("set freq %f\n", (rx_f)*1e-6);
+			update_freqMutex.unlock();
+
+			pTXCmd->sendCommand ("setTRX 0\n");
+			pTXCmd->sendCommand ("setRunState 0\n");
+			if(verbose) fprintf (stderr, "set ptt off\n");
+			TRX_label->setPixmap( QPixmap( rx_xpm ) );
+			TRX_label->setLabel( RX );
+			set_MUTE ( 0 );
+
+		}
+		old_PTT = PTT;
+	}
+}
+
+
+void Main_Widget::initHamlib ()
+{
+    rig_errcode_e error;
+	ourHamlibWrapper = new hamlibWrapper ( this );
+
+	connect ( ourHamlibWrapper, SIGNAL ( nowTransmit ( int ) ), this, SLOT ( set_MUTE ( int ) ) );
+	connect ( ourHamlibWrapper, SIGNAL ( newFreq ( double ) ), this, SLOT ( setOurRxFrequency ( double ) ) );
+	connect ( ourHamlibWrapper, SIGNAL ( rigChangedMode ( rmode_t, bool ) ), this, SLOT ( setMode ( rmode_t, bool ) ) );
+	connect ( ourHamlibWrapper, SIGNAL ( slopeLowChangedByRig ( int ) ), this, SLOT ( setSlopeLowOffset ( int ) ) );
+	connect ( ourHamlibWrapper, SIGNAL ( slopeHighChangedByRig ( int ) ), this, SLOT ( setSlopeHighOffset ( int ) ) );
+	connect ( ourHamlibWrapper, SIGNAL ( rigPitch ( int ) ), this, SLOT ( setCWPitch ( int ) ) );
+
+    // hl_port = "localhost";  //Debugging fix.
+    QByteArray myarray = portString.toAscii();
+    char *hl_port = myarray.data();
+    if ( (error = (rig_errcode_e)ourHamlibWrapper->init ( rig, hl_port, speed )) != RIG_OK )
+	{
+        if(verbose) fprintf( stderr, "Hamlib initialization error: %d. \n", error);
+        if(verbose) fprintf( stderr, "Hamlib would not initialize.  Fix the hamlib set up and re-enable hamblib via the CFG option. \n");
+        setHamlib ( FALSE );
+	}
+	emit changeSlopeTune ( useSlopeTune );
+	emit tellMuteXmit ( muteXmit );
+}
+
+void Main_Widget::initRigCtl ()
+{
+	rigCtl = new RigCtlServer ( this, this );
+}
+
+void Main_Widget::updateUSBOffset ( int offset )
 {
-    specCal = value;
+	usbOffset = offset;
 }
 
-void Main_Widget::calibrateMetr( int value )
+void Main_Widget::updateLSBOffset ( int offset )
 {
-    metrCal = value;
+	lsbOffset = offset;
 }
 
+void Main_Widget::setSlopeTune ( bool useslopetune)
+{
+	useSlopeTune = useslopetune;
+	emit changeSlopeTune ( useSlopeTune );
+}
+
+void Main_Widget::updateSlopeLowOffset ( int offset )
+{
+	slopeLowOffset = offset;
+}
+
+void Main_Widget::updateSlopeHighOffset ( int offset )
+{
+	slopeHighOffset = offset;
+}
+
+void Main_Widget::setSlopeLowOffset ( int value )
+{
+	switch ( mode )
+	{
+		case RIG_MODE_USB:
+			slopeTuneOffset = ( int ) 1.000 * value * slopeLowOffset / SLOPE_TUNE_MAX;
+			break;
+		case RIG_MODE_CW:
+			slopeTuneOffset = ( int ) 1.000 * value * slopeLowOffset / SLOPE_TUNE_MAX_CW;
+			break;
+		default:	
+        if(verbose) fprintf(stderr, "Hit default: value is: %d \n", value );
+	}
+	setDefaultRxFrequency();
+}
+
+void Main_Widget::setSlopeHighOffset ( int value )
+{
+	switch ( mode )
+	{
+		case RIG_MODE_FM:
+			slopeTuneOffset = 0;
+			break;
+		case RIG_MODE_AM:
+		case RIG_MODE_SAM:
+			slopeTuneOffset = 3200 * value  / SLOPE_TUNE_MAX;  // Hardcode this for now.
+			break;
+		case RIG_MODE_LSB:
+			slopeTuneOffset = ( int ) 1.000 * value * slopeHighOffset / SLOPE_TUNE_MAX;
+			break;
+		case RIG_MODE_CWR:
+			slopeTuneOffset = ( int ) 1.000 * value * slopeHighOffset / SLOPE_TUNE_MAX_CW;
+			break;
+		default:	
+        if(verbose) fprintf(stderr, "Hit default: value is: %d \n", value );
+	}
+	setDefaultRxFrequency();
+}
+
+void Main_Widget::setCWPitch ( int pitch )
+{
+	cwPitch = pitch;
+}
+
+// ---------------------------------------------------------------------------
+// Arbitrary DttSP Commands
+void Main_Widget::toggleCmd ( Command *c )
+{
+	c->toggle();
+}
+
+void Main_Widget::configCmd ( Command * )
+{
+	cmdFrame->show();
+}
+
+void Main_Widget::updateCmd ( int n )
+{
+	c_cell[n]->setText ( cmdName[n]->text() );
+	c_cell[n]->setName ( cmdName[n]->text() );
+	c_cell[n]->setTargets(cmdRXbutton[n]->isChecked(), cmdTXbutton[n]->isChecked());
+	c_cell[n]->setOnCommand(cmdOnCommand[n]->text());
+	c_cell[n]->setOffCommand(cmdOffCommand[n]->text());
+}
+
+void Main_Widget::resetCmd ( int i )
+{
+	cmdName[i]->setText ( c_cell[i]->getName() );
+	cmdOnCommand[i]->setText ( c_cell[i]->getOnCommand() );
+	cmdOffCommand[i]->setText ( c_cell[i]->getOffCommand() );
+	cmdRXbutton[i]->setChecked ( c_cell[i]->getToRX() );
+	cmdTXbutton[i]->setChecked ( c_cell[i]->getToTX() );
+}
+
+rmode_t Main_Widget::rigGetMode () {
+	return mode;
+}
+
+int Main_Widget::rigGetFilterWidth () {
+	return (*filter_h) - (*filter_l);
+}
+
+unsigned long long int Main_Widget::rigGetFrequency () {
+	return rx_f - rx_delta_f;
+}
+
+void Main_Widget::rigSetFrequency(unsigned long long int rigctlfreq){
+
+    rx_delta_f = tuneCenter;
+    rx_f = rigctlfreq;
+    rx_f += rx_delta_f;
+    fprintf (stderr, "Hamlib cmd set freq %f\n", (rx_f)*1e-6 );
+    pUSBCmd->sendCommand("set freq %f\n", (rx_f)*1e-6);
+    tx_f = rigctlfreq;
+    set_RIT( 0 );	// do this before set_SPLIT, as it clears the RIT text
+     if (tx_f != 0) {
+             tx_delta_f = tuneCenter;
+             tx_f += tx_delta_f;
+             set_SPLIT ( TRUE );
+     } else {
+             set_SPLIT ( FALSE );
+     }
+     setRxFrequency( 1 );
+
+}
+
+void Main_Widget::rigSetPTT ( int enabled ) {
+	if (transmit != enabled) {
+		toggle_TX( enabled );
+	}
+}
--- sdr-shell-4~svn156.orig/memorycell.cpp
+++ sdr-shell-4~svn156/memorycell.cpp
@@ -1,6 +1,6 @@
 #include "memorycell.h"
 
-MemoryCell::MemoryCell(QWidget *parent, const char *name) : QLabel(parent, name)
+MemoryCell::MemoryCell(QWidget *parent) : QLabel(parent)
 {
     id = 0;
     frequency = 0;
@@ -16,7 +16,7 @@ void MemoryCell::setID( int i )
     id = i;
 }
 
-void MemoryCell::setMode( int m )
+void MemoryCell::setMode( rmode_t m )
 {
     mode = m;
 }
@@ -32,6 +32,11 @@ void MemoryCell::setFrequency( long long
     frequency = f;
 }
 
+void MemoryCell::setTxFrequency( long long int f )
+{
+    txFrequency = f;
+}
+
 int MemoryCell::getID()
 {
     return id;
@@ -57,15 +62,27 @@ long long int MemoryCell::getFrequency()
     return frequency;
 }
 
+long long int MemoryCell::getTxFrequency()
+{
+    return txFrequency;
+}
+
 void MemoryCell::mouseReleaseEvent ( QMouseEvent *e )
 {
-    if ( e->state() == LeftButton )
+    if ( e->button() == Qt::LeftButton )
         emit read( this );
-    else if ( e->state() == MidButton )
+    else if ( e->button() == Qt::MidButton )
         emit write( this );
 }
 
 void MemoryCell::enterEvent( QEvent * )
 {
+	//fprintf( stderr, "memory cell mouse enter\n" );
 	emit display( this );
 }
+
+void MemoryCell::leaveEvent( QEvent * )
+{
+	//fprintf( stderr, "memory cell mouse leave\n" );
+	//emit display( this );
+}
--- /dev/null
+++ sdr-shell-4~svn156/command.cpp
@@ -0,0 +1,159 @@
+
+#include <cstdio>
+#include "command.h"
+
+Command::Command(QWidget *parent) : QLabel(parent)
+{
+        state = FALSE;
+        rxCmd = txCmd = NULL;
+
+}
+
+void Command::setCmd(DttSPcmd *rx, DttSPcmd *tx)
+{
+	if(rxCmd != NULL) rxCmd = rx;
+	else fprintf(stderr, "RX not enabled.\n");
+	if(txCmd != NULL) txCmd = tx;
+	else fprintf(stderr, "TX not enabled.\n");
+}
+
+void Command::setID(int v)
+{
+	id = v;
+}
+
+void Command::setName(QString n)
+{
+    // fprintf(stderr, "setName '%s'\n", qPrintable(n));
+	name = n;
+}
+void Command::setTargets(bool r, bool t)
+{
+	sendRx = r;
+	sendTx = t;
+}
+void Command::setCommand(QString On, QString Off)
+{
+	OnCommand = On;
+	OffCommand = Off;
+}
+void Command::setOnCommand(QString On)
+{
+	//fprintf(stderr, "setONCommand: %s\n", qPrintable(On));
+	OnCommand = On;
+}
+void Command::setOffCommand(QString Off)
+{
+	//fprintf(stderr, "setOffCommand: %s\n", qPrintable(Off));
+	OffCommand = Off;
+}
+int Command::getID()
+{
+	return id;
+}
+void Command::setTargets(QString T)
+{
+	if(T.contains("RX", Qt::CaseInsensitive)) {
+		printf("setTarget: RX\n");
+		sendRx = TRUE;
+	}
+	if(T.contains("TX", Qt::CaseInsensitive)) {
+		printf("setTarget: TX\n");
+		sendTx = TRUE;
+	}
+}
+
+QString Command::getOnCommand()
+{
+	return OnCommand;
+}
+QString Command::getOffCommand()
+{
+	return OffCommand;
+}
+QString Command::getName()
+{
+	return name;
+}
+QString Command::getTo()
+{
+	return tr(sendRx? "RX":"") + tr(sendTx? "TX":"");
+}
+bool Command::getToRX()
+{
+	return sendRx;
+}
+bool Command::getToTX()
+{
+	return sendTx;
+}
+
+void Command::mouseReleaseEvent ( QMouseEvent *e )
+{
+    if ( e->button() == Qt::LeftButton )
+        emit mouseReleaseL( this );
+    else if ( e->button() == Qt::RightButton )
+        emit mouseReleaseR( this );
+}
+
+bool Command::sendCmd(DttSPcmd *p, QString *str)
+{
+	QStringList list;
+	int n;
+	char *s;
+	bool error = FALSE;
+
+    if (p == NULL)
+        return 1;
+
+	//printf("Send: '%s'\n", qPrintable(*str));
+	list = str->split(tr(";"), QString::KeepEmptyParts);
+	//printf("list is %d items\n", list.size());
+	n = list.size();
+	for(int i = 0; i < n; i++) {
+		s = (char*)qPrintable(list.at(i));
+		printf("item %d = '%s'\n", i, s);
+		if (p->sendCommand (s))
+			error = TRUE;
+	}
+	//p->sendCommand (qPrintable(*str));
+	return error;
+}
+
+// Click on the command icon
+// If there is one command to send, it should be in the "On" field.
+// If there is no command in the "Off" field, then the icon is left plain.
+bool Command::toggle()
+{
+	bool error = FALSE;
+	QString *cmd;
+
+	if (OffCommand.isEmpty())
+		state = TRUE;
+	else
+		state = !state;
+
+	fprintf(stderr, "Command::toggle %s\n", state ? "on" : "off");
+	if (state) {
+		cmd = &OnCommand;
+		//txCmd->sendCommand (qPrintable(OnCommand));
+		if (!OffCommand.isEmpty())
+			this->setPalette(QPalette(QColor(200, 0, 0)));
+	} else {
+		cmd = &OffCommand;
+		//txCmd->sendCommand (qPrintable(OffCommand));
+		this->setPalette(QPalette(QColor(0, 0, 0)));
+	}
+	if (sendRx) {
+		if (sendCmd(rxCmd, cmd)) {
+			error = TRUE;
+		}
+	}
+	if (sendTx) {
+		if (sendCmd(txCmd, cmd)) {
+			error = TRUE;
+		}
+	}
+	return TRUE;
+}
+
--- /dev/null
+++ sdr-shell-4~svn156/sdrshell.kdevelop
@@ -0,0 +1,228 @@
+<?xml version = '1.0'?>
+<kdevelop>
+  <general>
+    <author/>
+    <email>frohro@frohro-hamshack</email>
+    <version>$VERSION$</version>
+    <projectmanagement>KDevTrollProject</projectmanagement>
+    <primarylanguage>C++</primarylanguage>
+    <keywords>
+      <keyword>Qt</keyword>
+    </keywords>
+    <projectname>sdrshell</projectname>
+    <ignoreparts/>
+    <projectdirectory>.</projectdirectory>
+    <absoluteprojectpath>false</absoluteprojectpath>
+    <description/>
+    <defaultencoding/>
+    <versioncontrol/>
+  </general>
+  <kdevfileview>
+    <groups>
+      <group pattern="*.cpp;*.cxx;*.h" name="Sources" />
+      <group pattern="*.ui" name="User Interface" />
+      <group pattern="*.png" name="Icons" />
+      <group pattern="*" name="Others" />
+      <hidenonprojectfiles>false</hidenonprojectfiles>
+      <hidenonlocation>false</hidenonlocation>
+    </groups>
+    <tree>
+      <hidepatterns>*.o,*.lo,CVS</hidepatterns>
+      <hidenonprojectfiles>false</hidenonprojectfiles>
+    </tree>
+  </kdevfileview>
+  <kdevdoctreeview>
+    <ignoretocs>
+      <toc>bash</toc>
+      <toc>bash_bugs</toc>
+      <toc>clanlib</toc>
+      <toc>w3c-dom-level2-html</toc>
+      <toc>fortran_bugs_gcc</toc>
+      <toc>gnome1</toc>
+      <toc>gnustep</toc>
+      <toc>gtk</toc>
+      <toc>gtk_bugs</toc>
+      <toc>haskell</toc>
+      <toc>haskell_bugs_ghc</toc>
+      <toc>java_bugs_gcc</toc>
+      <toc>java_bugs_sun</toc>
+      <toc>kde2book</toc>
+      <toc>opengl</toc>
+      <toc>pascal_bugs_fp</toc>
+      <toc>php</toc>
+      <toc>php_bugs</toc>
+      <toc>perl</toc>
+      <toc>perl_bugs</toc>
+      <toc>python</toc>
+      <toc>python_bugs</toc>
+      <toc>qt-kdev3</toc>
+      <toc>ruby</toc>
+      <toc>ruby_bugs</toc>
+      <toc>sdl</toc>
+      <toc>stl</toc>
+      <toc>w3c-svg</toc>
+      <toc>sw</toc>
+      <toc>w3c-uaag10</toc>
+      <toc>wxwidgets_bugs</toc>
+    </ignoretocs>
+    <ignoredoxygen>
+      <toc>KDE Libraries (Doxygen)</toc>
+    </ignoredoxygen>
+  </kdevdoctreeview>
+  <kdevdebugger>
+    <general>
+      <dbgshell/>
+      <gdbpath/>
+      <configGdbScript/>
+      <runShellScript/>
+      <runGdbScript/>
+      <breakonloadinglibs>true</breakonloadinglibs>
+      <separatetty>false</separatetty>
+      <floatingtoolbar>false</floatingtoolbar>
+      <raiseGDBOnStart>false</raiseGDBOnStart>
+    </general>
+    <display>
+      <staticmembers>false</staticmembers>
+      <demanglenames>true</demanglenames>
+      <outputradix>10</outputradix>
+    </display>
+  </kdevdebugger>
+  <kdevcppsupport>
+    <qt>
+      <version>3</version>
+      <used>true</used>
+      <includestyle>3</includestyle>
+      <designerintegration>ExternalDesigner</designerintegration>
+      <root>/usr/share/qt3</root>
+      <qmake>/usr/bin/qmake-qt3</qmake>
+      <designer>/usr/bin/designer</designer>
+      <designerpluginpaths/>
+    </qt>
+    <codecompletion>
+      <automaticCodeCompletion>true</automaticCodeCompletion>
+      <automaticArgumentsHint>true</automaticArgumentsHint>
+      <automaticHeaderCompletion>true</automaticHeaderCompletion>
+      <codeCompletionDelay>250</codeCompletionDelay>
+      <argumentsHintDelay>400</argumentsHintDelay>
+      <headerCompletionDelay>250</headerCompletionDelay>
+      <showOnlyAccessibleItems>false</showOnlyAccessibleItems>
+      <completionBoxItemOrder>0</completionBoxItemOrder>
+      <howEvaluationContextMenu>true</howEvaluationContextMenu>
+      <showCommentWithArgumentHint>true</showCommentWithArgumentHint>
+      <statusBarTypeEvaluation>false</statusBarTypeEvaluation>
+      <namespaceAliases>std=_GLIBCXX_STD;__gnu_cxx=std</namespaceAliases>
+      <processPrimaryTypes>true</processPrimaryTypes>
+      <processFunctionArguments>false</processFunctionArguments>
+      <preProcessAllHeaders>false</preProcessAllHeaders>
+      <parseMissingHeaders>false</parseMissingHeaders>
+      <resolveIncludePaths>true</resolveIncludePaths>
+      <alwaysParseInBackground>true</alwaysParseInBackground>
+      <usePermanentCaching>true</usePermanentCaching>
+      <alwaysIncludeNamespaces>false</alwaysIncludeNamespaces>
+      <includePaths>.;</includePaths>
+      <parseMissingHeadersExperimental>false</parseMissingHeadersExperimental>
+      <resolveIncludePathsUsingMakeExperimental>false</resolveIncludePathsUsingMakeExperimental>
+    </codecompletion>
+    <creategettersetter>
+      <prefixGet/>
+      <prefixSet>set</prefixSet>
+      <prefixVariable>m_,_</prefixVariable>
+      <parameterName>theValue</parameterName>
+      <inlineGet>true</inlineGet>
+      <inlineSet>true</inlineSet>
+    </creategettersetter>
+    <splitheadersource>
+      <enabled>false</enabled>
+      <synchronize>true</synchronize>
+      <orientation>Vertical</orientation>
+    </splitheadersource>
+    <references/>
+  </kdevcppsupport>
+  <kdevfilecreate>
+    <filetypes/>
+    <useglobaltypes>
+      <type ext="ui" />
+      <type ext="cpp" />
+      <type ext="h" />
+    </useglobaltypes>
+  </kdevfilecreate>
+  <kdevtrollproject>
+    <general>
+      <activedir></activedir>
+    </general>
+    <run>
+      <directoryradio>executable</directoryradio>
+      <mainprogram>/home/frohro/Projects/sdr-shell-v3a/src/sdr-shell</mainprogram>
+      <programargs/>
+      <globaldebugarguments/>
+      <globalcwd>/home/frohro/Projects/sdr-shell-v3a/src</globalcwd>
+      <useglobalprogram>true</useglobalprogram>
+      <terminal>false</terminal>
+      <autocompile>false</autocompile>
+      <autoinstall>false</autoinstall>
+      <autokdesu>false</autokdesu>
+      <envvars/>
+    </run>
+    <make>
+      <abortonerror>true</abortonerror>
+      <runmultiplejobs>false</runmultiplejobs>
+      <numberofjobs>1</numberofjobs>
+      <dontact>false</dontact>
+      <makebin/>
+      <prio>0</prio>
+      <envvars>
+        <envvar value="/usr/src/qt4/" name="QTDIR" />
+      </envvars>
+    </make>
+    <qmake>
+      <savebehaviour>2</savebehaviour>
+      <replacePaths>false</replacePaths>
+      <disableDefaultOpts>true</disableDefaultOpts>
+      <enableFilenamesOnly>false</enableFilenamesOnly>
+      <showVariablesInTree>true</showVariablesInTree>
+      <showParseErrors>true</showParseErrors>
+    </qmake>
+  </kdevtrollproject>
+  <cppsupportpart>
+    <filetemplates>
+      <interfacesuffix>.h</interfacesuffix>
+      <implementationsuffix>.cpp</implementationsuffix>
+    </filetemplates>
+  </cppsupportpart>
+  <ctagspart>
+    <customArguments/>
+    <customTagfilePath>/home/frohro/Projects/sdr-shell-v3a/src/tags</customTagfilePath>
+    <activeTagsFiles/>
+  </ctagspart>
+  <kdevdocumentation>
+    <projectdoc>
+      <docsystem/>
+      <docurl/>
+      <usermanualurl/>
+    </projectdoc>
+  </kdevdocumentation>
+  <dist>
+    <custom>false</custom>
+    <bzip>false</bzip>
+    <archname/>
+    <appname>sdrshell</appname>
+    <version>3a</version>
+    <release/>
+    <vendor/>
+    <licence/>
+    <summary/>
+    <group/>
+    <packager/>
+    <description/>
+    <changelog/>
+    <devpackage>false</devpackage>
+    <docspackage>false</docspackage>
+    <appicon>false</appicon>
+    <arch>0</arch>
+    <genHTML>false</genHTML>
+    <useRPM>false</useRPM>
+    <ftpkde>false</ftpkde>
+    <appskde>false</appskde>
+    <url/>
+  </dist>
+</kdevelop>
--- /dev/null
+++ sdr-shell-4~svn156/startup/start-delta44.sh
@@ -0,0 +1,72 @@
+#!/bin/sh
+
+# Start-Up for sdr-shell, dttsp, and usbsoftrock.  Oriented towards a Softrock
+# RXTX board.
+
+set -x
+export SDR_DEFRATE=96000
+
+/usr/bin/jackd -R -P66 -p128 -t2000 -dalsa -r96000 -D -Chw:2 -Phw:2 -s -p 2048&
+#pasuspender -- /usr/bin/jackd -R -P66 -p128 -t2000 -dalsa -r96000 -D -Chw:2 -Phw:2 -s -p 2048&
+JPID="$!"
+
+sleep 2
+
+#
+#  Start usbsoftrock.  Set your calibration valeu on the -x line.
+#  If you have it internally calibrated using advanced mode, put a '-a'
+#  here instead of the -x.
+#
+usbsoftrock ptt off
+#./usbsoftrock -vvvv -x 114.230181 -d &
+usbsoftrock -vvv -x 114.2630 -d &
+PIDS="$PIDS $!"
+
+export SDR_NAME=sdr
+sdr-core -s -m&
+PIDS="$PIDS $!"
+sleep 1
+jack_connect sdr:ol alsa_pcm:playback_1 
+jack_connect sdr:or alsa_pcm:playback_2
+jack_connect alsa_pcm:capture_1 sdr:il        
+jack_connect alsa_pcm:capture_2 sdr:ir     
+jack_lsp -c
+
+export SDR_NAME=sdr-tx
+export SDR_PARMPORT=19005
+export SDR_SPECPORT=19006
+export SDR_METERPORT=19007
+sdr-core -s -m -v &
+PIDS="$PIDS $!"
+sleep 1
+jack_lsp
+jack_connect sdr-tx:ol alsa_pcm:playback_3
+jack_connect sdr-tx:or alsa_pcm:playback_4
+case $1 in
+metronome )
+	jack_metro -b 60 &
+	PIDS="$PIDS $!"
+	sleep 1
+	jack_connect metro:60_bpm sdr-tx:il        
+	jack_connect metro:60_bpm sdr-tx:ir
+;;
+* )
+	jack_connect alsa_pcm:capture_3 sdr-tx:il
+	jack_connect alsa_pcm:capture_4 sdr-tx:ir
+;;
+esac
+
+echo $PIDS
+
+export SDR_MODE=$PWD/hook-mode
+#export SDR_BAND=$PWD/hook-band
+./sdr-shell
+
+# kill jack clients before killing jack himself.
+# this seems to be a cleaner shutdown than everything at once
+
+kill $PIDS
+sleep 2
+kill $JPID
+wait
+
--- /dev/null
+++ sdr-shell-4~svn156/startup/start-audigy.sh
@@ -0,0 +1,53 @@
+#!/bin/sh
+
+set -x
+SDR_DEFRATE=${SDR_DEFRATE-48000}
+export SDR_DEFRATE
+echo Rate: $SDR_DEFRATE
+
+export SDR_MODE=$PWD/hook_mode
+
+./usbsoftrock -vvv ptt off
+./usbsoftrock -vvv status
+#./usbsoftrock -vvv -x 114.230181 -d &		# SR6.2
+./usbsoftrock -vvv -x 114.2633 -d &		# SR6.3
+PIDS="$PIDS $!"
+
+#
+# Receive
+#
+export SDR_NAME=sdr
+#./sdr-core -v -s -m &
+./sdr-core -s -m &
+PIDS="$PIDS $!"
+sleep 1
+jack_lsp
+jack_connect sdr:ol system:playback_1 
+jack_connect sdr:or system:playback_2
+jack_connect system:capture_1 sdr:il        
+jack_connect system:capture_2 sdr:ir     
+jack_lsp -c
+
+#
+# Transmit
+#
+SDR_DEFRATE=${SDR_DEFRATE-48000}
+export SDR_DEFRATE
+export SDR_PARMPORT=19005
+export SDR_SPECPORT=19006
+export SDR_METERPORT=19007
+export SDR_NAME=sdr-tx
+./sdr-core -v -s -m &
+PIDS="$PIDS $!"
+sleep 1
+#jack_lsp
+jack_connect sdr-tx:ol system:playback_3
+jack_connect sdr-tx:or system:playback_4
+jack_connect system:capture_3 sdr-tx:il        
+jack_connect system:capture_4 sdr-tx:ir
+echo system:capture_3 system:capture_4 >.phinput
+echo $PIDS
+./sdr-shell
+kill $PIDS
+wait
+
--- /dev/null
+++ sdr-shell-4~svn156/startup/start_rx
@@ -0,0 +1,32 @@
+#!/bin/bash
+# define name used in the RMI registry
+NAME=SDR-SHELL
+export SDR_DEFRATE=48000
+export JACK_BUFFER=1024
+AUDIO_DEV=hw:0
+
+echo "starting jackd ..."
+/usr/bin/jackd -dalsa -d$AUDIO_DEV -r$SDR_DEFRATE -p${JACK_BUFFER} -n3&
+
+sleep 5
+
+# start RX DttSP
+echo "starting DttSP ${NAME}_RX ..."
+echo ports do not exist as argument
+exit
+sdr-core --spectrum --metering --client-name=${NAME}_RX --buffsize=${JACK_BUFFER} --ringmult=4 --command-port=19001 --spectrum-port=19002 --meter-port=19003&
+
+sleep 5
+# connect receiver
+echo "connecting receiver ..."
+jack_connect system:capture_1 ${NAME}_RX:il
+sleep 2
+jack_connect system:capture_2 ${NAME}_RX:ir
+sleep 2
+jack_connect ${NAME}_RX:ol system:playback_1
+sleep 2
+jack_connect ${NAME}_RX:or system:playback_2
+sleep 2
+
+# start sdr-shell
+./sdr-shell&
--- /dev/null
+++ sdr-shell-4~svn156/startup/start_fifi.sh
@@ -0,0 +1,91 @@
+#!/bin/sh
+clear
+set -x
+export SDR_DEFRATE=96000 #48000 
+#export SDR_DEFRATE=48000 
+DEV_CAPTURE=hw:4
+DEV_PLAYBACK=hw:0
+export SDR_NAME=sdr
+#export SDR_NAME=sdr-tx # double entry?
+
+## communication over ports
+export SDR_PARMPORT=19005 # sdr-core eats this
+export SDR_SPECPORT=19006  # sdr-core eats this
+export SDR_METERPORT=19007  # sdr-core eats this
+
+## FIFOs
+# if communication over fifos
+#export SDR_PARMPATH=/dev/shm/SDRcommands
+#export SDR_METERPATH=/dev/shm/SDRmeter
+#export SDR_SPECPATH=/dev/shm/SDRspectrum
+#for f in $SDR_PARMPATH $SDR_METERPATH $SDR_SPECPATH; do test -e $f || mkfifo $f; done;
+
+## Clean up
+killall -KILL sdr-core
+killall -KILL jackd
+
+## Start jackd
+echo "Starting jackd"
+/usr/bin/jackd -R -P66 -p128 -t2000 -dalsa -r$SDR_DEFRATE -D -C$DEV_CAPTURE -P$DEV_PLAYBACK -s -p 2048&
+# start in (R)ealtime with (P)rio 66, (p)ortmax 128, (t)imeout 2000 alsa with parameters...
+JPID="$!"
+sleep 5
+echo "Started jackd"
+
+## Realtime
+#rmmod capability
+#rmmod commoncap
+#modprobe realcap any=1 allcaps=1
+
+## Start DttSP
+echo "Starting DttSP"
+sdr-core --spectrum --metering&
+#sdr-core --spectrum --metering R} --ringmult=4 --command-port=19001 --spectrum-port=19002 --meter-port=19003
+PIDS="$PIDS $!"
+sleep 3
+echo "Started DttSP"
+
+# connect jack
+echo "Connecting jack"
+jack_connect $SDR_NAME:ol alsa_pcm:playback_1 || exit 1
+jack_connect $SDR_NAME:or alsa_pcm:playback_2 || exit 1
+jack_connect alsa_pcm:capture_1 $SDR_NAME:ir || exit 1       
+jack_connect alsa_pcm:capture_2 $SDR_NAME:il || exit 1    
+jack_lsp -c || exit 1
+PIDS="$PIDS $!"
+sleep 1
+echo "Connected jack"
+
+# Start si controller
+echo Starting si controller
+usbsoftrock -vvv -a -d &
+PIDS="$PIDS $!"
+sleep 5
+echo Starting si controller done
+
+echo "The following pids have been used: $PIDS"
+
+# Startx X
+#X :2 
+#export DISPLAY=:2
+
+# Start SDR shell
+echo "Starting SDR shell"
+#export SDR_MODE=$PWD/hook-mode
+#export SDR_BAND=$PWD/hook-band
+#sdr-shell
+sdr-shell --sample_rate=$SDR_DEFRATE --meter-port=$SDR_METERPORT \
+--spectrum-port=$SDR_SPECPORT --rx-command-port=$SDR_PARMPORT
+
+
+# kill jack clients before killing jack himself.
+# this seems to be a cleaner shutdown than everything at once
+
+kill $PIDS
+sleep 2
+kill $JPID
+wait
+
+
+killall sdr-core
+killall jackd
--- /dev/null
+++ sdr-shell-4~svn156/startup/start_softrock_lite.sh
@@ -0,0 +1,83 @@
+#!/bin/sh
+# Start-Up for sdr-shell, dttsp, and usbsoftrock.  Oriented towards a Softrock
+# RXTX board.
+clear
+# http://sdr-shell.googlecode.com/svn/tags/PMSDR-1.0/sdr-shell.sh
+set -x
+export SDR_DEFRATE=96000 #48000 
+#export SDR_DEFRATE=48000 
+DEV_CAPTURE=hw:4
+DEV_PLAYBACK=hw:0
+export SDR_NAME=sdr
+#export SDR_NAME=sdr-tx # double entry?
+
+## communication over ports
+#export SDR_PARMPORT=19005 # sdr-core eats this
+#export SDR_SPECPORT=19006  # sdr-core eats this
+#export SDR_METERPORT=19007  # sdr-core eats this
+
+## FIFOs
+# if communication over fifos
+export SDR_PARMPATH=/dev/shm/SDRcommands
+export SDR_METERPATH=/dev/shm/SDRmeter
+export SDR_SPECPATH=/dev/shm/SDRspectrum
+for f in $SDR_PARMPATH $SDR_METERPATH $SDR_SPECPATH; do test -e $f || mkfifo $f; done;
+
+## Clean up
+killall -KILL sdr-core
+killall -KILL jackd
+
+## Start jackd
+echo "Starting jackd"
+/usr/bin/jackd -R -P66 -p128 -t2000 -dalsa -r$SDR_DEFRATE -D -C$DEV_CAPTURE -P$DEV_PLAYBACK -s -p 2048&
+# start in (R)ealtime with (P)rio 66, (p)ortmax 128, (t)imeout 2000 alsa with parameters...
+JPID="$!"
+sleep 5
+echo "Started jackd"
+
+## Realtime
+#rmmod capability
+#rmmod commoncap
+#modprobe realcap any=1 allcaps=1
+
+## Start DttSP
+echo "Starting DttSP"
+sdr-core --spectrum --metering&
+#/usr/local/bin/sdr-core --spectrum --metering --client-name=${NAME}_RX --buffsize=${JACK_BUFFER} --ringmult=4 --command-port=19001 --spectrum-port=19002 --meter-port=19003
+PIDS="$PIDS $!"
+sleep 3
+echo "Started DttSP"
+
+# connect jack
+echo "Connecting jack"
+jack_connect $SDR_NAME:ol alsa_pcm:playback_1 || exit 1
+jack_connect $SDR_NAME:or alsa_pcm:playback_2 || exit 1
+jack_connect alsa_pcm:capture_1 $SDR_NAME:il || exit 1       
+jack_connect alsa_pcm:capture_2 $SDR_NAME:ir || exit 1    
+jack_lsp -c || exit 1
+PIDS="$PIDS $!"
+sleep 1
+echo "Connected jack"
+
+echo "The following pids have been used: $PIDS"
+
+# Start SDR shell
+echo "Starting SDR shell"
+#export SDR_MODE=$PWD/hook-mode
+#export SDR_BAND=$PWD/hook-band
+./sdr-shell
+#./sdr-shell --sample_rate=$SDR_DEFRATE --meter-port=$SDR_METERPORT \
+#--spectrum-port=$SDR_SPECPORT --rx-command-port=$SDR_PARMPORT
+
+
+# kill jack clients before killing jack himself.
+# this seems to be a cleaner shutdown than everything at once
+
+kill $PIDS
+sleep 2
+kill $JPID
+wait
+
+
+killall sdr-core
+killall jackd
--- /dev/null
+++ sdr-shell-4~svn156/startup/sdr-shell.sh
@@ -0,0 +1,309 @@
+#!/usr/bin/env bash
+#
+# sdr_shell.sh
+#
+# Synopsis: 	 The script starts jack, dttsp, connects the jack ports, starts sdr-shell
+#
+# Version:      $Revision$
+#
+# Author:	    Andrea Montefusco iw0hdv
+#               Excerpted from Edson Pereira startup script
+#
+# Usage:        ./sdr-shell.sh
+#
+
+function trapped {
+
+   JACKD_PID=`cat $VARRUN/sdr-core.pid`
+   DTTSP_PID=`cat $VARRUN/jackd.pid`
+   echo "Killing....... $JACKD_PID $DTTSP_PID"
+   kill  $JACKD_PID $DTTSP_PID 
+
+   rm -f $PMSDR_CMDPATH
+
+   killall socat
+   killall pmsdr
+
+   rm -f $SDR_PARMPATH
+   rm -f $SDR_METERPATH
+   rm -f $SDR_SPECPATH
+}
+
+trap "trapped" EXIT
+trap "trapped" INT
+trap "trapped" KILL
+
+
+
+#
+# Read the local configuration
+#
+. ./sdr-shell.conf
+
+
+#
+# Detect the sound card id from name
+#
+
+ALSAH_ID=$(aplay -l | grep "^card.*$ALSAH_NAME" | cut -f 1 -d: | cut -f 2 -d' ')
+
+if [ -z "$ALSAH_ID" ]; then
+   echo "Can't find soundcard $ALSAH_NAME"
+   echo "Check your config"
+   aplay -l
+   exit 1
+fi
+
+ALSAH="hw:$ALSAH_ID"
+
+echo "ALSA Sound card id: $ALSAH" 
+
+
+#
+# Sound Card Sampling Rate
+#
+if [ -z "$DEFRATE" ]; then
+   echo "Can't find DEFRATE definition."
+   exit 1
+fi
+
+export SDR_DEFRATE="$DEFRATE"
+
+
+JACKD_PARAM=" -dalsa -d$ALSAH -r$SDR_DEFRATE "
+
+##############################################################################
+
+VARRUN=/tmp/
+
+##############################################################################
+# Setup the DttSP Environment Variables
+
+# Path to DttSP command FIFO
+export SDR_PARMPATH=/dev/shm/SDRcommands
+
+# Path to DttSP meter FIFO
+export SDR_METERPATH=/dev/shm/SDRmeter
+
+# Path to DttSP spectrum FIFO
+export SDR_SPECPATH=/dev/shm/SDRspectrum
+
+
+##############################################################################
+# Setup the PMSDR environment variables
+export PMSDR_CMDPATH=/tmp/PMSDRcommands
+
+##############################################################################
+# Test if we have the needed executables and directories
+if [ ! -x $JACKD ]; then
+  echo "Can't find $JACKD executable."
+  exit 1
+fi
+
+if [ ! -d $DTTSP ]; then 
+  echo "Can't find directory $DTTSP"
+  exit 1
+fi
+
+DTTSP_EXEC=$DTTSP/sdr-core
+
+if [ ! -x $DTTSP_EXEC ]; then 
+  echo "Can't find $DTTSP_EXEC executable."
+  exit 1
+fi
+
+if [ ! -x $JACKC ]; then
+  echo "Can't find $JACKC"
+  exit 1
+fi
+
+# If we have RT capability, get the realtime module ready
+if [ $REALTIME ]; then
+  echo "Configuring realtime module"
+  JACKD="$JACKDRT -R"
+  rmmod capability
+  rmmod commoncap
+  modprobe realcap any=1 allcaps=1
+fi
+  
+
+##########################################################################
+# Create FIFOs if needed
+if [ ! -p $SDR_PARMPATH ]; then
+   mkfifo $SDR_PARMPATH
+fi
+
+if [ ! -p $SDR_METERPATH ]; then
+   mkfifo $SDR_METERPATH
+fi
+
+if [ ! -p $SDR_SPECPATH ]; then
+   mkfifo $SDR_SPECPATH
+fi
+
+if [ ! -p $PMSDR_CMDPATH ]; then
+   mkfifo $PMSDR_CMDPATH
+fi
+
+##########################################################################
+# Sanity check
+if [ ! -p $SDR_PARMPATH ]; then
+   echo "Error while creating $SDR_PARMPATH fifo"
+   exit 1
+fi
+
+if [ ! -p $SDR_METERPATH ]; then
+   echo "Error while creating $SDR_METERPATH fifo"
+   exit 1
+fi
+
+if [ ! -p $SDR_SPECPATH ]; then
+   echo "Error while creating $SDR_SPECPATH fifo"
+   exit 1
+fi
+
+if [ ! -p $PMSDR_CMDPATH ]; then
+   echo "Error while creating $PMSDR_CMDPATH fifo"
+   exit 1
+fi
+
+##########################################################################
+# Make sure jack and dttsp are not already running
+TMP=`ps -ef | grep jackd | grep -v grep | wc -l`
+if [ ! $TMP == 0 ]; then
+  echo "jackd is already running. Stopping..."
+  # exit 1
+fi
+
+TMP=`ps -ef | grep sdr-core | grep -v grep | wc -l`
+if [ ! $TMP == 0 ]; then
+  echo "sdr-core is already running. Stopping..."
+  exit 1
+fi
+
+##########################################################################
+# Start jackd
+echo ">>>> Starting jack: $JACKD $JACKD_PARAM $JACKD_CUSTOM_PARAM"
+
+$JACKD $JACKD_PARAM $JACKD_CUSTOM_PARAM &
+
+JACKD_PID=$!
+if [ $JACKD_PID ] 
+then
+  echo $JACKD_PID > $VARRUN/jackd.pid
+  echo "  Succeeded. JackD PID is $JACKD_PID"
+  echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
+else
+  echo "  Failed"
+  exit 1
+fi
+
+##########################################################################
+# 
+# wait for jackd startup 
+#
+sleep 2
+
+if [ $UDP_HELPER ] 
+then
+   ##########################################################################
+   # Start the helpers
+   #
+   socat -u -b 65536   UDP-LISTEN:19002   PIPE:$SDR_SPECPATH  &
+   socat -u            UDP-LISTEN:19003   PIPE:$SDR_METERPATH &
+fi
+
+
+##########################################################################
+# Start dttsp
+echo ">>>> Starting dttsp: $DTTSP_EXEC $DTTSP_PARAM..."
+cd $DTTSP
+$DTTSP_EXEC $DTTSP_PARAM &
+DTTSP_RC=$?
+DTTSP_PID=$!
+
+if [ $DTTSP_RC == 0 ] 
+then
+   echo "$DTTSP_RC"
+   if [ $DTTSP_PID ] 
+   then
+     echo $DTTSP_PID > $VARRUN/sdr-core.pid
+     echo "  Succeeded. DttSP PID is $DTTSP_PID"
+     echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
+   else
+     echo "  Failed to start $DTTSP_EXEC"
+     exit 1
+   fi
+else
+   echo "  Failed"
+   exit 1
+fi 
+
+
+
+##########################################################################
+# Start the PMSDR
+#
+echo "> Start the pmsdr.... $PMSDR"
+$PMSDR &
+PMSDR_PID=$!
+if [ $PMSDR_PID ] 
+then
+  echo $PMSDR_PID > $VARRUN/pmsdr.pid
+  echo "  Succeeded. pmsdr PID is $PMSDR_PID"
+else
+  echo "  Failed"
+fi
+
+##########################################################################
+# Make sure that pmsdr is running
+#
+TMP=`killall -CONT pmsdr ; echo $?`
+if [ $TMP != 0 ]; then
+   echo "pmsdr not running. Stopping..." | gmessage -center -timeout 5 -file -
+   exit 1
+fi
+
+
+##########################################################################
+# Start the Dttsp command helper
+#
+if [ $UDP_HELPER ] 
+then
+   #
+   # using socat for command pipe sometime may cause an error due to
+   # sdr-core command interpreter that requires each command to travel in 
+   # a single packet udp packet; starting from DttSP release #223 Frank ab2kt 
+   # has written a small utility to circumvent the problem.
+   #
+   #socat -u     PIPE:$SDR_PARMPATH UDP:localhost:19001,connect-timeout=10 &
+   #
+   $DTTSP/passport $SDR_PARMPATH &
+fi
+
+
+##########################################################################
+#
+# Connect Dttsp to jack ports
+#
+echo ">>>> Connecting dttsp to jack..."
+
+echo "  sdr-$DTTSP_PID:ol -> alsa_pcm:playback_1"
+$JACKC sdr-$DTTSP_PID:ol alsa_pcm:playback_1
+echo "  sdr-$DTTSP_PID:or -> alsa_pcm:playback_2"
+$JACKC sdr-$DTTSP_PID:or alsa_pcm:playback_2
+echo "  alsa_pcm:capture_1 -> sdr-$DTTSP_PID:il"
+$JACKC alsa_pcm:capture_1 sdr-$DTTSP_PID:il
+echo "  alsa_pcm:capture_2 -> sdr-$DTTSP_PID:ir"
+$JACKC alsa_pcm:capture_2 sdr-$DTTSP_PID:ir
+
+##########################################################################
+#
+# Start the real thing ....
+#
+$SDRSHELL
+
+SDRSHELL_RC=$?
+
+exit $SDRSHELL_RC
+
